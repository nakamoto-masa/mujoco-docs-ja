概要
====

はじめに
--------

**MuJoCo** は **Mu**\ lti-**Jo**\ int dynamics with **Co**\ ntact（多関節接触動力学）の略称です。ロボティクス、バイオメカニクス、グラフィクスとアニメーション、機械学習など、環境と相互作用する多関節構造の高速かつ正確なシミュレーションを必要とする分野での研究開発を促進することを目的とした汎用物理エンジンです。
当初はRoboti LLCによって開発されましたが、2021年10月にDeepMindに買収され `無料で公開 <https://github.com/google-deepmind/mujoco/blob/main/LICENSE>`__ され、2022年5月にオープンソース化されました。MuJoCoのコードベースはGitHubの `google-deepmind/mujoco <https://github.com/google-deepmind/mujoco>`__ リポジトリで公開されています。

MuJoCoは研究者と開発者向けのC/C++ライブラリで、C APIを提供しています。ランタイムシミュレーションモジュールは性能を最大化するよう調整されており、組み込みのXMLパーサーとコンパイラによって事前に確保された低レベルデータ構造上で動作します。ユーザーはネイティブのMJCFシーン記述言語（可能な限り人間が読みやすく編集しやすいように設計されたXMLファイル形式）でモデルを定義します。URDFモデルファイルも読み込むことができます。ライブラリにはOpenGLでレンダリングされるネイティブGUIによるインタラクティブな可視化機能が含まれています。さらにMuJoCoは、物理関連の量を計算するための多数のユーティリティ関数を提供しています。

MuJoCoは、制御合成、状態推定、システム同定、機構設計、逆動力学によるデータ解析、機械学習アプリケーションのための並列サンプリングなど、モデルベースの計算を実装するために使用できます。また、ゲームやインタラクティブな仮想環境を含む、より従来型のシミュレータとしても使用できます。


.. _Features:

主要な特徴
~~~~~~~~~~

MuJoCoには多数の機能があります。ここでは最も注目すべきものを概説します。

一般化座標と最新の接触動力学の組み合わせ
   物理エンジンは伝統的に2つのカテゴリに分かれていました。ロボティクスやバイオメカニクス向けのエンジンは、一般化座標または関節座標における効率的で正確な再帰アルゴリズムを使用します。しかし、これらは接触動力学を省略するか、非常に小さなタイムステップを必要とする従来のバネ・ダンパーアプローチに頼っていました。ゲームエンジンは、最適化問題を解くことで接触力を求める、より現代的なアプローチを使用します。しかし、これらは関節制約を数値的に課す過剰指定されたデカルト表現に頼ることが多く、複雑な運動構造が関与する場合に不正確さや不安定性を引き起こします。MuJoCoは、一般化座標でのシミュレーションと最適化ベースの接触動力学という両方の長所を組み合わせた最初の汎用エンジンでした。他のシミュレータもより最近になってMuJoCoのアプローチを採用するよう適応されましたが、最初からそのように設計されていないため、通常はすべての機能との互換性がありません。ゲームエンジンに慣れたユーザーは、最初は一般化座標を直感に反すると感じるかもしれません。以下の :ref:`Clarifications` セクションを参照してください。

ソフトで凸かつ解析的に逆変換可能な接触動力学
   接触動力学の現代的なアプローチでは、摩擦接触によって引き起こされる力やインパルスは、通常、線形または非線形相補性問題（LCPまたはNCP）の解として定義されますが、いずれもNP困難です。MuJoCoは、 :doc:`computation/index` の章で詳しく説明されているように、凸最適化問題に帰着する接触物理学の異なる定式化に基づいています。我々のモデルはソフトな接触やその他の制約を許容し、データ解析や制御応用を容易にする一意に定義された逆変換を持ちます。楕円摩擦円錐を扱える射影ガウス・ザイデル法の一般化を含む、最適化アルゴリズムの選択肢があります。ソルバーは、ねじり摩擦やころがり摩擦を含む摩擦接触、無摩擦接触、関節やテンドンの限界、関節やテンドンの乾燥摩擦、さらに様々な等式制約を統一的に扱います。

テンドンジオメトリ
   MuJoCoはテンドンの3Dジオメトリをモデル化できます。テンドンとは、巻き付けや経由点制約に従う最短経路長の弦です。このメカニズムはOpenSimのものと類似していますが、計算を高速化するために、より制限された閉形式の巻き付きオプションセットを実装しています。また、プーリーや結合された自由度など、ロボティクス固有の構造も提供しています。テンドンはアクチュエーションに使用できるほか、テンドン長さに対する不等式または等式制約を課すためにも使用できます。

汎用的なアクチュエーションモデル
   モデルに依存しないAPIを使用しつつ、十分にリッチなアクチュエーションモデルを設計することは困難です。MuJoCoは、異なるタイプの伝達、力の生成、および内部動力学（すなわち、全体の動力学を3次にする状態変数）を持つことができる抽象的なアクチュエーションモデルを採用することで、この目標を達成しています。これらのコンポーネントをインスタンス化することで、モーター、空圧および油圧円筒、PDコントローラー、生体筋肉、その他多くのアクチュエータを統一的にモデル化できます。

再構成可能な計算パイプライン
   MuJoCoにはトップレベルのステッパー関数 :ref:`mj_step` があり、順動力学全体を実行してシミュレーションの状態を進めます。しかし、シミュレーション以外の多くのアプリケーションでは、計算パイプラインの選択した部分を実行できることが有益です。この目的のために、MuJoCoは多数の :ref:`フラグ <option-flag>` を提供しており、任意の組み合わせで設定できるため、 :ref:`オプション <option>` によるアルゴリズムやアルゴリズムパラメータの選択に加えて、必要に応じてパイプラインを再構成できます。さらに、多くの低レベル関数を直接呼び出すことができます。ユーザー定義のコールバックで、カスタムの力場、アクチュエータ、衝突ルーチン、フィードバックコントローラーを実装できます。

モデルのコンパイル
   前述のように、ユーザーはMJCFと呼ばれるXMLファイル形式でMuJoCoモデルを定義します。このモデルは組み込みコンパイラによって、ランタイム計算用に相互インデックス化され最適化された低レベルデータ構造 :ref:`mjModel` にコンパイルされます。コンパイルされたモデルはバイナリMJBファイルとしても保存できます。

.. _ModelAndData:

モデルとデータの分離
   MuJoCoはランタイム時にシミュレーションパラメータを2つのデータ構造（C構造体）に分離します：

   -  :ref:`mjModel` はモデルの記述を含み、定数であることが期待されます。シミュレーションおよび可視化オプションを含む他の構造体が埋め込まれており、それらのオプションは時折変更する必要がありますが、これはユーザーが行います。
   -  :ref:`mjData` はすべての動的変数と中間結果を含みます。すべての関数がそこから入力を読み取り、出力を書き込むスクラッチパッドとして使用されます。書き込まれた出力はシミュレーションパイプラインの後続ステージへの入力となります。また、事前に確保され内部的に管理されるスタックも含まれているため、モデルの初期化後にランタイムモジュールがメモリ確保関数を呼び出す必要がありません。

   :ref:`mjModel` はコンパイラによって構築されます。 :ref:`mjData` は :ref:`mjModel` を与えられてランタイム時に構築されます。この分離により、複数のモデルのシミュレーション、および各モデルに対する複数の状態と制御のシミュレーションが容易になり、サンプリングのための :ref:`マルチスレッド <siMultithread>` や :ref:`有限差分 <mjd_transitionFD>` が促進されます。トップレベルのAPI関数はこの基本的な分離を反映しており、以下の形式を持ちます：

   .. code:: C

      void mj_step(const mjModel* m, mjData* d);

インタラクティブなシミュレーションと可視化
   ネイティブの :ref:`3Dビジュアライザ <Visualization>` は、メッシュと幾何プリミティブ、テクスチャ、反射、影、霧、透明度、ワイヤーフレーム、スカイボックス、立体視（クアッドバッファOpenGLをサポートするビデオカードでの）のレンダリングを提供します。この機能は、物理シミュレーションに対する洞察をユーザーが得られるよう3Dレンダリングを生成するために使用され、自動生成されるモデルスケルトン、等価慣性ボックス、接触位置と法線、法線成分と接線成分に分離可能な接触力、外部摂動力、ローカルフレーム、関節とアクチュエータの軸、テキストラベルなどの視覚的補助を含みます。ビジュアライザはOpenGLレンダリングコンテキストを持つ汎用ウィンドウを想定しているため、ユーザーは好みのGUIライブラリを採用できます。MuJoCoに同梱されるコードサンプル :ref:`simulate.cc <saSimulate>` は、GLFWライブラリを使用してこれを行う方法を示しています。関連するユーザビリティ機能として、シミュレーション内に「手を伸ばして」オブジェクトを押し動かし、物理がどう応答するかを確認する機能があります。ユーザーは外力とトルクが適用されるボディを選択し、摂動とその動的結果のリアルタイムレンダリングを確認します。これを使用して、モデルを視覚的にデバッグしたり、フィードバックコントローラーの応答をテストしたり、モデルを望む姿勢に配置したりできます。

強力かつ直感的なモデリング言語
   MuJoCoにはMJCFと呼ばれる独自のモデリング言語があります。MJCFの目標は、MuJoCoのすべての計算機能へのアクセスを提供しつつ、ユーザーが新しいモデルを素早く開発し実験できるようにすることです。この目標は主に、HTMLにインライン化されたカスケーディングスタイルシート（CSS）に似た、広範な :ref:`デフォルト設定 <CDefault>` メカニズムによって達成されています。MJCFには多くの要素と属性がありますが、任意のモデルでユーザーが設定する必要があるものは驚くほど少数です。これにより、MJCFファイルは他の多くのフォーマットよりも短く読みやすくなっています。

柔軟な複合オブジェクトの自動生成
   MuJoCoのソフト制約は、ロープ、布、変形可能な3Dオブジェクトをモデル化するために使用できます。これには、多数の規則的なボディ、関節、テンドン、制約が協調して動作する必要があります。モデリング言語には、モデルコンパイラによって標準モデル要素の必要なコレクションに自動展開される高レベルマクロがあります。重要なのは、これらの柔軟オブジェクトがシミュレーションの他の部分と完全に相互作用できることです。

.. _Instance:

モデルインスタンス
~~~~~~~~~~~~~~~~~~

MuJoCoには「モデル」と呼ばれるいくつかの実体があります。ユーザーはMJCFまたはURDFで書かれたXMLファイルでモデルを定義します。
ソフトウェアは、異なる媒体（ファイルまたはメモリ）および異なる記述レベル（高レベルまたは低レベル）で同じモデルの複数のインスタンスを作成できます。以下の表に示すように、すべての組み合わせが可能です：

+----------------+---------------------------+----------------------------+
|                | 高レベル                  | 低レベル                   |
+================+===========================+============================+
| **ファイル**   | MJCF/URDF (XML)           | MJB (バイナリ)             |
+----------------+---------------------------+----------------------------+
| **メモリ**     | :ref:`mjSpec` (C構造体)   | :ref:`mjModel` (C構造体)   |
+----------------+---------------------------+----------------------------+

すべてのランタイム計算は :ref:`mjModel` で実行されますが、手動で作成するには複雑すぎます。このため2段階のモデリングがあります。高レベルはユーザーの利便性のために存在し、その唯一の目的は、計算を実行できる低レベルモデルにコンパイルされることです。生成された :ref:`mjModel` はバイナリファイル（MJB）に読み込みおよび保存できますが、これらはバージョン固有でありデコンパイルできないため、モデルは常にXMLファイルとして管理する必要があります。

:ref:`mjSpec` C構造体はMJCFファイルフォーマットと1対1で対応しています。XMLローダーはMJCFまたはURDFファイルを解釈し、対応する :ref:`mjSpec` を作成して :ref:`mjModel` にコンパイルします。ユーザーはプログラムで :ref:`mjSpec` を作成し、MJCFに保存するかコンパイルすることができます。手続き的なモデル作成と編集については :doc:`Model Editing <programming/modeledit>` の章で説明されています。

以下の図は :ref:`mjModel` を取得するための異なる経路を示しています：

-  （テキストエディタ） → MJCF/URDFファイル → （MuJoCoパーサー → mjSpec → コンパイラ） → mjModel
-  （ユーザーコード） → mjSpec → （MuJoCoコンパイラ） → mjModel
-  MJBファイル → （モデルローダー） → mjModel

.. _Examples:

使用例
~~~~~~

以下はMuJoCoのMJCFフォーマットによるシンプルなモデルです。ワールドに固定された平面、オブジェクトをより良く照らし影を投影するライト、6自由度の浮遊ボックス（これが「free」ジョイントの役割）を定義しています。

`hello.xml <_static/hello.xml>`__:

.. code:: xml

   <mujoco>
     <worldbody>
       <light diffuse=".5 .5 .5" pos="0 0 3" dir="0 0 -1"/>
       <geom type="plane" size="1 1 0.1" rgba=".9 0 0 1"/>
       <body pos="0 0 1">
         <joint type="free"/>
         <geom type="box" size=".1 .2 .3" rgba="0 .9 0 1"/>
       </body>
     </worldbody>
   </mujoco>

組み込みのOpenGLビジュアライザはこのモデルを次のようにレンダリングします：

.. image:: images/overview/hello.png
   :width: 300px
   :align: center

このモデルをシミュレートすると、ボックスは地面に落下します。レンダリングなしの受動動力学の基本的なシミュレーションコードを以下に示します。

.. code:: c

   #include "mujoco.h"
   #include "stdio.h"

   char error[1000];
   mjModel* m;
   mjData* d;

   int main(void) {
     // ファイルからモデルを読み込みエラーをチェック
     m = mj_loadXML("hello.xml", NULL, error, 1000);
     if (!m) {
       printf("%s\n", error);
       return 1;
     }

     // モデルに対応するデータを作成
     d = mj_makeData(m);

     // 10秒間シミュレーションを実行
     while (d->time < 10)
       mj_step(m, d);

     // モデルとデータを解放
     mj_deleteData(d);
     mj_deleteModel(m);

     return 0;
   }

これは技術的にはCファイルですが、正当なC++ファイルでもあります。実際、MuJoCo APIはCとC++の両方に互換性があります。通常、ユーザーコードはC++で記述されます。これは利便性が向上し、計算ボトルネックは既に高度に最適化されたシミュレータ内にあるため効率性を犠牲にしないからです。

関数 :ref:`mj_step` は、シミュレーション状態を1タイムステップ進めるトップレベル関数です。もちろんこの例は単なる受動力学系です。ユーザーが制御を指定したり力を加えたりしてシステムと相互作用し始めると、より興味深いものになります。

次に、MJCFのいくつかの機能を示すより詳細な例を提供します。以下の
`example.xml <_static/example.xml>`__ を考えてみましょう：

.. code:: xml

   <mujoco model="example">
     <default>
       <geom rgba=".8 .6 .4 1"/>
     </default>

     <asset>
       <texture type="skybox" builtin="gradient" rgb1="1 1 1" rgb2=".6 .8 1" width="256" height="256"/>
     </asset>

     <worldbody>
       <light pos="0 1 1" dir="0 -1 -1" diffuse="1 1 1"/>
       <body pos="0 0 1">
         <joint type="ball"/>
         <geom type="capsule" size="0.06" fromto="0 0 0  0 0 -.4"/>
         <body pos="0 0 -0.4">
           <joint axis="0 1 0"/>
           <joint axis="1 0 0"/>
           <geom type="capsule" size="0.04" fromto="0 0 0  .3 0 0"/>
           <body pos=".3 0 0">
             <joint axis="0 1 0"/>
             <joint axis="0 0 1"/>
             <geom pos=".1 0 0" size="0.1 0.08 0.02" type="ellipsoid"/>
             <site name="end1" pos="0.2 0 0" size="0.01"/>
           </body>
         </body>
       </body>

       <body pos="0.3 0 0.1">
         <joint type="free"/>
         <geom size="0.07 0.1" type="cylinder"/>
         <site name="end2" pos="0 0 0.1" size="0.01"/>
       </body>
     </worldbody>

     <tendon>
       <spatial limited="true" range="0 0.6" width="0.005">
         <site site="end1"/>
         <site site="end2"/>
       </spatial>
     </tendon>
   </mujoco>

.. raw:: html

   <figure class="align-right">
      <video width="200" height="295" muted autoplay loop>
         <source src="_static/example.mp4" type="video/mp4">
      </video>
   </figure>

このモデルは、反対側に円筒が取り付けられた紐を「保持」する7自由度のアームです。紐は長さ制限付きのテンドンとして実装されています。肩にはボールジョイント、肘と手首にはヒンジジョイントのペアがあります。円筒内のボックスはフリー「ジョイント」を示しています。XMLの外側のボディ要素は必須の :el:`worldbody` です。2つのボディ間で複数のジョイントを使用する場合、ダミーボディを作成する必要がないことに注目してください。

MJCFファイルにはモデルを指定するために必要な最小限の情報が含まれています。カプセルは空間内の線分で定義され、この場合はカプセルの半径のみが必要です。ボディフレームの位置と向きは、それに属するジオムから推定されます。慣性特性は均一密度の仮定のもとでジオム形状から推定されます。2つのサイトはテンドン定義が参照する必要があるため名前が付けられていますが、他には名前が付けられていません。関節軸はヒンジジョイントに対してのみ定義され、ボールジョイントには定義されていません。衝突ルールは自動的に定義されます。摩擦特性、重力、シミュレーションタイムステップなどはデフォルト値に設定されています。上部で指定されたデフォルトのジオムカラーはすべてのジオムに適用されます。

コンパイルされたモデルをバイナリMJBフォーマットで保存するだけでなく、MJCFまたは人間が読めるテキストとして保存することもできます。それぞれ
`example_saved.xml <_static/example_saved.xml>`__ と `example_saved.txt <_static/example_saved.txt>`__
を参照してください。XML版はオリジナルと類似していますが、テキスト版は ``mjModel`` からのすべての情報を含んでいます。テキスト版をXML版と比較すると、モデルコンパイラがどれだけの作業を代行してくれたかがわかります。

.. _Elements:

モデル要素
----------

このセクションでは、MuJoCoモデルに含めることができるすべての要素の簡単な説明を提供します。後ほど、基礎となる計算、要素がMJCFでどのように指定されるか、および ``mjModel`` における表現についてより詳しく説明します。

.. _Options:

オプション
~~~~~~~~~~

各モデルには以下に示す3組のオプションがあります。これらは常に含まれます。値がXMLファイルで指定されていない場合、デフォルト値が使用されます。オプションは、ユーザーが各シミュレーションタイムステップの前にその値を変更できるように設計されています。ただし、タイムステップ内ではオプションを変更してはいけません。

``mjOption``
^^^^^^^^^^^^

この構造体には、物理シミュレーションに影響するすべてのオプションが含まれています。アルゴリズムの選択とパラメータの設定、シミュレーションパイプラインの異なる部分の有効化と無効化、重力などのシステムレベルの物理特性の調整に使用されます。

``mjVisual``
^^^^^^^^^^^^

この構造体にはすべての可視化オプションが含まれています。追加のOpenGLレンダリングオプションがありますが、これらはセッション依存であり、モデルの一部ではありません。

``mjStatistic``
^^^^^^^^^^^^^^^

この構造体には、コンパイラによって計算されるモデルに関する統計情報が含まれています：平均ボディ質量、モデルの空間的広がりなど。情報提供の目的で含まれており、ビジュアライザが自動スケーリングに使用するためでもあります。

.. _Assets:

アセット
~~~~~~~~

アセットはそれ自体がモデル要素ではありません。モデル要素がアセットを参照でき、その場合アセットは参照元要素の特性を何らかの形で変更します。1つのアセットは複数のモデル要素から参照できます。アセットを含める唯一の目的は参照することであり、参照は名前によってのみ行えるため、すべてのアセットには名前があります（該当する場合はファイル名から推測されることがあります）。対照的に、通常の要素の名前は未定義のままにできます。

メッシュ
^^^^^^^^

MuJoCoはOBJファイルとバイナリSTLから三角化されたメッシュを読み込めます。 `MeshLab <https://www.meshlab.net/>`__ などのソフトウェアを使用して他のフォーマットから変換できます。三角形のコレクションは何でもメッシュとして読み込みおよび可視化できますが、衝突検出器は凸包で動作します。メッシュのスケーリングや、プリミティブな幾何形状へのフィッティングのためのコンパイル時オプションがあります。メッシュは慣性特性の自動推定にも使用できます。これは三角錐の和集合として扱い、それらの質量と慣性を組み合わせることで行われます。メッシュには色がないことに注意してください。代わりに、参照するジオムのマテリアルプロパティを使用してメッシュに色が付けられます。対照的に、すべての空間的特性はメッシュデータによって決定されます。MuJoCoは法線とテクスチャ座標に対してOBJとカスタムバイナリファイルフォーマットの両方をサポートしています。メッシュはXMLに直接埋め込むこともできます。

スキン
^^^^^^

スキンメッシュ（またはスキン）は、ランタイム時に形状が変形できるメッシュです。頂点は剛体（この文脈ではボーンと呼ばれます）にアタッチされ、各頂点は複数のボーンに属することができ、スキンの滑らかな変形をもたらします。スキンは純粋に可視化用のオブジェクトであり、物理に影響しませんが、視覚的なリアリズムを大幅に向上させることができます。スキンはカスタムバイナリファイルから読み込むか、メッシュと同様にXMLに直接埋め込むことができます。複合柔軟オブジェクトを自動生成する場合、モデルコンパイラはこれらのオブジェクトのスキンも生成します。

ハイトフィールド
^^^^^^^^^^^^^^^^

ハイトフィールドはPNGファイル（内部的にグレースケールに変換）またはカスタムバイナリフォーマットのファイルから読み込めます。ハイトフィールドは標高データの矩形グリッドです。コンパイラはデータを[0-1]の範囲に正規化します。ハイトフィールドの実際の空間的広がりは、参照するジオムのサイズパラメータによって決定されます。ハイトフィールドはワールドボディにアタッチされたジオムからのみ参照できます。レンダリングと衝突検出の目的で、グリッドの矩形は自動的に三角化されるため、ハイトフィールドは三角柱の和集合として扱われます。このような複合オブジェクトとの衝突検出は、原理的に1つのジオムペアに対して多数の接触点を生成する可能性があります。その場合、最初の64個の接触点のみが保持されます。この根拠は、ハイトフィールドはシミュレーション内の他のオブジェクトと比較して空間的特徴が大きい地形マップのモデル化に使用されるべきであり、適切に設計されたモデルでは接触数は少なくなるということです。

テクスチャ
^^^^^^^^^^

テクスチャはPNGファイルから読み込むか、ユーザー定義の手続きパラメータに基づいてコンパイラが合成できます。モデル作成時にテクスチャを空のまま残し、後からランタイム時に変更するオプションもあります。これにより、MuJoCoシミュレーション内でビデオをレンダリングしたり、その他の動的エフェクトを作成できます。ビジュアライザは2種類のテクスチャマッピングをサポートしています：2Dとキューブ。2Dマッピングは平面やハイトフィールドに有用です。キューブマッピングは、テクスチャ座標を指定することなく3Dオブジェクトにテクスチャを「シュリンクラップ」するのに有用です。スカイボックスの作成にも使用されます。キューブマップの6面は、個別の画像ファイルから、1つの合成画像ファイルから、または同じ画像を繰り返して読み込めます。モデル要素から直接参照される他のすべてのアセットとは異なり、テクスチャは別のアセット（すなわちマテリアル）からのみ参照でき、そのマテリアルがモデル要素から参照されます。

マテリアル
^^^^^^^^^^

マテリアルは、ジオム、サイト、テンドンの外観を制御するために使用されます。これは対応するモデル要素からマテリアルを参照することで行います。外観には、テクスチャマッピングに加えて、以下のOpenGLライトと相互作用する他の特性が含まれます：RGBA、スペキュラリティ、光沢度、発光。マテリアルはオブジェクトを反射性にするためにも使用できます。現在、反射は平面とボックスのZ+面にのみレンダリングされます。モデル要素にも色を設定するためのローカルRGBAパラメータがあることに注意してください。マテリアルとローカルRGBAの両方が指定されている場合、ローカルの定義が優先されます。

.. _Kinematic:

キネマティックツリー
~~~~~~~~~~~~

MuJoCoは、動きが通常制約される剛体の集合の動力学をシミュレートします。システム状態は関節座標で表現され、ボディはキネマティックツリーに明示的に整理されます。ツリー構造は ``mjModel.body_parentid`` という長さ ``nbody >= 1`` の整数配列で与えられます。トップレベルの「ワールド」ボディは常に存在し（id ``0``）、自身の親であるため、 ``body_parentid[0] == 0`` であり、他のすべての ``i`` について ``body_parentid[i] < i`` です。
ワールドボディやその他の静的（ジョイントのない）子ボディは、自由度を持たない固有の「静的ツリー」を形成することに注意してください。このトップレベルの静的ツリーの下に、複数のキネマティックツリーをアタッチできます。以下の :ref:`Tree <ElemTree>` を参照してください。

運動学ループは許可されていません。ループジョイントが必要な場合は、等式制約でモデル化する必要があります。したがって、MuJoCoモデルの骨格は、ネストされたボディ定義によって形成される1つまたは複数のキネマティックツリーです。単独の浮遊ボディもツリーとして数えられます。以下に示すいくつかの要素はボディ内で定義され、そのボディに属します。これは、後述する単独のボディに関連付けられないスタンドアロン要素とは対照的です。

.. _ElemBody:

ボディ
^^^^^^

ボディには質量と慣性特性がありますが、幾何特性はありません。代わりに、幾何形状（またはジオム）がボディにアタッチされます。各ボディには2つの座標フレームがあります：ボディを定義し他の要素をその相対位置に配置するためのフレームと、ボディの重心に中心を置き主慣性軸に整列した慣性フレームです。ボディ慣性行列はこのフレームでは対角行列になります。各タイムステップでMuJoCoは順運動学を再帰的に計算し、すべてのボディの位置と向きをグローバル直交座標で生成します。これが後続のすべての計算の基礎となります。
ボディの数は ``mjModel.nbody`` で与えられます。

.. _ElemJoint:

ジョイント
^^^^^^^^^^

ジョイントはボディ内で定義されます。ボディとその親の間に運動の自由度（DOF）を作成します。ジョイントがない場合、ボディは親に溶接されます。これは、ジョイントがDOFを追加するのではなく削除する、過剰な直交座標を使用するゲームエンジンとは逆です。ジョイントには4つのタイプがあります：ボール、スライド、ヒンジ、および浮遊ボディを作成する「フリージョイント」です。1つのボディに複数のジョイントを持たせることができます。このようにして、ダミーボディを定義することなく複合ジョイントが自動的に作成されます。ボールジョイントとフリージョイントの向き成分は単位クォータニオンとして表現され、MuJoCoのすべての計算はクォータニオンの性質を尊重します。ジョイントの数は ``mjModel.njnt`` で与えられます。

ジョイント参照
''''''''''''''

参照姿勢は ``mjModel.qpos0`` に格納されるジョイント位置のベクトルです。モデルが初期設定にあるときのジョイントの数値に対応します。先の例では、肘は90°の角度の曲がった設定で作成されました。しかしMuJoCoは肘が何であるかを知らないため、デフォルトではこのジョイント設定を数値0として扱います。デフォルトの動作をオーバーライドし、 :ref:`joint <body-joint>` のref属性を使用して初期設定が90°に対応することを指定できます。すべてのジョイントの参照値は ``mjModel.qpos0`` ベクトルに集約されます。シミュレーションがリセットされると、ジョイント設定 ``mjData.qpos`` は ``mjModel.qpos0`` に設定されます。ランタイム時にジョイント位置ベクトルは参照姿勢に対して相対的に解釈されます。特に、ジョイントが適用する空間変換の量は ``mjData.qpos - mjModel.qpos0`` です。この変換は ``mjModel`` のボディ要素に格納される親子間の並進および回転オフセットに加えて行われます。ref属性はスカラージョイント（スライドとヒンジ）にのみ適用されます。ボールジョイントの場合、 ``mjModel.qpos0`` に保存されるクォータニオンは常にヌル回転に対応する(1,0,0,0)です。フリージョイントの場合、浮遊ボディのグローバル3D位置とクォータニオンが ``mjModel.qpos0`` に保存されます。

バネ参照
''''''''

これは、すべてのジョイントとテンドンのバネが自然長を達成する姿勢です。ジョイント設定がバネ参照姿勢から逸脱するとバネ力が生成され、逸脱量に対して線形です。バネ参照姿勢は ``mjModel.qpos_spring`` に保存されます。スライドおよびヒンジジョイントの場合、バネ参照は属性springrefで指定されます。ボールおよびフリージョイントの場合、バネ参照は初期モデル設定に対応します。

.. _ElemDof:

自由度（DOF）
^^^^^^^^^^^^^

自由度はジョイントと密接に関連していますが、ボールジョイントとフリージョイントは複数のDOFを持つため、1対1の対応ではありません。ジョイントは位置情報を指定し、DOFは速度と力の情報を指定すると考えてください。より形式的には、ジョイント位置はシステムの設定多様体上の座標であり、ジョイント速度は現在位置におけるこの多様体の接空間上の座標です。DOFには摩擦損失、減衰、アーマチュア慣性などの速度関連特性があります。システムに作用するすべての一般化力はDOFの空間で表現されます。対照的に、ジョイントには限界やバネ剛性などの位置関連特性があります。DOFはユーザーが直接指定するものではなく、ジョイントが与えられるとコンパイラによって作成されます。DOFの数は ``mjModel.nv`` で与えられます。

.. _ElemTree:

ツリー
^^^^^^

:ref:`上記 <Kinematic>` で説明したように、可動ボディはキネマティックツリーに整理されます。キネマティックツリーまたは「ツリー」とは *可動ボディとそのすべての子孫* です。したがって、ワールドやその他の静的ボディはグローバルツリー構造に含まれますが、いかなる *ツリー* にも関連付けられません。グローバルツリー構造は深さ優先の構成を使用するため、1つのツリーに属するすべてのボディ、ジョイント、DOFは常に連続しています。静的であればどのツリーにも関連付けられないボディとは異なり、ジョイントとDOFは常にツリーに関連付けられることに注意してください。 :ref:`アイランド発見 <soIsland>` と :ref:`アイランドスリープ <Sleeping>` の両方がツリーレベルで動作します。

ツリーの数は ``mjModel.ntree`` で与えられます。例えば、3つのフリーボディと `標準的なヒューマノイド <https://github.com/google-deepmind/mujoco/blob/main/model/humanoid/humanoid.xml>`__ を含むモデルでは ``ntree = 4`` です。ツリーは確かにグローバルツリー（ルートはワールド）のサブツリーですが、これは特定の用語 ``subtree`` と混同しないでください。subtreeはボディごとの部分ツリー用に予約されており、 ``mjModel.body_subtreemass`` はすべてのボディに対して各ボディの下にある部分ツリーの総質量を与えます。

.. _ElemGeom:

ジオム
^^^^^^

ジオムはボディに剛体的にアタッチされた3D形状です。同じボディに複数のジオムをアタッチできます。これは、MuJoCoが凸ジオム同士の衝突のみをサポートしており、非凸オブジェクトを作成する唯一の方法は凸ジオムの和集合として表現することである点で特に有用です。衝突検出とそれに続く接触力の計算に加えて、ジオムはレンダリングに使用され、後者が省略された場合のボディ質量と慣性の自動推定にも使用されます。MuJoCoはいくつかのプリミティブ幾何形状をサポートしています：平面、球、カプセル、楕円体、円筒、ボックス。ジオムはメッシュやハイトフィールドにもでき、これは対応するアセットを参照することで行います。ジオムにはシミュレーションと可視化に影響する多数のマテリアル特性があります。
ジオムの数は ``mjModel.ngeom`` で与えられます。

.. _ElemSite:

サイト
^^^^^^

サイトは本質的に軽量なジオムです。ボディフレーム内の関心のある場所を表します。サイトは衝突検出や慣性特性の自動計算には参加しませんが、センサー、テンドンルーティング、スライダークランクのエンドポイントなど他のオブジェクトの空間的特性を指定するために使用できます。
サイトの数は ``mjModel.nsite`` で与えられます。

.. _ElemCamera:

カメラ
^^^^^^

モデル内に複数のカメラを定義できます。インタラクティブビジュアライザでマウスで自由に移動できるデフォルトカメラが常に存在します。しかし、ワールドに固定されるか、ボディの1つにアタッチされてそれと共に動く追加カメラを定義することがしばしば便利です。カメラの位置と向きに加えて、ユーザーは垂直視野角とステレオスコピックレンダリングのための瞳孔間距離を調整でき、ステレオスコピック仮想環境に必要な斜め投影も作成できます。不完全な光学系を持つ実カメラをモデル化する場合、水平方向と垂直方向で別々の焦点距離と中心からずれた主点を指定できます。
カメラの数は ``mjModel.ncam`` で与えられます。

.. _ElemLight:

ライト
^^^^^^

ライトはワールドボディに固定するか、可動ボディにアタッチできます。ビジュアライザはOpenGL（固定機能）の完全なライティングモデルへのアクセスを提供します。これにはアンビエント、ディフューズ、スペキュラの各成分、減衰とカットオフ、位置ライティングと指向性ライティング、フォグが含まれます。ライト、より正確にはそれによって照らされるオブジェクトは影も投影できます。ただし、マテリアル反射と同様に、影を投影する各ライトはレンダリングパスを1つ追加するため、この機能は注意して使用する必要があります。ライティングモデルの詳細なドキュメントはこの章の範囲外です。代わりに `OpenGLドキュメント <http://www.glprogramming.com/red/chapter05.html>`__ を参照してください。キネマティックツリー内でユーザーが定義するライトに加えて、カメラと共に移動するデフォルトのヘッドライトがあることに注意してください。そのプロパティはmjVisualオプションを通じて調整されます。
ライトの数は ``mjModel.nlight`` で与えられます。

.. _Standalone:

スタンドアロン
~~~~~~~~~~~~~~

ここでは、個々のボディに属さず、したがってキネマティックツリーの外部で記述されるモデル要素を説明します。

.. _ElemTendon:

テンドン
^^^^^^^^

テンドンは、アクチュエーション、限界や等式制約の課与、バネ・ダンパーや摩擦損失の作成に使用できるスカラー長さ要素です。テンドンには固定テンドンと空間テンドンの2種類があります。固定テンドンは（スカラー）ジョイント位置の線形結合です。機械的結合のモデル化に有用です。空間テンドンは、指定されたサイト（または経由点）のシーケンスを通過するか、指定されたジオムの周りを巻き付く最短経路として定義されます。巻き付きジオムとしてサポートされているのは球と円筒のみで、円筒は巻き付き目的では無限長として扱われます。テンドンが巻き付きジオムの一方の側から他方の側に突然ジャンプするのを避けるため、ユーザーは優先する側も指定できます。テンドン経路に複数の巻き付きジオムがある場合、反復ソルバーの必要性を避けるため、サイトで区切る必要があります。空間テンドンはプーリーを使用して複数のブランチに分割することもできます。

.. _ElemActuator:

アクチュエータ
^^^^^^^^^^^^^^

MuJoCoは柔軟なアクチュエータモデルを提供しており、独立して指定できる3つのコンポーネントがあります。これらが一体となってアクチュエータの動作を決定します。一般的なアクチュエータタイプは、これらのコンポーネントを協調的に指定することで得られます。3つのコンポーネントは、伝達、活性化ダイナミクス、力の生成です。伝達はアクチュエータがシステムの他の部分にどのように接続されるかを指定します。利用可能なタイプは関節、テンドン、スライダークランクです。活性化ダイナミクスは空圧または油圧円筒や生体筋肉の内部活性化状態をモデル化するために使用できます。このようなアクチュエータを使用すると、全体のシステム動力学が3次になります。力の生成メカニズムは、アクチュエータへの入力として提供されるスカラー制御信号がスカラー力にどのようにマッピングされるかを決定します。この力は伝達から推定されるモーメントアームによって一般化力にマッピングされます。

.. _ElemSensor:

センサー
^^^^^^^^

MuJoCoは、グローバル配列 ``mjData.sensordata`` に保存されるシミュレートされたセンサーデータを生成できます。結果は内部計算では使用されず、ユーザーがカスタム計算やデータ解析に必要であると想定されるために提供されます。利用可能なセンサータイプには、タッチセンサー、慣性計測ユニット（IMU）、力・トルクセンサー、ジョイントおよびテンドンの位置・速度センサー、アクチュエータの位置・速度・力センサー、モーションキャプチャマーカーの位置とクォータニオン、磁力計があります。これらの一部は追加の計算を必要としますが、その他は ``mjData`` の対応するフィールドからコピーされます。ユーザーセンサーもあり、ユーザーコードがセンサーデータ配列にその他の関心のある量を挿入できます。MuJoCoにはオフスクリーンレンダリング機能もあり、カラーカメラと深度カメラの両方のセンサーを簡単にシミュレートできます。これは標準的なセンサーモデルには含まれておらず、コードサンプル :ref:`simulate.cc <saSimulate>` に示されているようにプログラムで行う必要があります。

.. _ElemEquality:

等式制約
^^^^^^^^

等式制約は、キネマティックツリー構造とそこに定義されたジョイント/DOFによって既に課されている制約に加えて、追加の制約を課すことができます。ループジョイントの作成や、一般的に機械的結合のモデル化に使用できます。これらの制約を強制する内力は、他のすべての制約力と一緒に計算されます。利用可能な等式制約のタイプは：2つのボディを1点で接続（キネマティックツリー外にボールジョイントを作成）、2つのボディを溶接、ジョイントまたはテンドンの位置を固定、3次多項式を介して2つのジョイントまたは2つのテンドンの位置を結合、フレックス（すなわち変形メッシュ）のエッジを初期長さに制約。

.. _ElemFlex:

フレックス
^^^^^^^^^^

フレックスは1、2、または3次元の変形メッシュを表します（したがってその要素はカプセル、三角形、または四面体です）。ボディに剛体的にアタッチされた静的形状であるジオムとは異なり、フレックスの要素は変形可能です。複数のボディを接続して構築されるため、ボディの位置と向きがランタイム時のフレックス要素の形状を決定します。これらの変形可能な要素は衝突と接触力をサポートし、変形可能なエンティティの形状をソフトに保存するパッシブ力と制約力も生成します。ファイルからメッシュを読み込み、メッシュ頂点に対応するボディを構築し、メッシュ面（または次元に応じて線や四面体）に対応するフレックス要素を構築し、対応する変形可能なメッシュを取得するための自動化が提供されています。

接触ペア
^^^^^^^^

MuJoCoにおける接触生成は手の込んだプロセスです。接触がチェックされるジオムペアは2つのソースから来ます：自動近接テストやその他のフィルターをまとめて「動的」と呼ぶものと、モデルで提供されるジオムペアの明示的なリストです。後者は別のタイプのモデル要素です。接触は2つのジオムの組み合わせを含むため、明示的な指定により、動的メカニズムでは不可能な方法で接触パラメータを定義できます。特に、攻撃的なフィルタリングスキームによって除去された接触ペアを追加するなど、接触モデルの微調整にも有用です。接触メカニズムはフレックス要素にも拡張されており、2つ以上のボディ間の接触相互作用を作成できます。ただし、このような衝突は自動化されており、接触ペアを使用した微調整はできません。

接触除外
^^^^^^^^

これは接触ペアの逆で、候補接触ペアの生成から除外すべきボディ（ジオムではなく）のペアを指定します。ジオメトリが望ましくない恒久的な接触を引き起こすボディ間の接触を無効にするのに有用です。MuJoCoにはこの状況に対処する他のメカニズムがあります（特に、同じボディに属するジオムや親子ボディのジオムは衝突できません）が、これらの自動メカニズムでは不十分な場合もあり、明示的な除外が必要になります。

カスタム数値
^^^^^^^^^^^^

MuJoCoシミュレーションにカスタム数値を入力する方法は3つあります。第一に、グローバル数値フィールドをXMLで定義できます。名前と実数値の配列を持ちます。第二に、特定のモデル要素の定義を要素固有のカスタム配列で拡張できます。これはXML要素 ``size`` の属性 ``nuser_XXX`` を設定することで行います。第三に、MuJoCoの計算で使用されない配列 ``mjData.userdata`` があります。ユーザーはカスタム計算の結果をそこに格納できます。時間とともに変化するものはすべて ``mjModel`` ではなく ``mjData`` に格納する必要があることを覚えておいてください。

カスタムテキスト
^^^^^^^^^^^^^^^^

カスタムテキストフィールドをモデルに保存できます。カスタム計算で使用できます。キーワードコマンドの指定や、その他のテキスト情報の提供に使用します。ただし、コメントには使用しないでください。コンパイルされたモデルにコメントを保存しても利点はありません。XML自体のコメントメカニズム（MuJoCoのパーサーとコンパイラに無視される）の方が適切です。

カスタムタプル
^^^^^^^^^^^^^^

カスタムタプルは、他のタプルを含む可能性のあるMuJoCoモデル要素のリストです。シミュレータでは使用されませんが、ユーザーコードに必要な要素のグループを指定するために利用できます。例えば、タプルを使用してカスタム接触処理のためのボディペアを定義できます。

キーフレーム
^^^^^^^^^^^^

キーフレームはシミュレーション状態変数のスナップショットです。ジョイント位置、ジョイント速度、存在する場合はアクチュエータの活性化、およびシミュレーション時間のベクトルを含みます。モデルにはキーフレームのライブラリを含めることができます。システムの状態を関心のあるポイントにリセットするのに有用です。キーフレームはモデル内にトラジェクトリデータを格納するためのものではないことに注意してください。この目的には外部ファイルを使用する必要があります。

.. _Clarifications:

注意事項
--------

読者は他の物理シミュレータや関連する慣例、およびMuJoCoと整合しない一般的なプログラミング慣行の経験があるかもしれません。これは混乱を引き起こす可能性があります。このセクションの目的は、最も混乱を招きやすい側面を予防的に明確にすることです。FAQと選択されたトピックに関するチュートリアルの中間に位置します。ドキュメントの後半で扱う内容を参照する必要がありますが、以下のテキストは可能な限り自己完結的かつ入門的です。

.. _Divergence:

発散
~~~~

シミュレーションの発散は、状態の要素が急速に無限大に向かう場合に発生します。MuJoCoではこれは通常 :ref:`mjWARN_BADQACC<mjtwarning>` 警告として現れます。発散はすべての物理シミュレーションに固有のものであり、必ずしも悪いモデルやシミュレータのバグを示すものではなく、タイムステップが選択された積分器に対して大きすぎることを示唆しています。物理シミュレーションでは常に速度（大きなタイムステップ）と安定性（小さなタイムステップ）の間に緊張があります。速度のために適切に調整されたモデルは、発散しない最大のタイムステップを持ち、これは通常、極端な条件下では発散 *し得る* ことを意味します。その意味で、 *まれな* 発散は実際に適切に調整されたモデルの兆候であり得ます。すべての場合において、タイムステップを減少させたり、より安定した :ref:`積分器 <geIntegration>` に切り替えることで発散を防止できるはずです。それでも失敗する場合は原因が異なります。例えば、ボディが貫通した状態で初期化されるモデルでは、大きな反発力がボディを押し出して発散を引き起こす可能性があります。


.. _Units:

単位は未指定
~~~~~~~~~~~~

MuJoCoは基本的な物理単位を指定しません。ユーザーは一貫している限り、単位系を自由に解釈できます。これを理解するために例を考えましょう：1メートルの宇宙船が1キログラムで1ニュートンのスラスタを持つ場合の動力学は、1 cmの宇宙船が1グラムで1ダインのスラスタを持つ場合と同じです。これは `MKS <https://en.wikipedia.org/wiki/MKS_system_of_units>`__ と `CGS <https://en.wikipedia.org/wiki/Centimetre%E2%80%93gram%E2%80%93second_system_of_units>`__ の両方が一貫した単位系だからです。この性質により、ユーザーは好みに応じてモデルをスケーリングでき、非常に小さいものや大きいものをシミュレートする際にシミュレーションの数値特性を改善するのに有用です。

ただし、MuJoCoが2箇所でMKS風のデフォルト値を使用しているため、ユーザーにはMKSの使用が推奨されます：

- :ref:`gravity<option>` のデフォルト値は(0, 0, -9.81)で、MKSにおける地球表面重力に対応します。
  ただし、これは厳密にはMKS単位系を指定するものではありません。 `エンケラドゥス <https://en.wikipedia.org/wiki/Enceladus>`__ でCGSを使用しているかもしれないからです。
- :ref:`ジオム密度<body-geom>` のデフォルト値（ボディ質量と慣性の推定に使用）は1000で、MKSにおける水の密度に対応します。

基本単位（長さ、質量、時間）の一貫した系が選択されると、 `次元解析 <https://en.wikipedia.org/wiki/Dimensional_analysis>`__ と同様に、すべての派生単位はこの系に対応します。例えば、モデルがMKSとして解釈される場合、力とトルクはそれぞれニュートンとニュートン・メートルです。

**角度について：** MJCFでは角度を度で指定できますが（実際に度が :ref:`デフォルト <compiler>` です）、 :ref:`mjModel` と :ref:`mjData` のすべての角度量は `ラジアン <https://en.wikipedia.org/wiki/Radian>`__ で表現されます。したがって、例えばMKSを使用している場合、 :ref:`ジャイロスコープ<sensor-gyro>` が報告する角速度はrad/sとなり、ヒンジジョイントの剛性はNm/radとなります。


.. _SurprisingCollisions:

予想外の衝突
~~~~~~~~~~~~

MuJoCoはデフォルトで、直接的な親子関係を持つボディペアに属するジオム間の衝突を除外します。例えば、上記の :ref:`Examples` セクションのアームモデルを考えてみましょう：前腕が上腕の直接の子であるため、カプセルジオムが貫通しているにもかかわらず「肘」での衝突はありません。

しかし、この除外は **親が静的ボディの場合は適用されません** 。すなわち、ワールドボディ、またはワールドボディに対して自由度を持たないボディの場合です。この動作は :ref:`衝突検出<Collision>` セクションに文書化されており、オブジェクトが床を突き抜けたり壁を通り抜けたりするのを防ぎます。しかし、この動作はしばしば以下の状況につながります：

ユーザーが浮遊ベースモデルのルートジョイントをコメントアウトする。おそらく落下を防ぐためですが、ベースボディが静的として扱われるため、以前は存在しなかった新しい衝突が現れ、ユーザーは混乱します。この問題を避ける簡単な方法が2つあります：

1. ルートジョイントを削除しないでください。 :ref:`重力を無効化<option-flag>` し、場合によっては :ref:`流体粘性<option>` を追加することで、モデルが動き回りすぎるのを防ぐだけで十分かもしれません。

2. :ref:`衝突フィルタリング<Collision>` を使用して、不要な衝突を明示的に無効にしてください。関連する :at:`contype` と :at:`conaffinity` 属性を設定するか、接触 :ref:`除外 <contact-exclude>` ディレクティブを使用します。


.. _NotObject:

オブジェクト指向ではない
~~~~~~~~~~~~~~~~~~~~~~~~

オブジェクト指向プログラミングは非常に有用な抽象化であり、データ構造とそれに作用する関数というより基本的な（ハードウェアにより近い）概念の上に構築されています。オブジェクトとは、1つの意味的実体に対応するデータ構造と関数のコレクションであり、アプリケーションの他の部分よりもそれらの間に強い依存関係を持ちます。ここでこれを使用しない理由は、依存構造が物理シミュレータ全体が自然な実体であるようなものだからです。オブジェクトの代わりに、少数のデータ構造とそれに作用する多数の関数があります。

グループ化の一種は使用していますが、オブジェクト指向のアプローチとは異なります。モデル（``mjModel``）とデータ（``mjData``）を分離しています。これらは両方ともデータ構造です。モデルはモデル化されている物理システムの定数プロパティを記述するために必要なすべてを含み、データは時変状態と内部計算の再利用可能な中間結果を含みます。すべてのトップレベル関数は ``mjModel`` と ``mjData`` へのポインタを引数として想定しています。このようにして、ワークスペースを汚染しマルチスレッドを妨げるグローバル変数を回避しますが、オブジェクト指向プログラミングが同じ効果を達成する方法とは異なる方法で行っています。

.. _Soft:

柔軟性と滑り
~~~~~~~~~~~~~~~~~~~~

:doc:`computation/index` の章で詳しく説明するように、MuJoCoは接触やその他の制約の物理学の数学モデルに基づいています。このモデルは本質的にソフトであり、制約に対してより強く押すと常により大きな加速度が生じるため、逆動力学を一意に定義できます。これは凸最適化問題をもたらし、逆動力学に依存する解析を可能にし、さらに実際にモデル化する必要がある接触のほとんどにはある程度の柔軟性があるため望ましいことです。しかし、ソフト制約を許容すると、実質的に変形動力学という新しいタイプの動力学を作成することになり、これらの動力学がどのように振る舞うかを指定する必要があります。これには、制約ごとに設定できる属性 :at:`solref` と :at:`solimp` を含む、接触やその他の制約の精緻なパラメータ化が必要であり、後述されます。

このソフトモデルのしばしば混乱を招く側面は、漸進的な接触滑りを回避できないことです。同様に、摩擦ジョイントは重力の下で徐々に降伏します。これはソルバーが滑りを防止できないためではなく、つまり摩擦円錐や摩擦損失限界に到達するという意味でではなく、そもそも滑りを防止しようとしていないためです。与えられた制約に対してより大きな力はより大きな加速度をもたらさなければならないことを思い出してください。滑りが完全に抑制されると、この重要な特性が違反されなければなりません。したがって、シミュレーションで漸進的な滑りが見られる場合、直感的な説明は摩擦が不十分であるというものかもしれませんが、MuJoCoではそれはめったにありません。代わりに、この効果を減らすために ``solref`` と ``solimp`` パラメータベクトルを調整する必要があります。制約インピーダンス（``solimp`` の最初の2要素）およびグローバル設定 ``mjModel.opt.impratio`` を増加させることが特に効果的です。このような調整は非線形動力学の数値積分をより困難にするため、シミュレーションの安定性を保つためにより小さなタイムステップを必要とすることが多いです。滑りはニュートンソルバーによっても削減されますが、これは一般的により正確です。

滑りを完全に抑制することが望ましい状況のために、メインソルバーの後に実行される2番目の ``noslip`` ソルバーがあります。これは摩擦次元の接触力を制約の柔軟性を無視して更新します。ただし、このオプションを使用すると、MuJoCoは設計された凸最適化問題を解いていないことになり、シミュレーションのロバスト性が低下する可能性があります。したがって、楕円摩擦円錐と大きな ``impratio`` 値を持つニュートンソルバーの使用が滑り低減の推奨方法です。より詳細な推奨事項については、モデリングの章の :ref:`滑りの防止<CSlippage>` を参照してください。

.. _TypeNameId:

型、名前、ID
~~~~~~~~~~~~~

MuJoCoは前述のように多数のモデル要素をサポートしています。各要素型は ``mjModel`` に対応するセクションを持ち、さまざまなプロパティが列挙されます。例えば、ジョイント限界データは以下の配列にあります

.. code:: C

   mjtNum* jnt_range;             // ジョイント限界       (njnt x 2)

各配列のサイズ（この場合は ``njnt``）も ``mjModel`` で与えられます。最初のジョイントの限界が最初に含まれ、次に2番目のジョイントの限界が続きます。この順序は、MuJoCoのすべての行列が行優先フォーマットであることを反映しています。

利用可能な要素型は `mjmodel.h <https://github.com/google-deepmind/mujoco/blob/main/include/mujoco/mjmodel.h#L237>`_ のenum型 :ref:`mjtObj` で定義されています。これらのenumは主に内部的に使用されます。例外の1つは、MuJoCo APIの関数 :ref:`mj_name2id` と :ref:`mj_id2name` で、要素名を整数IDに、またその逆にマッピングします。これらの関数は要素型を入力として受け取ります。

XMLでモデル要素に名前を付けることは任意です。同じ型の2つの要素（例えば2つのジョイント）は同じ名前を持つことができません。名前付けはモデルの他の場所で要素を参照する必要がある場合にのみ必須です。XMLでの参照は名前によってのみ行えます。モデルがコンパイルされると、名前はユーザーの利便性のために ``mjModel`` にまだ格納されていますが、シミュレーションに対するさらなる影響はありません。名前は対応する整数IDを見つけるため、およびレンダリングに有用です：例えばジョイントラベルを有効にすると、各ジョイントの横に文字列が表示されます（名前が未定義の要素は「joint N」とラベル付けされ、Nは IDです）。

要素の整数IDはMuJoCoデータ配列のインデックスに不可欠です。IDはCの慣例に従い0ベースです。``mjModel* m`` が既にあるとします。「elbow」という名前のジョイントの範囲を表示するには：

.. code:: C

   int jntid = mj_name2id(m, mjOBJ_JOINT, "elbow");
   if (jntid >= 0)
      printf("(%f, %f)\n", m->jnt_range[2*jntid], m->jnt_range[2*jntid+1]);


名前が見つからない場合、関数は-1を返すため、常にid>=0をチェックする必要があります。

.. _BodyGeomSite:

ボディ、ジオム、サイト
~~~~~~~~~~~~~~~~~~~~~~

ボディ、ジオム、サイトは、物理世界の剛体に大まかに対応するMuJoCo要素です。ではなぜこれらは分離されているのでしょうか？以下にその意味的および計算上の理由を説明します。

まず類似点について。ボディ、ジオム、サイトはすべて空間フレームがアタッチされています（ただしボディにはボディ重心に中心を置き主慣性軸に整列した第2のフレームもあります）。これらのフレームの位置と向きは、順運動学により ``mjData.qpos`` から各タイムステップで計算されます。順運動学の結果は ``mjData`` 内でボディにはxpos、xquat、xmatとして、ジオムにはgeom_xpos、geom_xmatとして、サイトにはsite_xpos、site_xmatとして利用できます。

次に相違点について。ボディはキネマティックツリーを構築し、ジオムやサイトを含む他の要素のコンテナとして使用されます。ボディには空間フレームと慣性特性がありますが、外観や衝突ジオメトリに関する特性はありません。これは、このような特性は物理に影響しないためです（接触は当然影響しますが、これらは別途処理されます）。ロボティクスの教科書でキネマティックツリーの図を見たことがあれば、ボディは通常、無定形の形状として描かれています。これは実際の形状が物理に関係ないという点を強調するためです。

ジオム（geometric primitiveの略）は外観と衝突ジオメトリを指定するために使用されます。各ジオムはボディに属し、そのボディに剛体的にアタッチされます。同じボディに複数のジオムをアタッチできます。これは、MuJoCoの衝突検出器がすべてのジオムを凸であると仮定する（メッシュが凸でない場合は内部的に凸包に置き換える）ため、特に有用です。非凸形状をモデル化したい場合は、凸ジオムの和集合に分解して同じボディにすべてアタッチする必要があります。

ジオムにはXMLで密度または質量の値も指定でき、モデルコンパイラはこれを使用して親ボディの質量と慣性を計算します。質量はジオムの体積と :ref:`密度 <body-geom-density>` から指定または計算されます。慣性は質量、形状、均一密度の仮定から計算されます。 :ref:`shellinertia <body-geom-shellinertia>` フラグが設定されている場合、質量は **表面** に均一に分布していると仮定され、 :at:`density` は面積あたりの質量として解釈され、親ボディへの慣性寄与はそれに応じて計算されます。実際にシミュレートされる ``mjModel`` では、ジオムは慣性特性を持ちません。

サイトは軽量なジオムです。同じ外観特性を持ちますが、衝突に参加できず、ボディ質量の推定にも使用できません。一方で、サイトはジオムにできないことができます：タッチセンサーのボリューム、IMUセンサーのアタッチメント、空間テンドンのルーティング、スライダークランクアクチュエータのエンドポイントを指定できます。これらはすべて空間的な量ですが、質量を持ったり他のエンティティと衝突したりすべきエンティティには対応しません。これがサイト要素が作成された理由です。サイトはユーザーにとっての関心ポイント（より正確にはフレーム）を指定するためにも使用できます。

以下の例は、複数のサイトとジオムを同じボディにアタッチできることを示しています：この場合、1つのボディに2つのサイトと2つのジオムです。

.. code:: XML

   <mujoco>
     <worldbody>
       <body pos="0 0 0">
         <geom type="sphere" size=".1" rgba=".9 .9 .1 1"/>
         <geom type="capsule" pos="0 0 .1" size=".05 .1" rgba=".9 .9 .1 1"/>
         <site type="box" pos="0 -.1 .3" size=".02 .02 .02" rgba=".9 .1 .9 1"/>
         <site type="ellipsoid" pos="0 .1 .3" size=".02 .03 .04" rgba=".9 .1 .9 1"/>
       </body>
     </worldbody>
   </mujoco>

.. figure:: images/overview/bodygeomsite.png
   :width: 200px
   :align: right

このモデルはOpenGLビジュアライザにより次のようにレンダリングされます：

赤いボックスに注目してください。これはボディ慣性特性の等価慣性ボックスレンダリングであり、MuJoCoが内部的に生成します。ボックスはジオム上にありますが、サイト上にはありません。これは、ボディの慣性特性の（自動的な）推定にジオムのみが使用されたためです。後者がわかっている場合は、もちろん直接指定できます。しかし、均一密度の仮定を使用してボディにアタッチされたジオムからこれらのボディ特性をモデルコンパイラに推定させる方が便利なことが多いです（ジオムの密度はXMLで指定でき、デフォルトは水の密度です）。

.. _JointCo:

関節座標
~~~~~~~~

MuJoCoとゲームエンジンの主要な違いの1つは、MuJoCoが一般化座標または関節座標で動作するのに対し、ほとんどのゲームエンジンは直交座標で動作することです。これら2つのアプローチの違いは以下のようにまとめられます：

関節座標：

-  ロボットなどの複雑な運動構造に最適
-  ジョイントはデフォルトで溶接されるボディ間に自由度を **追加** する
-  関節制約は表現に暗黙的に含まれ、違反されない
-  シミュレートされるボディの位置と向きは一般化座標から順運動学を介して得られ、直接操作できない（ルートボディを除く）

直交座標：

-  分子動力学やボックスの積み重ねのように、互いに跳ね返る多数のボディに最適
-  ジョイントはデフォルトで自由浮遊するボディ間の自由度を **除去** する
-  関節制約は数値的に強制され、違反される可能性がある
-  シミュレートされるボディの位置と向きは明示的に表現され、直接操作できるが、関節制約のさらなる違反を引き起こす可能性がある

関節座標は、キネマティックツリーも含むモデルの一部である自由浮遊ボディを扱う場合に特に混乱を招く可能性があります。以下で明確にします。

.. _Floating:

浮遊オブジェクト
~~~~~~~~~~~~~~~~

関節座標で作業する場合、任意のボディの位置と向きを好きなように設定することはできません。その効果を達成するには、順運動学がボディを望む場所に配置するための（必ずしも一意でない）関節座標のセットを計算する、何らかの形式の逆運動学を実装する必要があります。

フリージョイントでワールドに接続されたボディ、つまり浮遊ボディの場合は状況が異なります。このようなボディの位置と向き、ならびに線形速度と角速度は ``mjData.qpos`` と ``mjData.qvel`` に明示的に表現されているため、直接操作できます。

フリージョイントのセマンティクスは以下の通りです。位置データは7つの数値（3D位置に続く単位クォータニオン）、速度データは6つの数値（3D線形速度に続く3D角速度）です。フリージョイントの線形位置はグローバルフレームにあり、線形速度も同様です。フリージョイントの向き（クォータニオン）もグローバルフレームにあります。ただし、フリージョイントの回転速度はローカルボディフレームにあります。これは設計上の決定というよりも、クォータニオンのトポロジーの正しい使用です。角速度はクォータニオンの接空間に存在し、特定の向きに対してローカルに定義されるため、フレームローカルの角速度が自然なパラメータ化です。加速度は対応する速度と同じ空間で定義されます。

フリージョイントは常にボディフレームで定義されますが、このフレームをボディの慣性に合わせることが計算上有利です。このオプションについて詳しくは :ref:`freejoint/align<body-freejoint-align>` 属性のドキュメントを参照してください。
