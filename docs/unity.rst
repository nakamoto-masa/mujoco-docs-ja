=============
Unityプラグイン
=============

はじめに
--------

MuJoCoの `Unityプラグイン <https://github.com/google-deepmind/mujoco/tree/main/unity>`__ により、Unity EditorとランタイムでMuJoCo物理エンジンを使用できるようになります。ユーザーはMJCFファイルをインポートして、Editorでモデルを編集できます。プラグインは、アセット、ゲームロジック、シミュレーション時間などのほとんどの側面についてUnityに依存していますが、オブジェクトの移動方法の決定にはMuJoCoを使用し、設計者はMuJoCoの完全なAPIにアクセスできます。

MuJoCoのUnityプラグインを使用したサンプルプロジェクトと入門チュートリアルのセットが `スタンドアロンリポジトリ <https://github.com/Balint-H/mj-unity-tutorial>`__ としても利用可能です。

.. _UInstallation:

インストール手順
----------------

`プラグインディレクトリ <https://github.com/google-deepmind/mujoco/tree/main/unity>`__ には ``package.json`` ファイルが含まれています。Unityのパッケージマネージャーはこのファイルを認識し、プラグインのC#コードベースをプロジェクトにインポートします。さらに、UnityにはネイティブなMuJoCoライブラリも必要で、これは対応する `プラットフォームアーカイブ <https://github.com/google-deepmind/mujoco/releases>`__ から入手できます。プラグインを単に使用したいだけで、開発したくない場合は、gitタグで識別されるバージョン固有の安定したコミットのいずれかを使用する必要があります。gitでクローンしたリポジトリの関連バージョンをチェックアウトしてください（ ``git checkout 3.X.Y`` 、ここでXとYはエンジンのバージョンを指定します）。リポジトリの ``main`` ブランチを単純に使用すると、MuJoCoの最新リリースバイナリと互換性がない場合があります。

Unityバージョン2020.2以降では、Package Managerがネイティブライブラリファイルを検索し、パッケージのインポート時にパッケージディレクトリにコピーします。あるいは、ネイティブライブラリをパッケージディレクトリに手動でコピーして名前を変更することもできます。詳細については、以下のプラットフォーム固有の手順を参照してください。ライブラリは、プロジェクトのAssetsディレクトリの下の任意の場所にコピーすることもできます。

MacOS
_____

MuJoCoアプリを少なくとも1回は実行して、ライブラリを信頼されたバイナリとして登録する必要があります。その後、ダイナミックライブラリファイルを ``/Applications/MuJoCo.app/Contents/Frameworks/mujoco.framework/Versions/Current/libmujoco.3.4.1.dylib`` からコピーし（ ``MuJoCo.app`` の内容を参照することで見つけることができます）、 ``mujoco.dylib`` としてリネームします。

Linux
_____

``tar.gz`` アーカイブを ``~/.mujoco`` に展開します。次に、ダイナミックライブラリを ``~/.mujoco/mujoco-3.4.1/lib/libmujoco.so.3.4.1`` からコピーし、 ``libmujoco.so`` としてリネームします。

Windows
_______

``zip`` アーカイブをユーザーディレクトリ内の ``MuJoCo`` というディレクトリに展開し、 ``MuJoCo\bin\mujoco.dll`` ファイルをコピーします。

.. _UUsing:

プラグインの使用
----------------

.. _UImporter:

インポーター
____________

インポーターは、Editorの *Asset* メニューから呼び出します。「Import MuJoCo Scene」をクリックして、モデルのMJCF仕様が記述されたXMLファイルを選択します。

コンテキストメニュー
____________________

- geomコンポーネントを右クリックすると、2つのオプションが提供されます：

  - 「Add mesh renderer」は、同じゲームオブジェクトにgeomをレンダリングするコンポーネントを追加します：標準の ``MeshRenderer`` と、geom形状プロパティの変更時に再作成されるプロシージャルメッシュを作成する ``MjMeshFilter`` です。
  - 「Convert to free object」は、2つの新しいゲームオブジェクトを追加します： ``MjBody`` コンポーネントを持つ親と、 ``MjFreeJoint`` コンポーネントを持つ兄弟です。これにより、以前は静的だったgeomがシーン内で自由に移動できるようになります。このアクションは、現在 ``MjBody`` 親を持たないgeom、つまり「world」geomにのみ適用されます。

- Unity Colliderを右クリックすると、同じゲームオブジェクトに「Add a matching MuJoCo geom」するオプションが提供されます。これは物理の完全な変換を構成するものではないことに注意してください。Rigidbody、ArticulationBody、Jointの構成は、引き続き手動で再作成する必要があります。

マウススプリング
________________

選択したゲームオブジェクトに ``MjBody`` コンポーネントがある場合、Sceneビューでcontrol-left-dragアクションを使用して、マウスカーソルに向かってこのボディにスプリング力を適用できます。スプリング力の原点の3D位置は、カメラのX方向とワールドのY方向で定義される平面にマウス位置を投影することで見つけられます。shiftキーを追加すると、投影平面がワールドのXおよびZ軸に平行になります。

.. _UTips:

Unityユーザー向けのヒント
__________________________

- コンパイルエラーまたは実行時エラーが発生した場合、システムの状態は未定義です。そのため、コンソールウィンドウで「Error Pause」をオンにすることをお勧めします。
- PhysXでは、すべての `Rigidbody` は「自由ボディ」です。対照的に、MuJoCoでは移動性のためにジョイントの明示的な指定が必要です。便宜上、worldgeom（つまり、 ``MjBody`` 祖先を持たない ``MjGeom`` コンポーネント）を「フリーにする」ためのコンテキストメニューを提供しています。これは、親の ``MjBody`` と兄弟の ``MjFreeJoint`` を追加することで実現されます。
- プラグインは物理的存在のない衝突検出をサポートしていないため、トリガーコライダーの組み込み概念はありません。接触力の有無は、タッチセンサーを追加してその ``SensorReading`` 値（法線力に対応、 `タッチセンサーのドキュメント <sensor-touch>` を参照）を読み取ることで確認できます。

.. _UDesign:

設計原則
--------

プラグイン設計は、MJCF要素とUnityコンポーネント間の1対1のマッピングを提供します。MuJoCoを使用してUnityシーンをシミュレートするため（たとえば、ユーザーがEditorで「play」ボタンを押した場合）、プラグインは以下を実行します：

1. シーン内のGameObjectヒエラルキーをスキャンして、MuJoCoコンポーネントを検索します。
2. MJCF記述を作成し、MuJoCoのコンパイラに渡します。
3. すべてのコンポーネントを、MuJoCoのデータ構造内の対応するインデックスを介してMuJoCoランタイムにバインドします。このインデックスは、シミュレーション中にUnityの変換を更新するために使用されます。

この設計原則にはいくつかの影響があります：

- Unityコンポーネントのほとんどのフィールドは、MJCF属性に直接対応しています。したがって、ユーザーは異なる値のセマンティクスの詳細についてMuJoCoドキュメントを参照できます。
- GameObjectヒエラルキー内のMuJoCoコンポーネントのレイアウトは、結果として得られるMuJoCoモデルのレイアウトを決定します。したがって、**すべてのゲームオブジェクトには最大1つのMuJoCoコンポーネントが必要**という設計ルールを採用しています。
- 空間構成にUnityを使用しており、UnityがY軸を垂直軸とする左手系フレームを使用するのに対し、MuJoCoはZ軸を垂直軸とする右手系フレームを使用するため、ベクトルコンポーネントを `スウィズル <https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)>`__ する必要があります。
- Unityの変換スケーリングは、ゲームオブジェクトのサブツリー全体の位置、方向、スケールに影響します。しかし、MuJoCoは傾斜した円筒とカプセルの衝突をサポートしていません（傾斜した球体は楕円体プリミティブを介してサポートされています）。geomsとsitesのギズモはこの傾斜を無視し（PhysXコライダーと同様）、物理に表示されるプリミティブ形状を常に表示します。
- ランタイム中にコンポーネントフィールドの値を変更しても、シーンの再作成はトリガーされないため、物理には即座に影響しません。ただし、新しい値は次のシーン再作成時にロードされます。

可能な限り、Unityのやり方で処理します：重力はUnityの物理設定から読み取られ、シミュレーションステップはUnityのTime Managerの `Fixed Timestep` から読み取られます。外観のすべての側面（メッシュ、マテリアル、テクスチャなど）はUnityのAsset Managerによって処理され、RGBA仕様はマテリアルアセットを使用して行われます。

.. _UNotes:

実装メモ
--------

インポーターワークフロー
________________________

ユーザーがMJCFファイルを選択すると、インポーターはまずMuJoCoでファイルをロードし、一時的な場所に保存してから、生成された保存ファイルを処理します。これにはいくつかの効果があります：

- MJCFを検証します。保存されたMJCFが :ref:`スキーマ <CSchema>` に一致することが保証されます。
- アセット（マテリアル、メッシュ、テクスチャ）を検証し、これらのアセットをUnityにインポートするとともに、geomのRGBA仕様用の新しいマテリアルアセットを作成します。
- インポーターがMuJoCoのファイルシステムワークフローを複製することなく、 :ref:`\<include\> <include>` 要素を処理できるようになります。

Unityには、MJCFの「カスケード」 :ref:`\<default\> <default>` 句に相当するものがありません。したがって、Unityのコンポーネントは、関連するすべてのデフォルトクラスを適用した後の対応する要素の状態を反映し、元のMJCFのクラス構造は破棄されます。

MuJoCoシーン
____________

MuJoCoシーンが作成されると、 ``MjScene`` コンポーネントは最初にシーンをスキャンして、 ``MjComponent`` のすべてのインスタンスを検索します。各コンポーネントは、モデルの初期参照ポーズ（MuJoCoでは ``qpos0`` と呼ばれます）を記述するために、Unityシーンの空間構造を使用して独自のMJCF要素を作成します。 ``MjScene`` は、それぞれのゲームオブジェクトのヒエラルキーに従ってこれらのXML要素を組み合わせ、物理モデルの単一のMJCF記述を作成します。次に、ランタイム構造体 ``mjModel`` と ``mjData`` を作成し、一意のインデックスを識別することで各コンポーネントをランタイムにバインドします。

ランタイム中、 ``MjScene.FixedUpdate()`` は :ref:`mj_step` を呼び出し、バインディング時に識別されたインデックス ``MjComponent.MujocoId`` に従って各ゲームオブジェクトの状態を同期します。 ``MjScene`` コンポーネントは、アプリケーションの起動時（たとえば、ユーザーが「play」を押したとき）に、シーンにMuJoCoコンポーネントが含まれている場合にのみ自動的に追加されます。アプリケーションの初期化フェーズでゲームオブジェクトとコンポーネントを追加しながら物理をティックする場合、初期化フェーズが終了したら ``MjScene.CreateScene()`` を呼び出すことができます。

シーンの再作成は、以下の方法で物理と状態の連続性を維持します：

1. ジョイントの位置と速度がキャッシュされます。
2. MuJoCoの状態がリセットされ（ ``qpos0`` に）、Unityの変換が同期されます。
3. 新しいXMLが生成され、永続化したジョイントについて以前のものと同じ ``qpos0`` を持つモデルが作成されます。
4. MuJoCoの状態（永続化したジョイントについて）がキャッシュから設定され、Unityの変換が同期されます。

MuJoCoには動的シーン編集の機能（ :ref:`mjSpec` を介して）がありますが、これはまだUnityプラグインではサポートされていません。したがって、MuJoCoコンポーネントの追加と削除により、完全なシーンの再作成が発生します。これは、大規模なモデルや頻繁に発生する場合にはコストがかかる可能性があります。このパフォーマンス制限は、プラグインの将来のバージョンで解消される予定です。

グローバル設定
______________

1要素対1コンポーネントの例外は、Global Settingsコンポーネントです。このコンポーネントは、MJCFの固定サイズのシングルトンなグローバル要素に含まれるすべての構成オプションを担当します。現在、 :ref:`\<option\> <option>` および :ref:`\<size\> <size>` 要素に対応する情報を保持しており、将来的には、そこのフィールドがUnityプラグインに関連する場合に :ref:`\<compiler\> <compiler>` 要素にも使用される予定です。

アプリケーションランタイムでのインポーターの呼び出し
____________________________________________________

インポーターは ``MjImporterWithAssets`` クラスによって実装されており、これは ``MjcfImporter`` のサブクラスです。この親クラスはMJCF文字列を受け取り、コンポーネントのヒエラルキーを生成します。プレイタイム時に呼び出すことができ（Editorの機能を含まない）、MuJoCoライブラリの関数を呼び出しません。これは、MuJoCoモデルがプロシージャルに生成される場合（たとえば、進化的プロセスによって）、および/またはMJCFが変換目的でのみインポートされる場合（たとえば、PhysXまたはURDFへ）に役立ちます。Unityの ``AssetManager`` と対話できないため（これはEditorの機能です）、このクラスの機能は制限されています。具体的には：

- すべてのアセット（衝突メッシュを含む）を無視します。
- ビジュアル（RGBA仕様を含む）を無視します。

MuJoCoセンサーコンポーネント
____________________________

MuJoCoは多くのセンサーを定義しており、それぞれに対して個別の ``MjComponent`` クラスを作成すると、多くのコードの重複につながることが懸念されました。そのため、測定されるプロパティを持つオブジェクトのタイプ（actuator / body / geom / joint / site）と、測定されるデータのタイプ（scalar / vector / quaternion）に従ってクラスを作成しました。

以下は、タイプとセンサーのマッピング表です：

+------------------------+---------------+---------------------+
| **Mujocoオブジェクトタイプ** | **データタイプ** | **センサー名**     |
+------------------------+---------------+---------------------+
| Actuator               | Scalar        | - ``actuatorpos``   |
|                        |               | - ``actuatorvel``   |
|                        |               | - ``actuatorfrc``   |
+------------------------+---------------+---------------------+
| Body                   | Vector        | - ``subtreecom``    |
|                        |               | - ``subtreelinvel`` |
|                        |               | - ``subtreeangmom`` |
|                        |               | - ``framepos``      |
|                        |               | - ``framexaxis``    |
|                        |               | - ``frameyaxis``    |
|                        |               | - ``framezaxis``    |
|                        |               | - ``framelinvel``   |
|                        |               | - ``frameangvel``   |
|                        |               | - ``framelinacc``   |
|                        |               | - ``frameangacc``   |
+------------------------+---------------+---------------------+
| Body                   | Quaternion    | - ``framequat``     |
+------------------------+---------------+---------------------+
| Geom                   | Vector        | - ``framepos``      |
|                        |               | - ``framexaxis``    |
|                        |               | - ``frameyaxis``    |
|                        |               | - ``framezaxis``    |
|                        |               | - ``framelinvel``   |
|                        |               | - ``frameangvel``   |
|                        |               | - ``framelinacc``   |
|                        |               | - ``frameangacc``   |
+------------------------+---------------+---------------------+
| Geom                   | Quaternion    | - ``framequat``     |
+------------------------+---------------+---------------------+
| Joint                  | Scalar        | - ``jointpos``      |
|                        |               | - ``jointvel``      |
|                        |               | - ``jointlimitpos`` |
|                        |               | - ``jointlimitvel`` |
|                        |               | - ``jointlimitfrc`` |
+------------------------+---------------+---------------------+
| Site                   | Scalar        | - ``touch``         |
|                        |               | - ``rangefinder``   |
+------------------------+---------------+---------------------+
| Site                   | Vector        | - ``accelerometer`` |
|                        |               | - ``velocimeter``   |
|                        |               | - ``force``         |
|                        |               | - ``torque``        |
|                        |               | - ``gyro``          |
|                        |               | - ``magnetometer``  |
|                        |               | - ``framepos``      |
|                        |               | - ``framexaxis``    |
|                        |               | - ``frameyaxis``    |
|                        |               | - ``framezaxis``    |
|                        |               | - ``framelinvel``   |
|                        |               | - ``frameangvel``   |
|                        |               | - ``framelinacc``   |
|                        |               | - ``frameangacc``   |
+------------------------+---------------+---------------------+
| Site                   | Quaternion    | - ``framequat``     |
+------------------------+---------------+---------------------+

以下は同じ表を逆にして、センサーをクラスにマッピングしたものです：

================= ===================================
センサー名       プラグインクラス
================= ===================================
``accelerometer`` SiteVector
``actuatorfrc``   ActuatorScalar
``actuatorpos``   ActuatorScalar
``actuatorvel``   ActuatorScalar
``force``         SiteVector
``frameangacc``   \*Vector (フレームタイプに依存)
``frameangvel``   \*Vector (フレームタイプに依存)
``framelinacc``   \*Vector (フレームタイプに依存)
``framelinvel``   \*Vector (フレームタイプに依存)
``framepos``      \*Vector (フレームタイプに依存)
``framequat``     \*Quaternion (フレームタイプに依存)
``framexaxis``    \*Vector (フレームタイプに依存)
``frameyaxis``    \*Vector (フレームタイプに依存)
``framezaxis``    \*Vector (フレームタイプに依存)
``gyro``          SiteVector
``jointlimitfrc`` JointScalar
``jointlimitpos`` JointScalar
``jointlimitvel`` JointScalar
``jointpos``      JointScalar
``jointvel``      JointScalar
``magnetometer``  SiteVector
``subtreeangmom`` BodyVector
``subtreecom``    BodyVector
``subtreelinvel`` BodyVector
``torque``        SiteVector
``touch``         SiteScalar
``velocimeter``   SiteVector
================= ===================================

以下のセンサーはまだ実装されていません：

| ``tendonpos``
| ``tendonvel``
| ``ballquat``
| ``ballangvel``
| ``tendonlimitpos``
| ``tendonlimitvel``
| ``tendonlimitfrc``
| ``user``

メッシュ形状
____________

プラグインは、MuJoCo衝突用に任意のUnityメッシュを使用できます。モデルのコンパイル時、MuJoCoは `qhull <http://www.qhull.org/>`__ を呼び出してメッシュの凸包を作成し、それを衝突に使用します。現在、計算された凸包はUnityでは表示されませんが、将来のバージョンで公開する予定です。

ハイトフィールド
________________

MuJoCoのhfieldは、Unityではterrainゲームオブジェクトを介して表現されます。これにより、Unityで利用可能な地形編集ツールを使用して、MuJoCoとの衝突用の形状を生成できます。Unity geomコンポーネントでhfieldタイプを選択すると、右クリックのコンテキストメニューで、対応するUnity terrainをシーンに追加するユーティリティが提供されます。terrainからのデータは、シミュレーションと動的に同期されます。

MuJoCoプラグイン
________________

現在のバージョンのUnityパッケージは、 `弾性 <https://github.com/google-deepmind/mujoco/tree/main/plugin/elasticity#readme>`__ などの :ref:`MuJoCoプラグイン<exPlugin>` を使用するMJCFシーンのロードをサポートしていません。これを実行する基本機能は、今後のリリースの一部となる予定です。

外部プロセスとの相互作用
________________________

Robotiの `MuJoCo plug-in for Unity <https://roboti.us/download.html>`__ は、外部のPythonプロセスでシミュレーションをステップし、レンダリングのみにUnityを使用します。対照的に、私たちのプラグインは、シミュレーションをステップするためにUnityに依存しています。外部プロセスがシミュレーションを「駆動」する間、つまり ``qpos`` を設定し、 ``mj_kinematics`` を呼び出し、変換を同期してから、Unityを使用してレンダリングまたはゲームロジックを計算する間、プラグインを使用することは可能なはずです。外部プロセスとの通信を確立するには、Unityの `ML-Agents <https://github.com/Unity-Technologies/ml-agents>`__ パッケージを使用できます。
