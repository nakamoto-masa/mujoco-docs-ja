.. _Sample:

コードサンプル
--------------

MuJoCoには、便利な機能を提供するいくつかのコードサンプルが付属しています。中には非常に精巧なもの（特に :ref:`simulate.cc <saSimulate>` ）もありますが、それでもこれらがユーザーがライブラリを使ってプログラミングすることを学ぶのに役立つことを願っています。

.. _saTestspeed:

`testspeed <https://github.com/google-deepmind/mujoco/blob/main/sample/testspeed.cc>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

このコードサンプルは、与えられたモデルのシミュレーションを計測します。計測は単純明快です。受動ダイナミクス（オプションで制御ノイズを含む）のシミュレーションを指定されたステップ数だけロールアウトし、内部プロファイリングから接触数、スカラー制約数、CPU時間の統計を収集します。結果はコンソールに出力されます。受動ダイナミクスの代わりに制御されたダイナミクスをシミュレートするには、制御コールバック :ref:`mjcb_control` をインストールするか、 :ref:`simulation loop <siSimulation>` セクションで説明されているように、制御信号を明示的に設定するようにコードを変更します。このコマンドラインユーティリティは以下のように実行します。

.. code-block:: Shell

   testspeed modelfile [nstep nthread ctrlnoise npoolthread]

コマンドライン引数は以下の通りです。

.. list-table::
   :width: 95%
   :align: left
   :widths: 1 1 5
   :header-rows: 1

   * - 引数
     - デフォルト
     - 意味
   * - ``modelfile``
     - （必須）
     - モデルへのパス
   * - ``nstep``
     - 10000
     - ロールアウトあたりのステップ数
   * - ``nthread``
     - 1
     - 並列ロールアウトを実行するスレッド数
   * - ``ctrlnoise``
     - 0.01
     - アクチュエータに注入される疑似ランダムノイズのスケール
   * - ``npoolthread``
     - 1
     - エンジン内部のスレッドプール内のスレッド数

**注意事項:**

- ``nthread > 1`` が指定された場合、コードは単一のmjModelとスレッドごとのmjDataを割り当て、 ``nthread`` 個の同一のシミュレーションを並列に実行します。これは、サンプルを並列に収集する強化学習シナリオなど、すべてのコアがアクティブな状態でのパフォーマンスをテストします。最適な ``nthread`` は通常、論理コア数と等しくなります。
- デフォルトでは、シミュレーションはモデルの参照構成から速度ゼロで開始されます。ただし、モデル内に「test」という名前のキーフレームが存在する場合は、それが初期状態として使用されます。
- ``ctrlnoise`` 引数は、モデルが静的な状態に落ち着くことを防ぎます。静的な状態では、ウォームスタートのために人為的に高速なシミュレーションを測定する可能性があります。
- ``npoolthread > 1`` が指定された場合、指定された数のスレッドを持つエンジン内部の :ref:`mjThreadPool` が作成され、大規模なシーンのシミュレーションを高速化します。 ``nthread`` と ``npoolthread`` の両方を使用することは可能ですが、これらの異なるタイプのマルチスレッドが必要となるシナリオは通常、相互に排他的です。
- より再現性の高いパフォーマンス統計を得るには、Linux上で ``performance`` `governor <https://www.kernel.org/doc/Documentation/cpu-freq/governors.txt>`__ を使用するか、Windows上で ``High Performance`` 電源プランを使用してツールを実行し、CPU スケーリングからのノイズを減らします。
- 多くの最新のCPUには、「パフォーマンス」コアと「効率」コアが混在して含まれています。ユーザーは、より解釈しやすいパフォーマンス統計を得るために、プロセスを同じタイプのコアのみで実行するように制限することを検討する必要があります。これは、Linux上では `taskset <https://man7.org/linux/man-pages/man1/taskset.1.html>`__ コマンド、Windows上では `start /affinity <https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/start>`__ コマンドで行うことができます（macOSでは、文書化されたAPI手段でプロセッサアフィニティを指定することはできません）。

.. _saSimulate:

`simulate <https://github.com/google-deepmind/mujoco/blob/main/simulate>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

このコードサンプルは、フル機能のインタラクティブシミュレーターです。プラットフォーム非依存のGLFWライブラリを使用してOpenGLウィンドウを開き、その中にシミュレーション状態をレンダリングします。組み込みのヘルプ、シミュレーション統計、プロファイラー、センサーデータプロットがあります。モデルファイルはコマンドライン引数として指定するか、ドラッグアンドドロップ機能を使用して実行時にロードできます。このコードサンプルは、さまざまなコントロールをレンダリングするためにネイティブUIを使用しており、新しいUIフレームワークがどのように使用されることを意図しているかを示しています。以下は、 ``simulate`` の動作中のスクリーンキャプチャです。

..  youtube:: P83tKA1iz2Y
    :aspect: 16:9
    :width: 95%
    :align: center

インタラクションはマウスで行われます。利用可能なコマンドの概要を示す組み込みのヘルプは、 ``F1`` キーを押すことで利用できます。簡単に言うと、オブジェクトは左ダブルクリックで選択されます。ユーザーは、Ctrlキーを押しながらマウスをドラッグすることで、選択されたオブジェクトに力やトルクを適用できます。マウスだけをドラッグする（Ctrlなし）とカメラが移動します。シミュレーションの一時停止、リセット、モデルファイルの再読み込みのためのキーボードショートカットがあります。後者の機能は、XMLエディターでモデルを編集している間に非常に便利です。

コードは長いですが、かなりコメントが付いているので、読むのが最善です。ここでは、高レベルの概要を提供します。 ``main()`` 関数は、MuJoCoとGLFWの両方を初期化し、ウィンドウを開き、マウスとキーボード処理のためのGLFWコールバックをインストールします。レンダリングコールバックはないことに注意してください。GLFWは、バックグラウンドでレンダリングループを実行する代わりに、ユーザーを担当させます。メインループはUIイベントとレンダリングを処理します。シミュレーションはバックグラウンドスレッドで処理され、メインスレッドと同期されます。

マウスとキーボードのコールバックは、必要なアクションを実行します。これらのアクションの多くは、MuJoCoの :ref:`abstract visualization <Abstract>` メカニズムによって提供される機能を呼び出します。実際、このメカニズムは、マウスとキーボードイベントに直接フックされるように設計されており、カメラと摂動制御を提供します。

プロファイラーとセンサーデータプロットは、グリッド、注釈、軸スケーリングなどを備えた精巧な2D図を描画できる :ref:`mjr_figure` 関数の使用を示しています。プロファイラーに表示される情報は、mjDataの診断フィールドから抽出されます。これは、制約ソルバーアルゴリズムのパラメータを調整するための非常に便利なツールです。モデルで定義されたセンサーの出力は、棒グラフとして視覚化されます。

プロファイラーは、高解像度タイマーで収集されたタイミング情報を表示することに注意してください。Windowsでは、電源設定によっては、OSがCPU周波数を下げる場合があります。これは、 :ref:`simulate.cc <saSimulate>` がリアルタイムに減速するためにほとんどの時間スリープしているためです。これにより、不正確なタイミングが発生します。この問題を回避するには、最小プロセッサ状態が100%になるようにWindowsの電源プランを変更してください。

.. _saCompile:

`compile <https://github.com/google-deepmind/mujoco/blob/main/sample/compile.cc>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

このコードサンプルは、組み込みのパーサーとコンパイラを呼び出します。（MJCF、URDF、MJB）形式から（MJCF、MJB、TXT）形式へのすべての可能なモデル変換を実装します。MJCFとして保存されたモデルは、 :doc:`../modeling` 章で説明されている形式の正規サブセットを使用するため、MJCFからMJCFへの変換は通常、異なるファイルになります。TXT形式は、人間が読めるモデルのロードマップです。MuJoCoによってロードすることはできませんが、モデル開発中に非常に便利な補助となります。これは、コンパイルされたmjModelと一対一で対応しています。また、 :ref:`mj_printData` 関数を使用して、mjDataと一対一で対応するテキストファイルを作成することもできますが、これはこのコードサンプルでは行われません。

入力ファイルがMJCFで、出力ファイルが空の場合、コンパイルが実行され、コンパイラの :ref:`asset cache<Assetcache>` の影響を測定するために2回計測されます。

.. _saBasic:

`basic <https://github.com/google-deepmind/mujoco/blob/main/sample/basic.cc>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

このコードサンプルは、最小限のインタラクティブシミュレーターです。モデルファイルはコマンドライン引数として提供する必要があります。プラットフォーム非依存のGLFWライブラリを使用してOpenGLウィンドウを開き、リアルタイムでシミュレーションを進めながら60fpsでシミュレーション状態をレンダリングします。Backspaceキーを押すとシミュレーションがリセットされます。マウスを使用してカメラを制御できます。左ドラッグで回転、右ドラッグで垂直面内で平行移動、Shift+右ドラッグで水平面内で平行移動、スクロールまたは中央ドラッグでズームします。

以下の :ref:`Visualization` プログラミングガイドでは、可視化がどのように機能するかを説明しています。このコードサンプルは、そのガイドの概念の最小限の図解です。

.. _saRecord:

`record <https://github.com/google-deepmind/mujoco/blob/main/sample/record.cc>`_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

このコードサンプルは、与えられたモデルの受動ダイナミクスをシミュレートし、オフスクリーンでレンダリングし、カラーと深度のピクセル値を読み取り、それらをrawデータファイルに保存します。その後、ffmpegなどのツールでムービーファイルに変換できます。レンダリングは、ユーザーインタラクション、可視化オプション、タイミングがないため、 :ref:`simulate.cc <saSimulate>` と比較して簡素化されています。代わりに、デフォルト設定でできるだけ速くレンダリングするだけです。オフスクリーンバッファの寸法とマルチサンプル数は、MuJoCoモデルのvisual/global/{`offwidth <https://mujoco.readthedocs.io/en/stable/XMLreference.html#visual-global-offwidth>`__, `offheight <https://mujoco.readthedocs.io/en/stable/XMLreference.html#visual-global-offheight>`__} およびvisual/quality/`offsamples <https://mujoco.readthedocs.io/en/stable/XMLreference.html#visual-quality-offsamples>`_ 属性で指定され、シミュレーション時間、レンダリングされる毎秒フレーム数（通常は物理シミュレーションレートよりはるかに少ない）、および出力ファイル名はコマンドライン引数として指定されます。

.. code-block:: Shell

   record modelfile duration fps rgbfile [adddepth]

コマンドライン引数は以下の通りです。

.. list-table::
   :width: 95%
   :align: left
   :widths: 1 1 5
   :header-rows: 1

   * - 引数
     - デフォルト
     - 意味
   * - ``modelfile``
     - （必須）
     - モデルへのパス
   * - ``duration``
     - （必須）
     - 記録の秒単位の時間
   * - ``fps``
     - （必須）
     - 毎秒フレーム数
   * - ``rgbfile``
     - （必須）
     - raw記録ファイルへのパス
   * - ``adddepth``
     - 1
     - 左下隅に深度画像をオーバーレイ（0: なし）

たとえば、60フレーム/秒で5秒のアニメーションは以下のように作成されます。

.. code-block:: Shell

   record humanoid.xml 5 60 rgb.out

デフォルトの `humanoid.xml <https://github.com/google-deepmind/mujoco/blob/main/model/humanoid/humanoid.xml>`__ モデルは、2560x1440解像度のオフスクリーンレンダリングを指定しています。この情報を使用して、（大きな）rawデータファイルを再生可能なムービーファイルに圧縮できます。

.. code-block:: Shell

   ffmpeg -f rawvideo -pixel_format rgb24 -video_size 2560x1440
          -framerate 60 -i rgb.out -vf "vflip,format=yuv420p" video.mp4

オフスクリーンレンダリング解像度とffmpegのvideo_sizeは同一である必要があることに注意してください。

このサンプルは、OpenGLコンテキストの作成方法が異なる3つの方法でコンパイルできます。非表示のウィンドウを持つGLFWを使用する方法、OSMesaを使用する方法、EGLを使用する方法です。後者の2つのオプションはLinux上でのみ利用可能で、record.ccのコンパイル時にシンボルMJ_OSMESAまたはMJ_EGLを定義することで呼び出されます。関数 ``initOpenGL`` と ``closeOpenGL`` は、上記のどのシンボルが定義されているかに応じて、3つの異なる方法でOpenGLコンテキストを作成および閉じます。

MuJoCoのレンダリングコードは、OpenGLコンテキストがどのように作成されたかに依存しないことに注意してください。これがOpenGLの美しさです。コンテキストの作成はプラットフォームに任せ、実際のレンダリングは標準化されており、すべてのプラットフォームで同じように動作します。振り返ると、コンテキスト作成を標準から外すという決定は、不必要な重複技術の増殖を招きました。これらは、プラットフォーム間だけでなく、Linuxの場合はプラットフォーム内でも異なります。（たとえばOSMesaが提供するような）いくつかの追加関数の追加により、多くの混乱を回避できたはずです。EGLは、これを行うことを目的としたKhronosの新しい標準であり、人気が高まっています。しかし、すべてのユーザーがそれをインストールしていると想定することはまだできません。
