.. _Simulation:

シミュレーション
-----------------

.. _siInitialization:

初期化
~~~~~~

:ref:`mjModel` と :ref:`mjData` は、ユーザーが直接割り当てるべきではありません。代わりに、対応するAPI関数によって割り当てられ、初期化されます。これらは非常に複雑なデータ構造であり、他の構造体の（配列）、すべての中間結果用に事前割り当てされたデータ配列、および :ref:`内部スタック <siStack>` を含んでいます。私たちの戦略は、シミュレーションの開始時に必要なすべてのヒープメモリを割り当て、シミュレーション終了後に解放することで、シミュレーション中にCのメモリ割り当てと解放関数を呼び出す必要がないようにすることです。これは、速度、メモリの断片化の回避、将来のGPU移植性、およびリセット中のシミュレータ全体の状態の管理の容易さのために行われています。ただし、これは :ref:`size <size>` MJCF要素の :at:`memory` 属性で指定される最大可変メモリ割り当て（:ref:`mjData` の割り当てに影響する）が、十分に大きな値に設定されなければならないことも意味します。この最大サイズがシミュレーション中に超過した場合、動的に増加されるのではなく、代わりにエラーが生成されます。詳細は後述の :ref:`診断 <siDiagnostics>` も参照してください。

最初に、mjModelを割り当てて初期化し、そのポインタを返す関数のいずれかを呼び出す必要があります。利用可能なオプションは次のとおりです。

.. code-block:: C

   // option 1: parse and compile XML from file
   mjModel* m = mj_loadXML("mymodel.xml", NULL, errstr, errstr_sz);

   // option 2: parse and compile XML from virtual file system
   mjModel* m = mj_loadXML("mymodel.xml", vfs, errstr, errstr_sz);

   // option 3: load precompiled model from MJB file
   mjModel* m = mj_loadModel("mymodel.mjb", NULL);

   // option 4: load precompiled model from virtual file system
   mjModel* m = mj_loadModel("mymodel.mjb", vfs);

   // option 5: deep copy from existing mjModel
   mjModel* m = mj_copyModel(NULL, mexisting);

   // option 6: compile model from mjSpec
   mjModel* m = mj_compile(spec, vfs);

これらの関数はすべて、エラーまたは警告がある場合はNULLポインタを返します。XMLパースとモデルコンパイルの場合、エラーの説明は引数として提供される文字列に返されます。残りの関数については、低レベルの :ref:`mju_error` または :ref:`mju_warning` がエラー/警告メッセージとともに呼び出されます。詳細は :ref:`エラー処理 <siError>` を参照してください。上記の関数のいずれかによって割り当てられたmjModelへのポインタを取得したら、モデルアクセスが必要なすべてのAPI関数の引数として渡します。ほとんどの関数は、このポインタを ``const`` として扱うことに注意してください。詳細は後述の :ref:`モデルの変更 <siChange>` を参照してください。

仮想ファイルシステム（VFS）を使用すると、ディスクリソースをメモリにロードしたり、ユーザーがプログラムで作成したりでき、MuJoCoのロード関数はディスクにアクセスする前にVFS内のファイルを検索します。詳細は、APIリファレンス章の :ref:`Virtualfilesystem` を参照してください。

モデル記述を保持するmjModelに加えて、すべての計算が実行されるワークスペースであるmjDataも必要です。mjDataは特定のmjModelに固有であることに注意してください。API関数は一般に、ユーザーが何をしているかを知っていると仮定し、最小限の引数チェックのみを実行します。API関数に渡されるmjModelとmjDataが互換性がない（またはNULL）場合、結果の動作は未定義です。mjDataは次のように作成されます。

.. code-block:: C

   // option 1: create mjData corresponding to given mjModel
   mjData* d = mj_makeData(m);

   // option 2: deep copy from existing mjData
   mjData* d = mj_copyData(NULL, m, dexisting);

mjModelとmjDataの両方が割り当てられて初期化されたら、さまざまなシミュレーション関数を呼び出すことができます。完了したら、次のように削除できます。

.. code-block:: C

   // deallocate existing mjModel
   mj_deleteModel(m);

   // deallocate existing mjData
   mj_deleteData(d);

コードサンプルは、完全な初期化とシャットダウンのシーケンスを示しています。

MuJoCoシミュレーションは :ref:`決定論的 <piReproducibility>` です。

.. _siSimulation:

シミュレーションループ
~~~~~~~~~~~~~~~~~~~~~~

MuJoCoでシミュレーションループを実行する方法は複数あります。最も単純な方法は、次のようなループでトップレベルのシミュレーション関数 :ref:`mj_step` を呼び出すことです。

.. code-block:: C

   // simulate until t = 10 seconds
   while (d->time < 10)
     mj_step(m, d);

これだけでは、制御信号や適用力を提供していないため、受動的なダイナミクスがシミュレートされます。システムを制御するデフォルトの方法は、制御コールバックを実装することです。例えば次のようになります。

.. code-block:: C

   // simple controller applying damping to each DOF
   void mycontroller(const mjModel* m, mjData* d) {
     if (m->nu == m->nv)
       mju_scl(d->ctrl, d->qvel, -0.1, m->nv);
   }

これは2つの概念を示しています。まず、制御数 ``mjModel.nu`` が自由度（DOF）数 ``mjModel.nv`` と等しいかどうかをチェックしています。一般に、ユーザーコードの構造によっては、同じコールバックが複数のモデルで使用される可能性があるため、コールバック内でモデルの次元をチェックすることは良い考えです。次に、MuJoCoには非常に便利なBLAS風の関数ライブラリがあります。実際、コードベースの大部分は、このような関数を内部的に呼び出すことで構成されています。上記の :ref:`mju_scl` 関数は、速度ベクトル ``mjData.qvel`` を一定のフィードバックゲインでスケーリングし、結果を制御ベクトル ``mjData.ctrl`` にコピーします。このコールバックをインストールするには、グローバル制御コールバックポインタ :ref:`mjcb_control` に割り当てるだけです。

.. code-block:: C

   // install control callback
   mjcb_control = mycontroller;

これで :ref:`mj_step` を呼び出すと、シミュレーションパイプラインで制御信号が必要になるたびに制御コールバックが実行され、結果として制御されたダイナミクスがシミュレートされます。

制御コールバックに依存する代わりに、制御ベクトル ``mjData.ctrl`` を直接設定することもできます。あるいは、 :ref:`状態と制御 <siStateControl>` で説明されているように、適用力を設定することもできます。``mj_step`` が呼び出される前にこれらの制御関連の量を計算できる場合、制御されたダイナミクス用のシミュレーションループ（制御コールバックを使用しない）は次のようになります。

.. code-block:: C

   while (d->time < 10) {
     // set d->ctrl or d->qfrc_applied or d->xfrc_applied
     mj_step(m, d);
   }

なぜ ``mj_step`` が呼び出される前に制御を計算できないのでしょうか？結局のところ、これが因果律の意味ではないでしょうか？答えは微妙ですが重要で、離散時間でシミュレートしているという事実に関係しています。トップレベルのシミュレーション関数 ``mj_step`` は2つのことを行います：連続時間で :ref:`順動力学 <siForward>` を計算し、次に ``mjModel.opt.timestep`` で指定された期間にわたって積分します。順動力学は、時刻 ``mjData.time`` での加速度 ``mjData.qacc`` を、時刻 ``mjData.time`` での :ref:`状態と制御 <siStateControl>` が与えられたときに計算します。次に、数値積分器が状態と時刻を ``mjData.time + mjModel.opt.timestep`` に進めます。さて、制御は時刻 ``mjData.time`` での状態の関数である必要があります。しかし、一般的なフィードバックコントローラーは、状態のさまざまな特徴に依存する非常に複雑な関数になる可能性があります。特に、MuJoCoがシミュレーションの中間結果として計算するすべての特徴に依存します。これには、接触、ヤコビアン、受動力が含まれる場合があります。これらの量はいずれも ``mj_step`` が呼び出される前には利用できません（あるいは、利用可能ですが *1タイムステップ分古い* です）。対照的に、``mj_step`` が制御コールバックを呼び出すとき、計算のできるだけ遅い段階、すなわち状態に依存するが制御には依存しないすべての中間結果が計算された後に呼び出します。

同じ効果は、制御コールバックを使用せずに達成できます。これは、``mj_step`` を2つの部分に分割することで行われます：制御が必要になる前と、制御が必要になった後です。シミュレーションループは次のようになります。

.. code-block:: C

   while (d->time < 10) {
     mj_step1(m, d);
     // set d->ctrl or d->qfrc_applied or d->xfrc_applied
     mj_step2(m, d);
   }

ただし、1つの複雑な点があります。これは単一ステップ :ref:`積分器<geIntegration>` （Euler、implicit、implicitfast）でのみ機能します。ルンゲ・クッタ積分器は、ステップごとにフィードバック制御則を含む全体のダイナミクスを複数回評価する必要があり、これは制御コールバックを使用することでのみ実行できます。単一ステップ積分器では、上記の ``mj_step`` を :ref:`mj_step1` と :ref:`mj_step2` に分割することで、制御則に計算の中間結果を提供するのに十分です。

上記の説明をより明確にするために、:ref:`mj_step`、:ref:`mj_step1`、:ref:`mj_step2` の内部実装を示します。タイミング診断を計算するコードの一部は省略しています。メインシミュレーション関数は次のとおりです。

.. code-block:: C

   void mj_step(const mjModel* m, mjData* d) {
     // common to all integrators
     mj_checkPos(m, d);
     mj_checkVel(m, d);
     mj_forward(m, d);
     mj_checkAcc(m, d);

     // use selected integrator
     switch ((mjtIntegrator) m->opt.integrator) {
     case mjINT_EULER:
       mj_Euler(m, d);
       break;

     case mjINT_RK4:
       mj_RungeKutta(m, d, 4);
       break;

     case mjINT_IMPLICIT:
     case mjINT_IMPLICITFAST:
       mj_implicit(m, d);
       break;

     default:
       mjERROR("invalid integrator");
     }
   }

チェック関数は、数値が無効または大きすぎる場合に自動的にシミュレーションをリセットします。制御コールバック（ある場合）は、順動力学関数内から呼び出されます。

次に、2部構成のステッピングアプローチの実装を示しますが、具体的な内容は後で :ref:`順動力学 <siForward>` を説明した後でのみ理解できます。制御コールバックは、順動力学関数を基本的に展開したため、直接呼び出されることに注意してください。また、:ref:`mj_step2` では常に単一ステップ積分器を呼び出すことにも注意してください。RK4が選択されている場合、積分器はデフォルトでEulerになります。

.. code-block:: C

   void mj_step1(const mjModel* m, mjData* d) {
     mj_checkPos(m, d);
     mj_checkVel(m, d);
     mj_fwdPosition(m, d);
     mj_sensorPos(m, d);
     mj_energyPos(m, d);
     mj_fwdVelocity(m, d);
     mj_sensorVel(m, d);
     mj_energyVel(m, d);

     // if we had a callback we would be using mj_step, but call it anyway
     if (mjcb_control)
       mjcb_control(m, d);
   }

   void mj_step2(const mjModel* m, mjData* d) {
     mj_fwdActuation(m, d);
     mj_fwdAcceleration(m, d);
     mj_fwdConstraint(m, d);
     mj_sensorAcc(m, d);
     mj_checkAcc(m, d);

     // integrate with Euler or implicit; RK4 defaults to Euler
     if (m->opt.integrator == mjINT_IMPLICIT || m->opt.integrator == mjINT_IMPLICITFAST)
       mj_implicit(m, d);
     else
       mj_Euler(m, d);
   }

.. _siStateControl:

状態と制御
~~~~~~~~~~
MuJoCoは、設定、リセット、時間経過とともに進めることが容易な明確に定義された状態を持っています。これは、力学系の状態の概念と密接に関連しています。力学系は通常、一般的な形式で記述されます。

.. code-block:: Text

     dx/dt = f(t, x, u)

ここで ``t`` は時刻、``x`` は状態ベクトル、``u`` は制御ベクトル、``f`` は状態の時間微分を計算する関数です。これは連続時間の定式化であり、実際にMuJoCoがシミュレートする物理モデルは連続時間で定義されています。数値積分器は離散時間で動作しますが、計算のメイン部分、すなわち関数 :ref:`mj_forward` は、上記の連続時間ダイナミクス関数 ``f(t,x,u)`` に対応しています。以下でこの対応関係を説明します。

.. _siStateComponents:

状態要素
^^^^^^^^
状態は個別の要素で構成されており、:ref:`mjtState` ビットフィールド列挙型で記述されます。これは、個々の要素と要素の組み合わせの両方を列挙します。これらは次のとおりです。

.. _siPhysicsState:

物理状態
""""""""
*物理状態* (:ref:`mjSTATE_PHYSICS<mjtState>`) には、ステッピング中に時間積分される主要な量が含まれています。これらは ``mjData.{qpos, qvel, act}`` です。

位置：``qpos``
  一般化座標での構成、:ref:`数値積分<geIntegration>` セクションでは :math:`q` と表記されます。

速度：``qvel``
  一般化速度、:ref:`数値積分<geIntegration>` セクションでは :math:`v` と表記されます。クォータニオンの存在下（つまり、フリージョイントまたはボールジョイントが使用されている場合）、位置ベクトル ``mjData.qpos`` は速度ベクトル ``mjData.qvel`` よりも高い次元を持つため、これはスカラーの意味での単純な時間微分ではなく、代わりにクォータニオン代数を考慮に入れています。

アクチュエータ活性化：``act``
  2次機械システムの場合、状態には位置と速度のみが含まれますが、MuJoCoは独自の活性化状態を持つステートフルアクチュエータ（生物学的筋肉など）もモデル化し、``mjData.act`` に組み立てられます。これは :ref:`数値積分<geIntegration>` セクションでは :math:`w` と表記されます。

.. _siFullPhysics:

完全物理状態
""""""""""""
上記の `t, x` は *完全物理状態* (:ref:`mjSTATE_FULLPHYSICS<mjtState>`) に対応します。これは時間経過とともに進むすべてのものです。これは :ref:`物理状態<siPhysicsState>` と2つの追加要素です。

時刻：``time``
  力学は時間不変ですが、ユーザー定義の制御則は時間依存の場合があります。特に、軌道から得られる制御則は、しばしば時間インデックス化されています。したがって、時刻 ``t`` （``mjData.time``）は ``dt/dt == 1`` の状態要素です。

プラグイン状態：``plugin_state``
  ``mjData.plugin_state`` は :ref:`エンジンプラグイン<exPlugin>` によって宣言された状態です。詳細は :ref:`exPluginState` セクションを参照してください。

.. _siInput:

ユーザー入力
""""""""""""
これらの入力フィールド (:ref:`mjSTATE_USER<mjtState>`) はユーザーによって設定され、物理シミュレーションに影響を与えますが、シミュレータによって変更されることはありません。MoCap姿勢を除くすべての入力フィールドはデフォルトで0です。すべての :ref:`ユーザー入力<siInput>` 配列の一般的な特性は、ライブラリによって変更されないことです。したがって、このメモリに書き込まれた値が永続的であるという意味で、それらもステートフルと見なすことができます。

制御ベクトル ``u`` は主に配列 ``mjData.ctrl`` に対応し、ユーザーが設定した駆動信号を含みます。「主に」というのは、トルクとレンチも ``mjData.qfrc_applied`` と ``mjData.xfrc_applied`` を使用して直接適用できるためです。:ref:`ユーザー制御の静的ボディ<CMocap>` であるmocapボディの姿勢もユーザー入力です。フィールド ``mjData.userdata`` は（:ref:`nuserdata<size-nuserdata>` を設定することで割り当てられる）固定サイズのメモリブロックであり、ユーザーが任意の目的で使用することを意図しており、さまざまな状態風および制御風の量を格納するために使用できます。

制御：``ctrl``
  制御はXMLの :ref:`アクチュエータ<actuator>` セクションで定義されます。``mjData.ctrl`` 値は、一般化力を直接生成する（ステートレスアクチュエータ）か、``mjData.act`` のアクチュエータ活性化に影響を与え、次に力を生成します。すべてのアクチュエータが力を生成しますが、``ctrl`` と ``act`` のセマンティクスは :ref:`駆動モデル<geActuation>` の特定のパラメータに依存することに注意してください。

補助制御：``qfrc_applied`` と ``xfrc_applied``
  | ``mjData.qfrc_applied`` は直接適用される一般化力です。
  | ``mjData.xfrc_applied`` は個々のボディの重心に適用される直交レンチです。このフィールドは、たとえば :ref:`ネイティブビューア<saSimulate>` がマウスによる摂動を適用するために使用されます。
  | ``qfrc_applied`` と ``xfrc_applied`` の効果は、適切なアクチュエータ定義によって再現できることに注意してください。

MoCap姿勢：``mocap_pos`` と ``mocap_quat``
  ``mjData.mocap_pos`` と ``mjData.mocap_quat`` は :ref:`ここで説明されている<CMocap>` 特別なオプションの運動学的状態であり、ユーザーが静的ボディの位置と方向をリアルタイムで設定できるようにします。たとえば、モーションキャプチャデバイスから6D姿勢をストリーミングする場合などです。:ref:`mj_resetData` によって設定されるデフォルト値は、デフォルト構成でのボディの姿勢です。

等式制約トグル：``eq_active``
  ``mjData.eq_active`` はバイト値の配列であり、ユーザーが実行時に等式制約の状態を切り替えることができます。この配列の初期値は ``mjModel.eq_active0`` であり、:ref:`等式制約<coEquality>` の :ref:`active<equality-connect-active>` 属性を使用してXMLで設定できます。

ユーザーデータ：``userdata``
  ``mjData.userdata`` は、エンジンによって変更されないユーザー定義のメモリ空間として機能します。たとえば、コールバックで使用できます。これは :ref:`プログラミング章<siSimulation>` でより詳細に説明されています。

.. _siWarmstart:

ウォームスタート
""""""""""""""""

ウォームスタート加速度：``qacc_warmstart``
  ``mjData.qacc_warmstart`` は、制約ソルバーをウォームスタートするために使用される前のステップの加速度です。現在の解が前の解とあまり変わらないと仮定すると、これにより収束に必要な反復回数を減らすことでシミュレーションを高速化できます。PGSのようなゆっくり収束する :ref:`制約ソルバー<Solver>` を使用する場合、これらは収束に必要な反復回数を減らすことでシミュレーションを高速化できます。ただし、デフォルトのNewtonソルバーは非常に迅速に収束する（通常2〜3回の反復）ため、ウォームスタートは速度にほとんど影響を与えないことが多く、 :ref:`無効化<option-flag-warmstart>` できます。

  最適化問題は単一のグローバル最小値を持つ :ref:`厳密凸<Solver>` であるため、収束が達成されたと仮定すると、異なるソルバー初期化は解に知覚可能な影響を与えません。効果が顕著になるのは、遅い収束のため、または :ref:`MJX<MjxPerformance>` で時々行われるように :ref:`反復<option-iterations>` または :ref:`許容差<option-tolerance>` が制限されているために、数値収束が達成されない場合です。

  ウォームスタートが重要なもう1つのケースは、（初期状態は常にコールドスタートされるため）非初期状態をロードするときに、完全な数値再現性が必要な場合です。物理への影響はごくわずかですが、多くの物理システムは、タイムステッピング時に小さな差を `指数関数的 <https://en.wikipedia.org/wiki/Lyapunov_exponent>`__ に蓄積し、異なるウォームスタートに対してすぐに発散する軌道につながることに注意してください。詳細は :ref:`再現性<piReproducibility>` を参照してください。

.. _siIntegrationState:

積分状態
""""""""
*積分状態* (:ref:`mjSTATE_INTEGRATION<mjtState>`) は、上記のすべての :ref:`mjData` フィールドの和集合であり、*順動力学* へのすべての入力の完全なセットを構成します。同じ積分状態を持つ2つの :ref:`mjData` インスタンスのパイプライン出力は同一になります。*逆動力学* の場合、``mjData.qacc`` も入力変数として扱われます。他のすべての :ref:`mjData` フィールドは、積分状態の関数です。

:ref:`mjSTATE_INTEGRATION<mjtState>` によって与えられる完全な積分状態は最大主義的であり、しばしば未使用のフィールドを含むことに注意してください。小さな状態サイズが望ましい場合、未使用のフィールドを保存しないことが賢明かもしれません。特に ``xfrc_applied`` はかなり大きくなる可能性があります（``nbody x 6``）が、しばしば未使用です。

.. _siSimulationState:

シミュレーション状態
""""""""""""""""""""
*シミュレーション状態* は、:ref:`mjData` 構造体全体と関連するメモリバッファです。この状態には、ダイナミクス計算中に計算されるすべての派生量が含まれます。:ref:`mjData` バッファは最悪の場合に事前割り当てされるため、:ref:`mj_copyData` を使用するよりも :ref:`積分状態<siIntegrationState>` から派生量を再計算する方がはるかに高速であることがよくあります。スリーピングが有効になっている場合のシミュレーション状態に関する注意事項については、:ref:`スリーピングに関する注意 <siSleepNotes>` を参照してください。

.. _siStateManipulation:

状態操作
^^^^^^^^
状態の操作は、上記で文書化された状態要素を列挙する :ref:`mjtState` ビットフィールド列挙型によって容易になります。要素の組み合わせ（その一部は列挙型自体で利用可能）をOR演算してビットフィールド値を形成できます。例えば次のようになります。

.. code-block:: C

   int sig = mjSTATE_TIME | mjSTATE_QPOS | mjSTATE_CTRL;  // custom choice of state components

これらのビットフィールドを使用する関数は、:ref:`mj_getState`、:ref:`mj_setState`、:ref:`mj_copyState`、:ref:`mj_extractState` です。たとえば、:ref:`mjData` インスタンス ``src`` から別のインスタンス ``dst`` に :ref:`積分状態<siIntegrationState>` をコピーした後：

.. code-block:: C

   mj_copyState(model, src, dst, mjSTATE_INTEGRATION);

``src`` または ``dst`` をステッピングすると、同一の結果が生成されます。状態は単一の :ref:`mjtNum` 配列から取得および設定できます。

.. code-block:: C

   int sig = mjSTATE_TIME | mjSTATE_QPOS | mjSTATE_CTRL;
   int size = mj_stateSize(model, sig);
   mjtNum* state = mju_malloc(size * sizeof(mjtNum));
   mj_getState(model, src, state, sig);  // copy time, qpos and ctrl from src into state
   mj_setState(model, dst, state, sig);  // copy time, qpos and ctrl from state into dst

mjData全体も関数 :ref:`mj_copyData` でコピーできますが、もちろん :ref:`mj_copyState` よりもはるかに遅くなります。

この文脈で関連するのは、関数 :ref:`mj_resetData` です。これは ``mjData.qpos`` をモデル参照構成 ``mjModel.qpos0`` と等しく設定し、``mjData.mocap_pos`` と ``mjData.mocap_quat`` をmjModelの対応する固定ボディ姿勢と等しく設定し、他のすべての状態と制御変数を0に設定します。一部のツリーが *スリープ状態で初期化* されている場合、この関数はさらに多くの作業を行います。詳細は後述の :ref:`スリーピング <siSleepSleeping>` を参照してください。

.. _siForward:

順動力学
~~~~~~~~
順動力学の目標は、状態の時間微分、すなわち加速度ベクトル ``mjData.qacc`` と活性化時間微分 ``mjData.act_dot`` を計算することです。その過程で、アクティブな接触やその他の制約、関節空間慣性とその :math:`L^TDL` 分解、制約力、センサーデータなど、ダイナミクスのシミュレートに必要な他のすべてを計算します。これらすべての中間結果は :ref:`mjData` で利用可能であり、カスタム計算で使用できます。上記の :ref:`シミュレーションループ <siSimulation>` セクションで示したように、メインステッパー関数 :ref:`mj_step` は :ref:`mj_forward` を呼び出してほとんどの作業を実行し、次に数値積分器を呼び出してシミュレーション状態を次の離散時点に進めます。

順動力学関数 :ref:`mj_forward` は内部的に、スキップ引数（mjSTAGE_NONE、0）で :ref:`mj_forwardSkip` を呼び出します。後者の関数は次のように実装されています。

.. code-block:: C

   void mj_forwardSkip(const mjModel* m, mjData* d, int skipstage, int skipsensor) {
     // position-dependent
     if (skipstage < mjSTAGE_POS) {
       mj_fwdPosition(m, d);
       if (!skipsensor)
         mj_sensorPos(m, d);
       if (mjENABLED(mjENBL_ENERGY))
         mj_energyPos(m, d);
     }

     // velocity-dependent
     if (skipstage < mjSTAGE_VEL) {
       mj_fwdVelocity(m, d);
       if (!skipsensor)
         mj_sensorVel(m, d);
       if (mjENABLED(mjENBL_ENERGY))
         mj_energyVel(m, d);
     }

     // acceleration-dependent
     if (mjcb_control)
       mjcb_control(m, d);
     mj_fwdActuation(m, d);
     mj_fwdAcceleration(m, d);
     mj_fwdConstraint(m, d);
     if (!skipsensor)
       mj_sensorAcc(m, d);
   }

これは上記の :ref:`mj_step1` と :ref:`mj_step2` と同じ呼び出しシーケンスであることに注意してください。ただし、実数値のチェックやセンサーやエネルギーなどの機能の計算は省略されています。呼び出されている関数は、シミュレーションパイプラインのコンポーネントです。それらは順番にサブコンポーネントを呼び出します。

整数引数skipstageは、計算のどの部分がスキップされるかを決定します。可能なスキップレベルは次のとおりです。

mjSTAGE_NONE
   何もスキップしません。すべての計算を実行します。
mjSTAGE_POS
   位置に依存するが速度や制御や適用力には依存しない計算をスキップします。このような計算の例には、順運動学、衝突検出、慣性行列の計算と分解が含まれます。これらの計算は通常、最も多くのCPU時間を消費するため、可能な限りスキップする必要があります（以下を参照）。
mjSTAGE_VEL
   位置と速度に依存するが制御や適用力には依存しない計算をスキップします。例には、コリオリ力と遠心力、受動減衰力、制約安定化のための参照加速度の計算が含まれます。

mjDataの中間結果フィールドは、それらを計算するために必要な状態のどの部分に応じて、セクションに編成されています。mjSTAGE_POSで :ref:`mj_forwardSkip` を呼び出すと、最初のセクション（位置依存）のフィールドがすでに計算されていると仮定し、再計算しません。同様に、mjSTAGE_VELは、最初と2番目のセクション（位置および速度依存）のフィールドがすでに計算されていると仮定します。

上記の機構を使用して、計算の一部をスキップできるのはいつでしょうか？通常のシミュレーションでは、これは不可能です。しかし、MuJoCoはシミュレーションだけでなく、モデルベース最適化、機械学習などのより高度なアプリケーションのために設計されています。そのような設定では、近くの状態のクラウドでダイナミクスをサンプリングしたり、有限差分を介して導関数を近似したりする必要があることがよくあります。これは別の形式のサンプリングです。サンプルが、位置のみ、速度のみ、または制御のみが中心点と異なるグリッド上に配置されている場合、上記のメカニズムは約2倍のパフォーマンス向上によってパフォーマンスを改善できます。

.. _siInverse:

逆動力学
~~~~~~~~

逆動力学の計算はMuJoCoのユニークな機能であり、接触をシミュレートできる他の最新エンジンには見られません。逆動力学は明確に定義されており、概要章で説明した :ref:`ソフト制約モデル <Constraint>` のおかげで、計算が非常に効率的です。実際、順動力学と共有される位置および速度依存の計算が実行された後、加速度が与えられたときの制約と適用力の回復は解析式に帰着します。これは非常に高速であるため、実際には逆動力学（前のタイムステップで計算された加速度を使用）を使用して、順動力学の反復制約ソルバーをウォームスタートします。

逆動力学への入力は、:ref:`状態と制御 <siStateControl>` で示した順動力学の状態ベクトルと同じですが、``mjData.act`` と ``mjData.time`` を除きます。ユーザー定義状態変数に依存するコールバックがないと仮定すると、逆動力学への入力はmjDataの次のフィールドです。

::

     (mjData.qpos, mjData.qvel, mjData.qacc, mjData.mocap_pos, mjData.mocap_quat)

主な出力は ``mjData.qfrc_inverse`` です。これは、観測された加速度 ``mjData.qacc`` を達成するためにシステムに作用している必要がある力です。順動力学が反復ソルバーを完全な収束まで実行することによって正確に計算された場合、次のようになります。

::

     mjData.qfrc_inverse = mjData.qfrc_applied + Jacobian'*mjData.xfrc_applied + mjData.qfrc_actuator

ここで ``mjData.qfrc_actuator`` はアクチュエータによって生成される関節空間力であり、ヤコビアンは関節空間から直交空間へのマッピングです。``mjModel.opt.enableflags`` の :ref:`fwdinv<option-flag-fwdinv>` フラグが設定されている場合、上記の恒等式は順動力学ソリューションの品質を監視するために使用されます。特に、``mjData.solver_fwdinv`` の2つの成分は、関節力と制約力の観点から、順方向ソリューションと逆方向ソリューションの差のL2ノルムに設定されます。

順動力学と同様に、:ref:`mj_inverse` は内部的にスキップ引数 ``(mjSTAGE_NONE, 0)`` で :ref:`mj_inverseSkip` を呼び出します。スキップメカニズムは順動力学と同じであり、構造化サンプリングを高速化するために使用できます。結果 ``mjData.qfrc_inverse`` は、再帰ニュートン・オイラーアルゴリズムを使用してシステムに作用する正味の力を計算し、次にそれからすべての内部力を減算することによって得られます。

逆動力学は、実験データが利用可能な場合の分析ツールとして使用できます。これはロボット工学やバイオメカニクスで一般的です。また、与えられた参照軌道に沿ってシステムを駆動するために必要な関節トルクを計算するためにも使用できます。これは計算トルク制御として知られています。状態推定、システム同定、および最適制御の文脈では、最適化ループ内で使用して、他のコストとともに軌道に沿った物理違反を最小化する状態のシーケンスを見つけることができます。物理違反は、逆動力学によって計算された説明できない外力のノルムとして定量化できます。

.. _siMultithread:

マルチスレッド
~~~~~~~~~~~~~~

MuJoCoが :ref:`シミュレーションループ <siSimulation>` セクションで説明されているようにシミュレーションに使用される場合、単一のスレッドで実行されます。シミュレーションパイプラインの計算量が多く、並列処理に適した部分をマルチスレッド化する実験を行いましたが、高速化は追加のプロセッサコアを使用する価値がないという結論に達しました。これは、MuJoCoが同じタイムステップ内で複数のスレッドを起動して同期するオーバーヘッドと比較してすでに高速であるためです。ユーザーが多数の浮遊ボディを含む大規模なシミュレーションを扱い始めた場合、最終的にステップ内マルチスレッドを実装する可能性がありますが、現在のところこのユースケースは一般的ではありません。

単一のシミュレーションを高速化するのではなく、より高度なアプリケーションで一般的なサンプリング操作を高速化するためにマルチスレッドを使用することを好みます。シミュレーションは本質的に時間に対してシリアルです（1つのmj_stepの出力が次の入力になります）が、サンプリングでは、共通の初期状態を除いて、それらの間に依存関係がないため、順動力学または逆動力学への多くの呼び出しを並列に実行できます。

MuJoCoは最初からマルチスレッド用に設計されています。力学系の状態の概念がソフトウェア状態にマッピングするのが難しく、しばしば複数のオブジェクトに分散しているほとんどの既存のシミュレータとは異なり、MuJoCoには時間経過とともに変化するすべてを含む統一されたデータ構造mjDataがあります。:ref:`状態と制御 <siStateControl>` の議論を思い出してください。重要なアイデアは、各スレッドに1つのmjDataを作成し、次にそれをすべてのスレッドごとの計算に使用することです。以下は、スレッド管理を簡素化するためにOpenMPを使用した一般的なテンプレートです。

.. code-block:: C

   // prepare OpenMP
   int nthread = omp_get_num_procs();      // get number of logical cores
   omp_set_dynamic(0);                     // disable dynamic scheduling
   omp_set_num_threads(nthread);           // number of threads = number of logical cores

   // allocate per-thread mjData
   mjData* d[64];
   for (int n=0; n < nthread; n++)
     d[n] = mj_makeData(m);

   // ... serial code, perhaps using its own mjData* dmain

   // parallel section
   #pragma omp parallel
   {
     int n = omp_get_thread_num();       // thread-private variable with thread id (0 to nthread-1)

     // ... initialize d[n] from results in serial code

     // thread function
     worker(m, d[n]);                    // shared mjModel (read-only), per-thread mjData (read-write)
   }

   // delete per-thread mjData
   for (int n=0; n < nthread; n++)
     mj_deleteData(d[n]);

すべてのトップレベルAPI関数はmjModelを ``const`` として扱うため、このマルチスレッドスキームは安全です。各スレッドは独自のmjDataにのみ書き込みます。したがって、スレッド間のさらなる同期は必要ありません。

上記のテンプレートは、特定のスタイルの並列処理を反映しています。多数のスレッド（各作業項目に1つ）を作成し、OpenMPがそれらをプロセッサ間で分散させるのではなく、手動スケジューリングに依存しています。より正確には、プロセッサと同じ数のスレッドを作成し、次に ``worker`` 関数内でスレッド間に明示的に作業を分散します。このアプローチは、スレッド固有のmjDataがプロセッサキャッシュと比較して大きいため、より効率的です。

キャッシュ効率のために共有mjModelも使用します。状況によっては、すべてのスレッドで同じmjModelを使用できない場合があります。明らかな理由の1つは、スレッド関数内でmjModelを変更する必要がある場合です。もう1つの理由は、mjModel内に含まれるmjOption構造体を調整する必要がある場合です（たとえば、ソルバー反復回数を制御するため）が、これはすべての並列スレッドで同じである可能性が高いため、並列セクションの前に共有モデルで調整できます。

スレッド固有のmjDataがどのように初期化され、スレッド関数が何をするかは、もちろんアプリケーション依存です。それでも、前のセクションの一般的な効率ガイドラインがここでも適用されます。状態をスレッド固有のmjDataにコピーしてMuJoCoを実行して残りを埋めることは、mj_copyDataを使用するよりも高速な場合があります。さらに、順動力学と逆動力学の両方で利用可能なスキップメカニズムは、サンプルに通常再利用できる計算を可能にする構造があるため、並列サンプリングアプリケーションで特に便利です。最後に、順方向ソルバーは反復的であり、良好なウォームスタートは必要な反復回数を大幅に削減できることに留意してください。サンプルが状態と制御空間で互いに近い場合、1つのサンプル（理想的には中心）のソリューションを使用して、他のすべてのサンプルをウォームスタートできます。この設定では、近くのサンプル間の異なる結果が、サンプル間の真の差を反映していることを確認し、異なるウォームスタートや反復ソルバーの終了ではないことを確認することが重要です。

.. _siChange:

mjModelの変更
~~~~~~~~~~~~~

.. admonition:: :ref:`mjSpec` による手続き型モデル編集
   :class: tip

   以下の :ref:`mjModel` の変更に関する議論は、手続き型 :doc:`モデル編集<modeledit>` の導入前に書かれました。まだ有効ですが、新しいフレームワークがモデルを変更する安全で推奨される方法です。実行時に :ref:`mjModel` を変更する主な理由は、:ref:`mjSpec` を変更して再度コンパイルするのではなく、*速度* です。ただし、一部の変更を行うことは安全ではない場合があります。セグメンテーション違反が発生する可能性があるという意味で、または物理が予期せず変化するという意味でです。

一般的なルールは、実数値パラメータは変更しても安全ですが、構造的な整数パラメータは、不正なサイズやインデックスにつながる可能性があるため安全ではありません。このルールは普遍的には成り立たず、以下では例外について説明します。

**整数** 型が **変更しても安全ではない** という一般的なルールの例外：

.. list-table::
   :widths: 1 1 4
   :header-rows: 1
   :class: table-small

   * - フィールド
     - 変更可能性
     - 注記
   * - ``XXX_limited`` |br| ``XXX_group`` |br| ``XXX_matid`` |br| ``XXX_texid``
     - 安全
     -
   * - ``XXX_sameframe``
     - 安全ではない
     - このフラグは、エンジンに親/子フレーム変換をスキップするように指示します。0から0以外に変更することは安全ですが、その逆は安全ではありません。
   * - ``geom_contype`` |br| ``geom_conaffinity``
     - 安全ではない
     - 親ボディの ``body_contype`` と ``body_conaffinity`` がすべての子ジオムのビット単位のORに更新される場合、これは安全に行うことができます。
   * - ``geom_condim`` |br| ``geom_priority``
     - 安全
     -
   * - ``cam_resolution``
     - 安全
     -
   * - ``light_castshadow`` |br| ``light_active``
     - 安全
     -
   * - ``flex_contype`` |br|  ``flex_conaffinity`` |br|  ``flex_condim`` |br|  ``flex_priority``
     - 安全
     -
   * - ``tex_data``
     - 安全
     - GPUメモリの値を更新するには :ref:`mjr_uploadTexture` を呼び出す必要があります。

実数値パラメータが変更しても安全であるというルールの例外を検討する場合、コンパイルプロセスの最後のステップを構成する関数 :ref:`mj_setConst` に注意する必要があります。この関数は、一部のフィールドから他のフィールドへの変更を伝播し、それ以外の場合は安全ではない変更を可能にします。

**実数値** 型が **変更しても安全** であるという一般的なルールの例外：

.. list-table::
   :widths: 1 1 4
   :header-rows: 1
   :class: table-small

   * - フィールド
     - 変更可能性
     - 注記
   * - ``qpos0`` |br| ``qpos_spring``
     - :ref:`mj_setConst` で安全。
     -
   * - ``body_mass`` |br| ``body_inertia`` |br| ``body_ipos`` |br| ``body_iquat``
     - :ref:`mj_setConst` で安全。
     - 質量と慣性は通常一緒にスケーリングされることに注意してください。慣性は :math:`\sum m r^2` であるためです。それらを個別にスケーリングすることは正当ですが、空間質量分布の変化を意味します。また、対角慣性は三角不等式に従わなければならないことに注意してください。
   * - ``body_pos`` |br| ``body_quat``
     - :ref:`mj_setConst` で安全。
     - 静的ボディには安全ではありません。中間フェーズ衝突構造（BVH）を無効にします。
   * - ``body_gravcomp``
     - 安全。
     - 重力補償を持つボディの数が0から0以外に変更された場合、:ref:`mj_setConst` を呼び出す必要があります。
   * - ``dof_armature``
     - :ref:`mj_setConst` で安全。
     -
   * - ``geom_pos`` |br| ``geom_quat`` |br| ``geom_size`` |br| ``geom_rbound`` |br| ``geom_aabb``
     - 安全ではない。
     -
   * - ``{site,cam,light}_`` |br| ``{pos,quat}``
     - ほぼ安全。
     - トラッキングまたはターゲティングを使用するカメラとライトの場合、:ref:`mj_setConst` が必要です。
   * - ``tendon_stiffness`` |br| ``tendon_damping``
     - ほぼ安全。
     - キネマティックツリーがスリープできるかどうかに影響します。0から/0への変更の場合、:ref:`mj_setConst` が必要です。
   * - ``actuator_gainprm`` |br| ``actuator_biasprm``
     - ほぼ安全。
     - :ref:`dampratio<actuator-position-dampratio>` を使用する位置風アクチュエータの場合、:ref:`mj_setConst` が必要です。
   * - ``eq_data``
     - :ref:`mj_setConst` で安全。
     - connectとweld制約の場合、提供されていない場合はオフセットが計算されます。
   * - ``hfield_size``
     - :ref:`mj_setConst` で安全。
     -
   * - ``hfield_data``
     - 安全。
     - データ範囲は[0, 1]である必要があります。
       |br| GPUメモリの値を更新するには :ref:`mjr_uploadHField` が必要です。
   * -  ``mesh_scale`` |br| ``mesh_pos`` |br| ``mesh_quat``
     - 安全ではありませんが、効果がありません。
     - ``mesh_pos`` と ``mesh_quat`` は実行時にSDFセンサーに影響を与えます。
   * - ``mesh_vert`` |br| ``mesh_normal`` |br| ``mesh_face`` |br| ``mesh_polynormal``
     - 衝突メッシュには安全ではない。
     - ビジュアルメッシュには安全ですが、GPUメモリの値を更新するには :ref:`mjr_uploadMesh` が必要です。
   * - ``bvh_aabb`` |br| ``oct_aabb`` |br| ``oct_coeff``
     - 安全ではない
     -

最後に、実行時にmjModelに変更が加えられた場合、それらをXMLに保存することが望ましい場合があります。関数 :ref:`mj_saveLastXML` と :ref:`mj_copyBack` は限定的な意味でそれを行います。すべての実数値パラメータを :ref:`mjModel` から :ref:`mjSpec` にコピーします（前者の場合はグローバル内部spec、後者の場合はユーザーのコピー）。これは、ユーザーが行った可能性のあるすべての変更をカバーするわけではありません。すべての変更が保存されることを保証する唯一の方法は、関数 :ref:`mj_saveModel` を使用してモデルをバイナリMJBファイルとして保存するか、さらに良いことに、XMLまたは :ref:`mjSpec` で直接変更を行うことです。要約すると、モデルの変更を保存するための合理的ですが完璧ではないメカニズムがあります。この完璧さの欠如の理由は、コンパイル済みモデルを扱っているため、これはバイナリ実行可能ファイルを変更して「デコンパイラ」にCコードに対応する変更を行うように求めるようなものであり、一般的には不可能だからです。

.. _siLayout:

データレイアウト
~~~~~~~~~~~~~~~~

MuJoCoのすべての行列は **行優先** 形式です。たとえば、線形メモリ配列（a0、a1、... a5）は2行3列の行列を表します。

.. code-block:: Text

     a0 a1 a2
     a3 a4 a5

この規則は伝統的にCに関連付けられてきましたが、反対の列優先規則はFortranに関連付けられてきました。どちらを選択するかについて特別な理由はありませんが、選択が何であれ、常にそれを念頭に置くことが不可欠です。:ref:`mju_mulMatMat`、:ref:`mju_mulMatVec` などの行列を操作するすべてのMuJoCoユーティリティ関数は、この行列レイアウトを前提としています。ベクトルの場合、行優先形式と列優先形式の間に違いはもちろんありません。

可能な場合、MuJoCoは疎性を利用します。これにより、O(N)とO(N^3)のスケーリングの間のすべての違いが生じる可能性があります。慣性行列 ``mjData.qM`` とそのLTDL因数分解 ``mjData.qLD`` は常に疎として表されます。``qM`` はツリートポロジーに対応する行列用に設計されたカスタムインデックス形式を使用し、``qLD`` は標準のCSR形式を使用します。``qM`` は今後の変更でCSRに移行されます。関数 :ref:`mj_factorM`、:ref:`mj_solveM`、:ref:`mj_solveM2`、:ref:`mj_mulM` は、疎因数分解、代入、行列ベクトル乗算に使用されます。ユーザーは、関数 :ref:`mj_fullM` を使用してこれらの行列を密形式に変換することもできますが、MuJoCoは内部的にそれを決して行いません。

制約ヤコビアン行列 ``mjData.efc_J`` は、疎ヤコビアンオプションが有効になっている場合は常に疎として表されます。関数 :ref:`mj_isSparse` を使用して、疎形式が現在使用されているかどうかを判断できます。その場合、転置ヤコビアン ``mjData.efc_JT`` も計算され、逆制約慣性 ``mjData.efc_AR`` が疎になります。疎行列は圧縮疎行（CSR）形式で格納されます。次元がm×nの汎用行列Aの場合、この形式は次のとおりです。

======== ====== ============================================
変数     サイズ 意味
======== ====== ============================================
A        m \* n 実数値データ
A_rownnz m      行ごとの非ゼロの数
A_rowadr m      AとA_colindの行データの開始インデックス
A_colind m \* n 列インデックス
======== ====== ============================================


したがって、A[A_rowadr[r]+k]は、行rと列A_colind[A_rowadr[r]+k]の基礎となる密行列の要素であり、k < A_rownnz[r]です。通常、m*n記憶域は必要ありません（行列が実際に疎であると仮定すると）が、最悪のシナリオ用のスペースを割り当てます。さらに、疎性パターンを変更できる操作では、新しいデータを挿入するときに多くのメモリ移動を実行する必要がないように、データを分散させる方が効率的です。この疎レイアウトを「非圧縮」と呼びます。これは依然として有効なレイアウトですが、標準の規則であるA_rowadr[r] = A_rowadr[r-1] + A_rownnz[r]の代わりに、A_rowadr[r] = r*nを設定します。MuJoCoは内部的に疎行列を使用します。

3D方向と回転を表すために、MuJoCoは単位クォータニオンを使用します。すなわち、q = (w, x, y, z)のように配置された4D単位ベクトルです。ここで(x, y, z)は、sin(a/2)でスケーリングされた回転軸単位ベクトルであり、aはラジアンでの回転角度であり、w = cos(a/2)です。したがって、ヌル回転に対応するクォータニオンは(1, 0, 0, 0)です。これはMJCFのすべてのクォータニオンのデフォルト設定です。

MuJoCoは内部的に6D空間ベクトルも使用します。これらは、mjDataで'c'で始まる量、すなわちcvel、cacc、cdotなどです。これらは、3D回転成分とそれに続く3D並進成分を組み合わせた空間運動力ベクトルです。これらを扱うユーティリティ関数は提供していませんし、それらを文書化することは私たちの範囲を超えています。Roy Featherstoneの `空間代数 <http://royfeatherstone.org/spatial/>`__ に関するWebページを参照してください。異例の順序（並進の前の回転）はこの資料に基づいており、過去に明らかに標準的な規則でした。

データ構造mjModelとmjDataには、事前割り当てされたバッファへの多くのポインタが含まれています。これらのデータ構造のコンストラクタ（mj_makeModelとmj_makeData）は、1つの大きなバッファ、すなわち ``mjModel.buffer`` と ``mjData.buffer`` を割り当て、次にそれを分割し、その中の他のすべてのポインタを設定します。mjDataには、以下で説明するように、このメインバッファの外側にスタックも含まれています。たとえば ``mjData.qpos`` と ``mjData.qvel`` のように、2つのポインタが順番に表示されても、データ配列が連続していてそれらの間にギャップがないと仮定しないでください。コンストラクタは各データ配列にバイトアラインメントを実装し、必要に応じてバイトをスキップします。したがって、``mjData.qpos`` と ``mjData.qvel`` をコピーする場合、正しい方法は難しい方法です。

.. code-block:: C

   // do this
   mju_copy(myqpos, d->qpos, m->nq);
   mju_copy(myqvel, d->qvel, m->nv);

   // DO NOT do this, there may be padding at the end of d->qpos
   mju_copy(myqposqvel, d->qpos, m->nq + m->nv);

オプションのヘッダーファイル ``mjxmacro.h`` で定義されている :ref:`Xマクロ <tyXMacro>` を使用して、mjModelとmjDataに一致するデータ構造の割り当てを自動化できます。たとえば、スクリプト言語用のMuJoCoラッパーを作成する場合などです。

.. _siStack:

内部スタック
~~~~~~~~~~~~

MuJoCoは、``mjData.arena`` の「アリーナ」スペースで動的メモリを割り当てて管理します。アリーナメモリスペースには、2種類の動的に割り当てられたメモリが含まれています。

 - 接触数はステップの開始時に不明であるため、制約に関連するメモリ。
 - 内部スタックメカニズムによって管理される一時変数用のメモリ。

アリーナと内部スタックのレイアウトの詳細については、:ref:`CSize` を参照してください。

ほとんどのトップレベルMuJoCo関数は、:ref:`mjData` スタックにスペースを割り当て、内部計算に使用し、次に解放します。実行時に割り当てサイズが動的に決定されるため、通常のCスタックではこれを実行できません。ヒープメモリ管理関数を呼び出すと、非効率的になり、断片化が発生します。そのため、カスタムスタックです。MuJoCo関数が呼び出されると、戻り時に ``mjData.pstack`` の値は同じです。唯一の例外は、関数 :ref:`mj_resetData` とそのバリアントです。これらは ``mjData.pstack = 0`` を設定します。この関数は、:ref:`mj_step`、:ref:`mj_step1`、:ref:`mj_step2` で不安定性が検出されたときに内部的に呼び出されることに注意してください。したがって、ユーザー関数がカスタムスタックを利用する場合、これはシミュレーションをリセットする可能性のあるMuJoCo呼び出しの間に行う必要があります。

以下は、ユーザーコードでカスタムスタックを使用するための一般的なテンプレートです。

.. code-block:: C

   // mark an mjData stack frame
   mj_markStack(d);

   // allocate space
   mjtNum* myqpos = mj_stackAllocNum(d, m->nq);
   mjtNum* myqvel = mj_stackAllocNum(d, m->nv);

   // restore the mjData stack frame
   mj_freeStack(d);

関数 :ref:`mj_stackAllocNum` は、十分なスペースがあるかどうかをチェックし、ある場合はスタックポインタを進め、そうでない場合はエラーをトリガーします。また、最大スタック割り当てを追跡します。後述の :ref:`診断 <siDiagnostics>` を参照してください。:ref:`mj_stackAllocNum` は ``mjtNum`` 配列の割り当てにのみ使用されることに注意してください。これは最も一般的なタイプの配列です。整数配列割り当てには :ref:`mj_stackAllocInt` が、任意のバイト数とアラインメントの割り当てには :ref:`mj_stackAllocByte` が提供されています。

.. _siError:

エラーと警告
~~~~~~~~~~~~

致命的なエラーが発生すると、MuJoCoは内部的に関数 :ref:`mju_error` を呼び出します。mju_errorが行うことは次のとおりです。

#. プログラムディレクトリのファイルMUJOCO_LOG.TXTの最後にエラーメッセージを追加します（ファイルが存在しない場合は作成します）。また、エラーメッセージとともに日時も書き込みます。
#. ユーザーエラーコールバック :ref:`mju_user_error` がインストールされている場合、エラーメッセージを引数としてその関数を呼び出します。そうでない場合は、エラーメッセージと「終了するにはEnterキーを押してください...」を標準出力に出力します。次に、任意のキーボード入力を待ち、次に失敗でシミュレータを終了します。

ユーザーエラーコールバックがインストールされている場合、それは **返してはなりません**。そうしないと、シミュレータの動作は未定義です。ここでの考え方は、mju_errorが呼び出された場合、シミュレーションは続行できず、ユーザーはエラー条件が回避されるように何らかの変更を行うことが期待されるということです。エラーメッセージは自明です。

エラーの後でも続行することが望ましい状況の1つは、モデルファイルのロードに失敗したインタラクティブシミュレータです。これは、ユーザーが間違ったファイル名を提供したか、モデルのコンパイルに失敗したためである可能性があります。これは、mju_errorの呼び出しを回避する特別なメカニズムによって処理されます。モデルロード関数 :ref:`mj_loadXML` と :ref:`mj_loadModel` は、操作が失敗した場合はNULLを返し、プログラムを終了する必要はありません。mj_loadXMLの場合、失敗を引き起こしたパーサーまたはコンパイラエラーを含む出力引数がありますが、mj_loadModelは対応する警告を生成します（以下を参照）。

内部的にmj_loadXMLは実際にmju_errorメカニズムを使用し、一時的にC++例外をトリガーする「ユーザー」ハンドラをインストールし、次にそれを傍受します。これは、パーサー、コンパイラ、ランタイムが一緒にコンパイルおよびリンクされ、C/C++メモリマネージャと標準ライブラリの同じコピーを使用しているため可能です。ユーザーがC++例外をトリガーするエラーコールバックを実装する場合、これはユーザーのワークスペースにあり、MuJoCoライブラリワークスペースと必ずしも同じではないため、何が起こるかは明確ではありません。結果はおそらくコンパイラとプラットフォームに依存します。このアプローチを避けて、mju_errorが呼び出されたときに単に終了する方が良いです（これはユーザーハンドラがない場合のデフォルトの動作です）。

MuJoCoは警告も生成できます。これらは、数値的な不正確さを引き起こす可能性が高い条件を示しますが、モデルのロードやその他の問題のある状況での問題を示すこともできますが、シミュレータは通常の動作を続けることができます。警告メカニズムには2つのレベルがあります。高レベルは関数 :ref:`mj_warning` で実装されます。これは、後述の :ref:`診断 <siDiagnostics>` セクションで詳しく説明するように、mjDataに警告を登録し、低レベル関数 :ref:`mju_warning` も呼び出します。あるいは、低レベル関数は、mjDataに警告を登録せずに直接呼び出される場合があります（たとえば、mj_loadModel内から）。これは、mjDataが利用できない場所で行われます。

mju_warningは次のことを行います。ユーザーコールバック :ref:`mju_user_warning` がインストールされている場合、そのコールバックを呼び出します。そうでない場合は、警告メッセージをMUJOCO_LOG.TXTに追加し、mju_errorと同様にprintfも実行しますが、終了しません。MATLABなどの環境用のMuJoCoラッパーが開発されている場合、コマンドウィンドウで警告を出力するユーザーコールバックをインストールすることは理にかなっています（mexPrintfを使用）。

MuJoCoがヒープでメモリを割り当てて解放する場合、常に関数 :ref:`mju_malloc` と :ref:`mju_free` を使用します。これらの関数は、インストールされている場合はユーザーコールバック :ref:`mju_user_malloc` と :ref:`mju_user_free` を呼び出し、そうでない場合は標準のC関数mallocとfreeを呼び出します。この間接化の理由は、ユーザーがMuJoCoに制御下のヒープを使用させたい場合があるためです。たとえば、MATLABでは、メモリ割り当てのユーザーコールバックはmxmallocとmexMakeArrayPersistentを使用します。

.. _siDiagnostics:

診断
~~~~

MuJoCoには、モデルを微調整するために使用できるいくつかの組み込み診断メカニズムがあります。それらの出力は、mjDataの先頭にある診断セクションにグループ化されています。

シミュレータが致命的なエラーではないが、それでも疑わしく、不正確な数値結果をもたらす可能性が高い状況に遭遇すると、警告をトリガーします。いくつかの可能な警告タイプがあり、列挙型 :ref:`mjtWarning` によってインデックス付けされています。配列 ``mjData.warning`` には、警告タイプごとに1つの :ref:`mjWarningStat` データ構造が含まれており、前回のリセット以降に各警告タイプがトリガーされた回数と、警告に関する情報（通常は問題のあるモデル要素のインデックス）を示します。カウンタはリセット時にクリアされます。特定のタイプの警告が最初にトリガーされたとき、警告テキストも上記の :ref:`エラーとメモリ <siError>` に文書化されているようにmju_warningによって出力されます。これはすべて、シミュレータが警告に遭遇したときに内部的に呼び出す関数 :ref:`mj_warning` によって行われます。ユーザーもこの関数を直接呼び出して警告をエミュレートできます。

モデルを高速シミュレーションのために最適化する必要がある場合、パイプラインのどこでCPU時間が費やされているかを知ることが重要です。これは順に、モデルのどの部分を簡素化するか、またはユーザーアプリケーションをどのように設計するかを示唆する可能性があります。MuJoCoは広範なプロファイリングメカニズムを提供します。これには、列挙型 :ref:`mjtTimer` によってインデックス付けされた複数のタイマーが含まれます。各タイマーは、トップレベルAPI関数、またはそのような関数のコンポーネントに対応しています。警告と同様に、タイマー情報は蓄積され、リセット時にのみクリアされます。配列 ``mjData.timer`` には、タイマーごとに1つの :ref:`mjTimerStat` データ構造が含まれています。特定のタイマー（以下の例では ``mj_step`` に対応）の呼び出しあたりの平均期間は、次のように計算できます。

.. code-block:: C

   mjtNum avtm = d->timer[mjTIMER_STEP].duration / mjMAX(1, d->timer[mjTIMER_STEP].number);

このメカニズムはMuJoCoに組み込まれていますが、タイマーコールバック :ref:`mjcb_time` がユーザーによってインストールされている場合にのみ機能します。そうでない場合、すべてのタイマー期間は0です。この設計の理由は、追加の依存関係を導入せずにCで高解像度タイマーを実装するプラットフォーム非依存の方法がないためです。また、ほとんどの場合、ユーザーはタイミングを必要としないため、その場合はタイミング関数を呼び出す理由がありません。

緊密に監視する必要があるシミュレーションパイプラインの一部は、反復制約ソルバーです。ここで最も単純な診断は ``mjData.solver_niter`` であり、mj_stepまたは ``mj_forward`` への最後の呼び出しでソルバーが何回反復したかを示します。ソルバーには早期終了のための許容差パラメータがあるため、この数値は通常、許可される最大反復回数よりも小さいことに注意してください。配列 ``mjData.solver`` には、制約ソルバーの反復ごとに1つの :ref:`mjSolverStat` データ構造が含まれており、制約状態と直線探索に関する情報があります。

``mjModel.opt.enableflags`` でオプション :at:`fwdinv` が有効になっている場合、フィールド ``mjData.fwdinv`` も設定されます。これには、順動力学と逆動力学の差が、一般化力と制約力の観点から含まれています。逆動力学は解析式を使用し、常に正確であることを思い出してください。したがって、不一致は順動力学の反復ソルバーの収束が不十分なためです。終了近くの ``mjData.solver`` の数値は、``mjData.fwdinv`` の数値と同程度のオーダーですが、それでもこれらは2つの異なる診断です。

MuJoCoのランタイムはコンパイル済みモデルで動作するため、モデルがコンパイルまたはロードされるときにメモリが事前割り当てされます。MJCFの :ref:`size <size>` 要素の :at:`memory` 属性を思い出してください。これは、動的配列用の事前割り当てスペースを決定します。ユーザーは適切な値が何であるかをどのように知ることになっているのでしょうか？信頼できるレシピがあれば、コンパイラに実装していたでしょうが、そうではありません。理論上の最悪のケース、すなわちすべてのジオムが他のすべてのジオムと接触することは、実際にはほとんど必要とされない巨大な割り当てを要求します。私たちのアプローチは、ほとんどのモデルに十分なデフォルト設定をMJCFで提供し、ユーザーが上記の属性で手動で調整できるようにすることです。シミュレータが実行時に動的メモリを使い果たした場合、エラーをトリガーします。このようなエラーがトリガーされた場合、ユーザーは :at:`memory` を増やす必要があります。フィールド ``mjData.maxuse_arena`` は、この調整を支援するように設計されています。これは、最後のリセット以降の最大アリーナ使用量を追跡します。したがって、1つの戦略は、非常に大きな割り当てを行い、次に典型的なシミュレーション中に ``mjData.maxuse_memory`` 統計を監視し、それを使用して割り当てを減らすことです。

運動エネルギーとポテンシャルエネルギーは、``mjModel.opt.enableflags`` の対応するフラグが設定されている場合、``mjData.energy`` で計算および格納されます。これは別の診断として使用できます。一般に、シミュレーションの不安定性はエネルギーの増加に関連しています。一部の特殊なケース（すべての一方向制約、アクチュエータ、および散逸力が無効になっている場合）では、基礎となる物理システムはエネルギー保存です。その場合、総エネルギーの時間的な変動は、数値積分の不正確さを示します。このようなシステムでは、ルンゲ・クッタ積分器は、デフォルトの半陰的オイラー積分器よりもはるかに優れたパフォーマンスを発揮します。

.. _siJacobian:

ヤコビアン
~~~~~~~~~~

ベクトル引数に関するベクトル関数の導関数はヤコビアンと呼ばれます。この用語が多関節運動学およびダイナミクスで使用される場合、システム構成の関数としての空間量の導関数を指します。その場合、ヤコビアンは、構成多様体の（余）接空間のベクトル（速度、運動量、加速度、力など）に作用する線形マップでもあります。ここでの1つの注意点は、``mjData.qpos`` でエンコードされたシステム構成が次元 ``mjModel.nq`` を持っているのに対し、接空間は次元 ``mjModel.nv`` を持っており、クォータニオンジョイントが存在する場合、後者の方が小さいことです。したがって、ヤコビアン行列のサイズは、N×``mjModel.nv`` です。ここでNは、微分される空間量の次元です。

MuJoCoは多くの空間量を解析的に微分できます。これには、テンドンの長さ、アクチュエータ伝達長、エンドエフェクタ姿勢、接触およびその他の制約違反が含まれます。テンドンとアクチュエータ伝達の場合、対応する量は ``mjData.ten_moment`` と ``mjData.actuator_moment`` です。これらをモーメントアームと呼びますが、数学的にはヤコビアンです。すべてのスカラー制約違反のヤコビアン行列は ``mjData.efc_J`` に格納されます。制約自体ではなく制約違反について話していることに注意してください。これは、制約違反が長さの単位を持っている、つまり微分できる空間量であるためです。制約はより抽象的なエンティティであり、それらを微分することが何を意味するかは明確ではありません。

これらの自動計算されたヤコビアンに加えて、ユーザーがオンデマンドで追加のヤコビアンを計算できるサポート関数を提供します。これを行うためのメイン関数は :ref:`mj_jac` です。3D点と、この点が付属していると見なされるMuJoCoボディが与えられます。``mj_jac`` は、並進ヤコビアンと回転ヤコビアンの両方を計算します。これらは、運動学的構成に小さな変更を加えた場合に、与えられた点に固定された空間フレームがどのように並進および回転するかを示します。より正確には、ヤコビアンは関節速度をエンドエフェクタ速度にマッピングし、ヤコビアンの転置はエンドエフェクタ力を関節力にマッピングします。他にもいくつかの ``mj_jacXXX`` 関数があります。これらは、ボディの重心、ジオムの中心など、異なる関心点でメイン ``mj_jac`` 関数を呼び出す便利な関数です。

エンドエフェクタヤコビアンを正確かつ効率的に計算する能力は、関節座標で作業する主な利点です。このようなヤコビアンは、エンドエフェクタエラーをそれらのエラーを抑制するのに適したアクチュエータコマンドにマッピングする多くの制御スキームの基盤です。``mj_jac`` 関数によるMuJoCoでのエンドエフェクタヤコビアンの計算は、CPUコストの観点から基本的に無料です。したがって、この関数の使用をためらわないでください。

.. _siContact:

接触
~~~~

衝突検出と接触力の解決は、 :doc:`../computation/index` 章で詳しく説明されています。ここでは、プログラミングの観点から接触処理をさらに明確にします。

衝突検出ステージは、ジオム間の接触を見つけ、それらを :ref:`mjContact` データ構造の配列 ``mjData.contact`` に記録します。これらは、同じボディのペア間の複数の接触が連続するようにソートされます（1つのボディに複数のジオムが付属している場合があることに注意してください）。ボディペア自体は、最初のボディがメジャーインデックスとして機能し、2番目のボディがマイナーインデックスとして機能するようにソートされます。すべての検出された接触が接触力計算に含まれるわけではありません。接触が含まれる場合、そのmjContact.excludeフィールドは0であり、そのmjContact.efc_addressはアクティブなスカラー制約のリストのアドレスです。除外の理由は、:ref:`ジオム <body-geom>` の :at:`gap` 属性、および中間計算に仮想接触を使用する特定の種類の内部処理である可能性があります。

リスト ``mjData.contact`` は、順動力学と逆動力学の両方の位置ステージによって生成されます。これは自動的に行われます。ただし、ユーザーは内部衝突検出関数をオーバーライドできます。たとえば、非凸メッシュ衝突を実装したり、MuJoCoが提供するものを超えてジオム固有のプリミティブで使用する一部の凸衝突関数を置き換えたりできます。グローバル2D配列 :ref:`mjCOLLISIONFUNC` には、各ジオムタイプのペア（左上の三角形）の衝突関数ポインタが含まれています。それらを置き換えるには、これらのポインタを関数に設定するだけです。衝突関数タイプは :ref:`mjfCollision` です。ユーザー衝突関数が接触を検出すると、各接触のmjvContact構造を構築し、次に関数 :ref:`mj_addContact` を呼び出してその接触を ``mjData.contact`` に追加する必要があります。mj_addContactのリファレンスドキュメントは、カスタム衝突関数によって埋める必要があるmjContactのフィールドを説明しています。ここで話している関数は、ナローフェーズ衝突に対応しており、候補ジオムペアのリストが内部ブロードフェーズ衝突メカニズムによって構築された後にのみ呼び出されることに注意してください。

制約力が計算された後、接触 ``i`` の力のベクトルは次の位置から始まります。

.. code-block:: C

   mjtNum* contactforce = d->efc_force + d->contact[i].efc_address;

同様に、他のすべての ``efc_XXX`` ベクトルについても同様です。接触摩擦円錐は、``mjModel.opt`` で選択されたソルバーに応じて、角錐または楕円になる可能性があることに留意してください。関数 :ref:`mj_isPyramidal` を使用して、どの摩擦円錐タイプが使用されているかを判断できます。角錐円錐の場合、接触力の解釈（上記で計算したアドレス）は自明ではありません。なぜなら、成分は角錐のエッジに対応する冗長な非直交軸に沿った力であるためです。関数 :ref:`mj_contactForce` を使用して、特定の接触によって生成される力をより直感的な形式、すなわち3D力とそれに続く3Dトルクに変換できます。トルク成分は、:at:`condim` が1または3の場合は0になり、それ以外の場合は0以外になります。この力とトルクは、mjContact.frameによって与えられる接触フレームで表現されます。mjDataの他のすべての行列とは異なり、この行列は転置形式で格納されます。通常、座標フレームに対応する3×3行列は、フレーム軸を列に沿って持ちます。ここでは、軸が行列の行に沿っています。したがって、MuJoCoは行優先形式を使用するため、接触法線軸（私たちの規則では接触フレームのX軸）は位置mjContact.frame[0-2]にあり、Y軸は[3-5]に、Z軸は[6-8]にあります。この配置の理由は、法線軸のみが使用される摩擦のない接触を持つことができるため、その座標を ``mjContact.frame`` の最初の3つの位置に配置することは理にかなっているためです。

.. _siSleep:

スリーピングアイランド
~~~~~~~~~~~~~~~~~~~~~~

スリーピングアイランドは、:ref:`計算章 <Sleeping>` で大まかに説明されています。ここでは実装の詳細に焦点を当てます。

:ref:`ツリー<ElemTree>` の高レベルスリープ状態は ``mjData.tree_asleep`` によって記述されます（ただし、後述の注意事項を参照）。負の値はツリーが起きていることを意味し、非負の値は眠っていることを意味します。最大限起きているツリーには値 - |-| (1 |-| + |-| :ref:`mjMINAWAKE<glNumeric>`) が与えられ、速度がスリープ :ref:`許容差 <option-sleep_tolerance>` を下回るすべてのタイムステップで、この整数は-1（「スリープの準備ができている」を意味する）まで増分されます。アイランド内のすべてのツリーがスリープの準備ができている場合、状態の進行中にスリープ状態になり、``tree_asleep`` の関連値は（非負の）インデックスサイクル「スリーピングアイランド」に設定されます。アイランド内のツリーが起こされた場合、すべてが起こされます。

.. _siSleepPolicy:

スリープポリシー
^^^^^^^^^^^^^^^^

キネマティックツリーがスリープできる能力は、モデルコンパイル時に決定されるポリシーによって管理されます。コンパイラは、:ref:`ポリシー<mjtSleepPolicy>` を自動的に「allowed」または「never」に決定しますが、これらは :ref:`body/sleep <body-sleep>` 属性を使用してオーバーライドできます（その中のドキュメントを参照）。特別な「init」スリープポリシーもあります。次のセクションを参照してください。

.. _siSleepSleeping:

スリーピング
^^^^^^^^^^^^

スリーピングは2つの方法のいずれかで発生する可能性があります。

**自動:**
  上記で説明した速度しきい値は、アイランドに関連するすべての速度の無限大ノルム（最大絶対値）に関するものです。このノルムを取る前に、速度は要素ごとに ``mjModel.dof_length`` でスケーリングされます。回転速度と並進速度は異なる単位を持つためです。並進DOFの長さは1です。回転DOFの長さは、関連するジオメトリの平均長さに対応します。したがって、:ref:`sleep_tolerance <option-sleep_tolerance>` は[長さ/時間]の単位を持ちます。

  アイランドがスリープ状態になると、関連する速度は0に設定されます。したがって、アイランドがスリープ状態になるタイムステップでは、スリープ状態が :ref:`mj_forwardSkip` の呼び出しを使用して伝播される前に、すべての速度依存量を再計算する必要があります。

  アイランド内のツリーが「never」スリープポリシーを持っている場合、アイランド全体はスリープできません。

**スリープ状態で初期化:**
  ツリールートの :ref:`body/sleep<body-sleep>` 属性を「init」に設定すると、「スリープ状態で初期化」とマークされ、:ref:`mjData` 初期化中にスリープ状態になります。これは、多くのツリーがスリープ状態になるのを待つことが高価になる可能性がある大規模なモデルに役立ちます。

  接触を共有するツリーまたはそうでなければ同じアイランド内のツリーは一緒にスリープする必要があるため、アイランド内の一部のツリーがスリープ状態として初期化されている場合、それらすべてがそのようにマークされている必要があります。`このモデル <https://github.com/google-deepmind/mujoco/blob/main/test/engine/testdata/sleep/init_island_fail.xml>`__ には、この条件が満たされていないためコンパイルエラーが発生するXMLの例が含まれています。最後に、初期化スリープ機能はデフォルト構成でのみ利用可能であることに注意してください（キーフレームではありません。以下の議論を参照）。

.. _siSleepWaking:

ウェイキング
^^^^^^^^^^^^

ウェイキングはタイムステップの開始時に、:ref:`mj_kinematics` 中またはシミュレーションパイプラインの :ref:`位置ステージ <piStages>` 中にすぐに発生します。スリーピングアイランドは次の基準に従って起こされます。

- 関連する構成 ``qpos`` がユーザーによって変更された場合、たとえばシミュレーションが一時停止しているときに構成をインタラクティブに再配置する場合。
- 関連する速度 ``qvel`` または適用力 ``qfrc_applied`` または ``xfrc_applied`` がユーザーによって0以外の値に設定された場合、たとえばシミュレーション中にモデルをインタラクティブに摂動する場合。チェックは0へのバイト単位の比較によって実行されることに注意してください。したがって、関連する要素を浮動小数点値 ``-0.0`` に設定すると、アイランドが起こされますが、他の副作用はありません。
- 起きているツリーと接触した場合。接触によるウェイキングは、発生したタイムステップでのみ、衝突検出が *2回* 実行されます。これは、アイランド内およびアイランドと世界との間の接触を検出するために必要です。これらは、眠っていると見なされた最初の実行ではスキップされました。
- アクティブな等式制約または制限されたテンドンによって起きているツリーに接続されている場合。
- 異なるアイランドのスリーピングツリーに等式制約によって接続されている場合。これが発生するには、両方のツリーがスリープ状態になったときに等式が無効になっている必要があります。

上記の自動ウェイク基準は、スリーピングアイランドが起きているかのように動作するように設計されていますが、常にそうであるとは限りません。たとえば、床の上の自由ボディがスリープ状態になり、次に重力が逆転した場合、別の理由で起こされるまで、それらは所定の位置でスリープしたままになります。非物理性の最も極端な例は、スリープ状態で初期化されたアイランドです。これらは空中または深い衝突に配置できますが、起こされるまで移動しません。

.. _siSleepNotes:

注記
^^^^

.. admonition:: 新機能
   :class: warning

   スリーピングは新しい機能（2025年11月）であり、変更される可能性があり、潜在的なバグがある可能性があります。

**スリーピングアクチュエータ**
  :ref:`body/sleep <body-sleep>` ドキュメントで説明されているように、アクチュエータを持つツリーはデフォルトでスリープが許可されていませんが、これはユーザーがオーバーライドできます。スリープが許可されていない理由は、アクチュエータがスリープとしてマークされると、それを起こすために必要な計算が実行されなくなるためです。それが実行されたとしても（つまり、すべてのアクチュエータのスリープ状態に関係なく、アクチュエーション力が常に計算された場合）、この計算は加速度/力ステージで発生します。この時点ではツリーを起こすにはすでに遅すぎます。ウェイキングは位置ステージで発生する必要があるためです。したがって、アクチュエータを持つツリーがスリープを許可されている場合、ウェイキングは上記で説明したように、関連する速度または力に触れることによって手動で行う必要があります。

**スリーピングセンサー**
  ほとんどのセンサーについては、関連するオブジェクトがスリープしているときにそれらの値の計算をスキップし、それらのオブジェクトが最後に起きていたときに計算された値を報告できます。一部のセンサーは常に起きていますが、スリープを無効にしても、計算された値には影響しません。

  - :ref:`rangefinder<sensor-rangefinder>` センサーは常に起きています。それらが付属しているサイトのスリープ状態は、報告される値とは関係ありません。
  - :ref:`clock<sensor-clock>` センサーは常に起きています（関連するオブジェクトはありません）。
  - :ref:`user<sensor-user>` および :ref:`plugin<sensor-plugin>` センサーは常に起きています。

  一部のセンサーは常に起きていますが、スリープを無効にすると、計算された値に影響を与える可能性があります。これらは、接触の存在に明示的に依存するセンサーですが、最後に起きていたときに存在していた接触は、現在の値を決定するのに十分ではありません。

  - オブジェクト指定子を持たない :ref:`contact<sensor-contact>` センサー（すべての接触に一致）。
  - 唯一のオブジェクト指定子が静的である :ref:`contact<sensor-contact>` センサー。
  - :at:`site` 属性を使用する :ref:`contact<sensor-contact>` センサー。
  - 静的ボディに付属している :ref:`force<sensor-force>` または :ref:`torque<sensor-torque>` センサー（床の重量センサーなど）。

**暫定的な選択**
  一部の実装の選択は暫定的であり、変更される可能性があります。

  具体的な例は、:ref:`mjMINAWAKE<glNumeric>` の値をハードコードする決定であり、実行時オプションとしてユーザーに公開するのではなく。これは2つの理由で行われました。まず、私たちの実験では、この値を変更することは :ref:`sleep_tolerance<option-sleep_tolerance>` を変更することと同等であることがわかりました。これはより有用なノブです。次に、タイムステップの整数ではなく時間の単位でのスリープまでの時間セマンティクスを主張することもできます。これらの理由の1つまたは両方が無効であるという明確な証拠が得られるまで、単純な数値定数を選択しました。

**静的ボディ**
  キネマティックツリーをスリープできるようにするメインの最適化に加えて、スリープ機能には、静的ボディに関連する計算のスキップという別の関連する最適化も含まれています。これは、たとえばワールドボディまたはその静的な子に多数のジオムが含まれている場合に、姿勢が一度だけ計算される場合に貴重です。

  これは微妙な（可能性は低いですが）「落とし穴」につながります。シミュレーション中にスリーピングを有効にすることは許可されていますが、スリーピングは初期化時に有効にするか、少なくとも1つの :ref:`mj_step` の後に有効にする必要があります。すなわち：

  .. code-block:: C

     // this is OK:
     mjData* d = mj_makeData(m);            // sleeping is enabled at init time
     mj_step(m, d);
     ...

     // this is also OK:
     mjData* d = mj_makeData(m);            // sleeping is disabled at init time
     mj_step(m, d);
     ...
     m->opt.enableflags |= mjENABLE_SLEEP;  // enable sleeping after at least one step
     mj_step(m, d);

     // this is an error:
     mjData* d = mj_makeData(m);            // sleeping is disabled at init time
     m->opt.enableflags |= mjENABLE_SLEEP;  // enable sleeping
     mj_step(m, d);                         // undefined behavior, static elements not computed


**違反された仮定**
  スリーピングは、MuJoCoのコアに組み込まれているいくつかの仮定を破ります（スリーピングが無効になっている場合、これらは引き続き成立します）。

  *パイプラインステージ*：通常、速度関連の量は位置ステージの終了前に読み取られず、力関連の量は速度ステージの終了前に読み取られないことが保証されています。:ref:`mj_step1`/:ref:`mj_step2` 分割の中心にあるこの仮定は、:ref:`mj_kinematics` での ``qvel``、``qfrc_applied``、``xfrc_applied`` の読み取りによって違反されます。

  *コンパクトな状態*：スリープ状態は名目上 ``mjData.tree_asleep`` によって与えられますが、これは蜃気楼です。アイランドがスリープ状態になると、それに関連するmjData内の位置および速度依存量のサブセット全体が、「アイランドが起きるのを待っている」事前計算された潜在状態になります。このため、スリーピング要素を持つシミュレーションの状態を完全に保存および復元する唯一の方法は、mjData構造全体を :ref:`コピー<mj_copyData>` することです。これは、スリープ初期化がデフォルト構成でのみ利用可能で、キーフレームでは利用できない理由でもあります。:ref:`標準ツール<geState>` を使用した状態の保存とロードは依然として有効な操作ですが、スリーピングアイランドは暗黙的に起こされることに注意してください。


**RK4積分器**
  サブステップ内でのウェイキングの微妙さのため、RK4積分器は現在サポートされていません。

**潜在的なバグ**
  スリーピングは新しい機能（2025年11月）であり、潜在的なバグがある可能性があります。これらのバグは一般に2つのタイプになる可能性があります。

  - スキップできる量が代わりに再計算されます。このようなバグの唯一の観察可能な効果は、シミュレーションが可能な速度よりも遅くなることです。このタイプのバグは、詳細なプロファイリングでのみ診断できます。
  - 実際のバグ。うまくいけば、これらは有益な実行時エラーにつながるでしょう。開発チームにそのようなものを報告してください。


.. _siCoordinate:

座標フレームと変換
~~~~~~~~~~~~~~~~~~

MuJoCoで使用される複数の座標フレームがあります。トップレベルの区別は、関節座標と直交座標の間です。関節座標のベクトルからすべてのボディの直交位置と方向へのマッピングは順運動学と呼ばれ、物理パイプラインの最初のステップです。反対のマッピングは逆運動学と呼ばれますが、一意に定義されておらず、MuJoCoには実装されていません。接空間間のマッピング（つまり、関節速度と力から直交速度と力へ）は、ボディヤコビアンによって与えられることを思い出してください。

ここでは、座標フレームのさらなる微妙さと細分化を説明し、利用可能な変換関数を要約します。関節座標での唯一の複雑さは、位置ベクトル ``mjData.qpos`` がクォータニオンジョイントのために速度および加速度ベクトル ``mjData.qvel`` および ``mjData.qacc`` とは異なる次元を持つことです。関数 :ref:`mj_differentiatePos` は2つの関節位置ベクトルを「減算」し、速度ベクトルを返します。逆に、関数 :ref:`mj_integratePos` は位置ベクトルと速度ベクトルを取り、与えられた速度によって変位された新しい位置ベクトルを返します。

直交座標は、ローカル、グローバル、com基準の3つの異なる座標フレームを使用するため、より複雑です。ローカル座標は、mjModelで親ボディと子ボディ間の静的オフセット、およびボディとそれに付属するジオム、サイト、カメラ、ライト間の静的オフセットを表すために使用されます。これらの静的オフセットは、ジョイント変換に加えて適用されます。したがって、``mjModel.body_pos``、``mjModel.body_quat``、およびmjModelの他のすべての空間量はローカル座標で表現されます。順運動学の仕事は、キネマティックツリーに沿ってジョイント変換と静的オフセットを累積し、すべての位置と方向をグローバル座標で計算することです。「x」で始まるmjDataの量は、グローバル座標で表現されます。これらは ``mjData.xpos``、``mjData.geom_xpos`` などです。フレーム方向は通常3×3行列（xmat）として格納されますが、ボディの方向は単位クォータニオン ``mjData.xquat`` としても格納されます。このボディクォータニオンが与えられれば、ボディに付属する他のすべてのオブジェクトのクォータニオンは、クォータニオン乗算によって再構築できます。関数 :ref:`mj_local2Global` は、ローカルボディ座標からグローバル直交座標に変換します。

姿勢は、3D位置と単位クォータニオン方向のグループ化です。別個のデータ構造はありません。グループ化はロジックの観点からです。これは、空間内の位置と方向、つまり空間フレームを表します。OpenGLは4×4行列を使用して同じ情報を表現しますが、ここでは方向にクォータニオンを使用します。関数mju_mulPoseは2つの姿勢を乗算します。つまり、最初の姿勢を2番目の姿勢によって変換します（順序は重要です）。``mju_negPose`` は反対の姿勢を構築し、``mju_trnVecPose`` は姿勢によって3Dベクトルを変換し、姿勢を座標フレームと考える場合、ローカル座標からグローバル座標にマッピングします。方向部分のみを操作したい場合、類似のクォータニオンユーティリティ関数 :ref:`mju_mulQuat`、:ref:`mju_negQuat`、:ref:`mju_rotVecQuat` でそれを行うことができます。

最後に、com基準フレームがあります。これは、3D角速度または加速度またはトルクに続く3D線形速度または加速度または力を含む6D空間ベクトルを表すために使用されます。逆の順序に注意してください：並進に続く回転です。``mjData.cdof`` と ``mjData.cacc`` はこのようなベクトルの例です。名前は「c」で始まります。これらのベクトルは、多関節ダイナミクス計算で重要な役割を果たします。これの説明は私たちの範囲を超えています。Featherstoneの優れた `スライド <http://royfeatherstone.org/spatial>`__ をこの主題について参照してください。一般に、ユーザーはこのような量を直接扱うことを避けるべきです。代わりに、関数 :ref:`mj_objectVelocity`、:ref:`mj_objectAcceleration`、および低レベルの :ref:`mju_transformSpatial` を使用して、与えられたボディの線形および角速度、加速度、力を取得してください。それでも、興味のある読者のために、「c」量の最も異常な側面を要約します。所定の場所で回転しているボディを表現したいとします。0以外の角速度と0の線形速度を持つ空間速度が期待されるかもしれません。しかし、これは当てはまりません。回転は、座標フレームの中心を通る軸の周りで発生すると解釈されます。これはボディの外側にあります（キネマティックツリーの重心を使用します）。このような回転は、ボディを回転させるだけでなく、並進もします。したがって、空間ベクトルは、ボディ外軸の周りの回転の副作用を補償するために0以外の線形速度を持たなければなりません。mj_objectVelocityを呼び出すと、結果の6D量は、ボディの中心にありワールドと整列したフレームで表現されます。したがって、線形成分は期待どおりに0になります。この関数は、並進を回転の前に置きます。これは、ローカルおよびグローバル座標に対する私たちの規則です。
