.. _UI:

ユーザーインターフェース
------------------------

MuJoCoはネイティブのUIフレームワークを持っています。その使用方法は :ref:`simulate.cc <saSimulate>` ビューアで説明されています。このフレームワークは、更新とレンダリングの点で高速であり、開発者とユーザーの両方にとって使いやすく、クロスプラットフォームであり、ネイティブのMuJoCoレンダラーと統合されるように設計されています。これらの設計目標を達成するために、他のUIフレームワークで利用可能な多くの機能とカスタマイズオプションを省略し、代わりに効率性と自動化に焦点を当てています。



.. _uiDesign:

設計概要
~~~~~~~~~~~~~~~


ネイティブOpenGLレンダリング
  ヘルパーツールやライブラリは使用しません。代わりに、すべてのUI要素をOpenGLで直接レンダリングするためのCコードを提供します。複数のUIをサポートしており、各UIは表示されるウィンドウよりも縦に長くなることができる仮想矩形です。各UIの要素は、変更が必要な場合にのみ、最小限の更新を介して、補助OpenGLバッファにオフスクリーンでレンダリングされます。各画面更新時に、これらの補助バッファからウィンドウフレームバッファにピクセルをコピーし、ウィンドウがUIよりも小さい場合は垂直スクロールバーも実装します。このコピー操作はGPU上で行われ、非常に高速です。


プラットフォーム抽象化
  ソフトウェア設計には3つのレイヤーがあります。MuJoCoレンダラーと連携して動作するUI要素のOpenGLレンダリング（完全にクロスプラットフォーム）、 ``PlatformUIAdapter`` クラスで純粋仮想関数として定義されたウィンドウ、キーボード、マウスへのアクセスのための抽象関数、および派生クラス ``GlfwAdapter`` でのそれらの関数の実装です。 `GLFW <https://www.glfw.org/>`__ 自体はクロスプラットフォームです。それにもかかわらず、汎用機能とプラットフォーム固有機能を分離するために、この階層設計を採用しました。何らかの理由でGLFWを別の同様のフレームワークに置き換える必要がある場合、 ``GlfwAdapter`` のみを書き直す必要があります。


テーマと外観
  個々のUI要素は、外観やレイアウトの面でカスタマイズを許可しません。代わりに、色と間隔にテーマを使用し、すべてのUI要素を自動的に配置します。いくつかの組み込みテーマが提供されており、ユーザーはカスタムテーマを設計できますが、UI全体はすべての要素に対して単一のテーマを使用します。外観はミニマリストです。主に、テキストを含む色付き矩形です。ビットマップやその他のカスタム装飾はサポートされていません。UI要素タイプは、チェックボックス、ラジオボタングループ、選択リスト、スライダー、テキスト編集ボックス、静的テキスト、ボタン、セパレーターです。これらの要素は、展開および折りたたみができるセクションにグループ化されます。


レイアウトと矩形
  各UIは1つの仮想矩形であり、その幅はテーマによって決定され、その高さはセクション、各セクション内の項目、および各セクションの展開/折りたたみ状態によって決定されます。これらの仮想矩形のサイズと補助バッファは、UIが更新されるときに自動的に処理されます。各UIには画面上に表示される矩形があり、さらに3Dレンダリング、2Dフィギュア、およびカスタムOpenGLレンダリングのための他の矩形があります。これらすべての表示矩形は（ :ref:`mjuiState` に）保存され、マウスイベントをどこに向けるべきかを決定するために使用されます。矩形レイアウトは、ユーザーが提供するコールバックによって更新されます。


静的割り当てと作成
  UI要素に対応する多数のオブジェクトを割り当てて割り当て解除し、それらをリンクするのではなく、最大数のセクションと要素をサポートする静的割り当てを持つ単一のC構造体（タイプ :ref:`mjUI` ）を作成し、使用中の数を記録します。UI作成は、入力がC構造体（タイプ :ref:`mjuiDef` ）であるヘルパー関数によって簡素化されます。これは、基本的に各行が1つのUI要素を記述するテーブルです（以下を参照）。これにより、驚くほど少ないCコードで精巧なユーザーインターフェースを構築することが可能になります。プログラム的なUI作成も可能です。たとえば、MuJoCoモデルのジョイントに対応するスライダーでUIを設定する場合などです。


最小状態
  UIは、開発を簡素化するために、できるだけステートレスになるように設計されています。これには2つの側面があります。まず、UI要素内でユーザーデータを複製する代わりに、ユーザーデータへのポインタを格納します。たとえば、UIスライダーを作成し、そのデータポインタを ``mjData* d->qpos+7`` に設定する場合があります。このスライダーは、MuJoCoモデルのqposベクトルの7番目のスカラー成分を可視化および制御します。したがって、シミュレーションが更新されるとき、UIも更新することを忘れてはいけません。さらに、シミュレーションが更新されている間はUI編集を無効にする必要があります。しかし、利点は、UIが構築しやすくなり、ユーザーデータとUIの間に不一致が生じる危険性がないことです。次に、UI要素自体はほとんどステートレスです。代わりに、最小限のグローバル状態のセット、特にマウスとキーボードの状態、セクションの展開/折りたたみ、編集中のテキストボックスの内容（存在する場合）を追跡します。


自動有効化と無効化
  各UI項目は直接有効または無効状態に設定できますが、次のように自動化も提供します。各UI項目には整数カテゴリを割り当てることができます。次に、 :ref:`mjfItemEnable` コールバックが、プログラム固有の条件に基づいて、各カテゴリを有効にするか無効にするかを決定します。たとえば、MuJoCoモデルのジョイントの値を変更できるスライダーは、シミュレーション状態が更新されているときに無効にする必要があります。



.. _uiAPI:

メインAPI
~~~~~~~~~~~~~

以下のリンクをクリックして、メインUIデータ構造と関数の詳細なAPIリファレンスを参照してください。


**メインデータ構造:**

- :ref:`mjUI<mjUI>`: UI全体。
- :ref:`mjuiState<mjuiState>`: グローバルUI状態。
- :ref:`mjuiDef<mjuiDef>`: UI構築に使用される定義テーブルの1つのエントリ。


**メイン関数:**

- :ref:`mjui_update<mjui_update>`: メインUI更新関数。
- :ref:`mjui_render<mjui_render>`: UIをレンダリングします。
- :ref:`mjui_event<mjui_event>`: 低レベルイベントハンドラー。
- :ref:`mjui_add<mjui_add>`: UIを構築するために使用されるヘルパー関数。
