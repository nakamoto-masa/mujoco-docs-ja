.. _Visualization:

可視化
-------------

MuJoCoはネイティブの3Dビジュアライザーを持っています。その使用方法は :ref:`simulate.cc <saSimulate>` のコードサンプルと、よりシンプルな :ref:`basic.cc <saBasic>` のコードサンプルで説明されています。フル機能のレンダリングエンジンではありませんが、研究開発を促進する便利で効率的、かつ見栄えの良いビジュアライザーです。シミュレーション状態だけでなく、接触点や力、等価慣性ボックス、凸包、キネマティックツリー、制約違反、空間フレーム、テキストラベルなどの装飾要素もレンダリングします。これらは物理シミュレーションへの洞察を提供し、モデルの微調整に役立ちます。

ビジュアライザーはシミュレーターと緊密に統合されており、 :ref:`record.cc <saRecord>` のコードサンプルで説明されているように、オンスクリーンとオフスクリーンの両方のレンダリングをサポートしています。これにより、特にクラウド環境において、合成コンピュータビジョンや機械学習アプリケーションに適しています。MuJoCoバージョン1.40以降では、VR統合も利用可能であり、Oculus RiftやHTC Viveなどの新しいヘッドマウントディスプレイを活用するアプリケーションを促進します。

MuJoCoにおける可視化は2段階のプロセスです。

抽象的可視化とインタラクション
   このステージでは、 :ref:`mjvScene` データ構造に、3Dレンダリングを生成するために必要な幾何オブジェクト、ライト、カメラ、その他すべてのリストを設定します。また、ユーザーインタラクションのための抽象的なキーボードとマウスフックも提供します。関連するデータ構造と関数名には ``mjv`` の接頭辞が付いています。
OpenGLレンダリング
   このステージでは、抽象的可視化ステージで設定されたmjvSceneデータ構造を受け取り、それをレンダリングします。また、基本的な2D描画とフレームバッファアクセスも提供するため、ほとんどのアプリケーションはOpenGLを直接呼び出す必要がありません。関連するデータ構造と関数名には ``mjr`` の接頭辞が付いています。

この分離にはいくつかの理由があります。まず、2つのステージは概念的に異なっており、それらを分離することは良いソフトウェア設計です。次に、それらは内部的にも追加ライブラリの面でも異なる依存関係を持っています。特に、抽象的可視化はグラフィックスライブラリを必要としません。第三に、別のレンダリングエンジンをMuJoCoと統合したいユーザーは、ネイティブのOpenGLレンダラーをバイパスしながらも、抽象的ビジュアライザーを活用できます。

以下は、シミュレーションとレンダリングの両方を行うMuJoCoアプリケーションの構造を示すCコードと疑似コードの混合です。これは :ref:`basic.cc <saBasic>` のコードサンプルの短縮版です。具体性のため、GLFWを使用することを想定していますが、GLUTやその派生物などの別のウィンドウライブラリに置き換えることもできます。

.. code-block:: C

   // MuJoCo data structures
   mjModel* m = NULL;                  // MuJoCo model
   mjData* d = NULL;                   // MuJoCo data
   mjvCamera cam;                      // abstract camera
   mjvOption opt;                      // visualization options
   mjvScene scn;                       // abstract scene
   mjrContext con;                     // custom GPU context

   // ... load model and data

   // init GLFW, create window, make OpenGL context current, request v-sync
   glfwInit();
   GLFWwindow* window = glfwCreateWindow(1200, 900, "Demo", NULL, NULL);
   glfwMakeContextCurrent(window);
   glfwSwapInterval(1);

   // initialize visualization data structures
   mjv_defaultCamera(&cam);
   mjv_defaultPerturb(&pert);
   mjv_defaultOption(&opt);
   mjr_defaultContext(&con);

   // create scene and context
   mjv_makeScene(m, &scn, 1000);
   mjr_makeContext(m, &con, mjFONTSCALE_100);

   // ... install GLFW keyboard and mouse callbacks

   // run main loop, target real-time simulation and 60 fps rendering
   while( !glfwWindowShouldClose(window) ) {
     // advance interactive simulation for 1/60 sec
     //  Assuming MuJoCo can simulate faster than real-time, which it usually can,
     //  this loop will finish on time for the next frame to be rendered at 60 fps.
     //  Otherwise add a cpu timer and exit this loop when it is time to render.
     mjtNum simstart = d->time;
     while( d->time - simstart < 1.0/60.0 )
         mj_step(m, d);

     // get framebuffer viewport
     mjrRect viewport = {0, 0, 0, 0};
     glfwGetFramebufferSize(window, &viewport.width, &viewport.height);

     // update scene and render
     mjv_updateScene(m, d, &opt, NULL, &cam, mjCAT_ALL, &scn);
     mjr_render(viewport, &scn, &con);

     // swap OpenGL buffers (blocking call due to v-sync)
     glfwSwapBuffers(window);

     // process pending GUI events, call GLFW callbacks
     glfwPollEvents();
   }

   // close GLFW, free visualization storage
   glfwTerminate();
   mjv_freeScene(&scn);
   mjr_freeContext(&con);

   // ... free MuJoCo model and data

.. _Abstract:

抽象的可視化とインタラクション
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

このステージでは、 :ref:`mjvScene` データ構造に、3Dレンダリングを生成するために必要な幾何オブジェクト、ライト、カメラ、その他すべてのリストを設定します。また、ユーザーインタラクションのための抽象的なキーボードとマウスフックも提供します。

.. _viCamera:

カメラ
'''''''

カメラオブジェクトには2つのタイプがあります。スタンドアロンのデータ構造 :ref:`mjvCamera` で表現される抽象的カメラと、mjvSceneに埋め込まれたデータ構造 :ref:`mjvGLCamera` で表現される低レベルOpenGLカメラです。抽象的カメラが存在する場合、シーン更新時に自動的にOpenGLカメラパラメータを計算し、それがOpenGLレンダラーによって使用されます。あるいは、ユーザーは抽象的カメラメカニズムをバイパスして、以下のバーチャルリアリティのセクションで説明されているように、OpenGLカメラパラメータを直接設定することもできます。

抽象的カメラは、mjvCamera.typeによって決定される3つの異なるカメラタイプを表現できます。可能な設定は列挙型mjtCameraによって定義されます。

mjCAMERA_FREE
   これは最も一般的に使用される抽象的カメラです。マウスで自由に動かすことができます。注視点、注視点までの距離、方位角、仰角があり、視線周りのツイストは許可されていません。関数 :ref:`mjv_moveCamera` は、これらすべてのカメラプロパティをマウスで対話的に制御するためのマウスフックです。 :ref:`simulate.cc <saSimulate>` が最初に起動するとき、フリーカメラを使用します。
mjCAMERA_TRACKING
   これはフリーカメラに似ていますが、注視点はもはや自由パラメータではなく、mjvCamera.trackbodyidで指定されたMuJoCoボディに結合されます。各更新時に、注視点は指定されたボディをルートとするキネマティックサブツリーの重心に設定されます。また、スムーズなカメラモーションを生成するフィルタリングもあります。距離、方位角、仰角はユーザーによって制御され、自動的には変更されません。これは、カメラを回さずにボディが移動するのを追跡するのに便利です。 :ref:`simulate.cc <saSimulate>` でフリーカメラからトラッキングカメラに切り替えるには、Ctrlキーを押しながら対象のボディを右ダブルクリックします。Escキーを押すとフリーカメラに戻ります。
mjCAMERA_FIXED
   これは、モデルで明示的に定義されたカメラを指し、ビジュアライザーにのみ存在し、モデルでは定義されていないフリーカメラやトラッキングカメラとは異なります。モデルカメラのIDはmjvCamera.fixedcamidで指定されます。このカメラは、ビジュアライザーがその姿勢やその他のパラメータを変更できないという意味で固定されています。ただし、シミュレーターは各タイムステップでカメラの姿勢を計算し、カメラが移動するボディに取り付けられているか、トラッキングモードまたはターゲティングモードにある場合は移動します。
mjCAMERA_USER
   これは、更新時に抽象的カメラが無視され、低レベルOpenGLカメラが変更されないことを意味します。これは、以下で説明する更新関数でmjvCameraにNULLポインタを渡すこと、つまり抽象的カメラをまったく指定しないことと同等です。

低レベルのmjvGLCameraは、実際のレンダリングを決定するものです。mjvSceneには2つのそのようなカメラが埋め込まれており、それぞれが各眼用です。各カメラには位置、前方向、上方向があります。前方向はカメラフレームの負のZ軸に対応し、上方向は正のY軸に対応します。OpenGLの意味での錐台もありますが、左右の錐台エッジの平均を保存し、レンダリング時にビューポートのアスペクト比から実際のエッジを計算します（1:1ピクセルアスペクト比を仮定）。2つのカメラ位置間の距離は、瞳孔間距離（ipd）に対応します。低レベルカメラパラメータが抽象的カメラから自動的に計算される場合、ipdと垂直視野角（fovy）は、フリーカメラとトラッキングカメラの場合は ``mjModel.vis.global.ipd`` / ``fovy`` から、モデルで定義されたカメラの場合は ``mjModel.cam_ipd/fovy`` から取得されます。mjvScene.stereoで決定されるように、ステレオスコピックモードが有効でない場合、2つの眼のカメラデータはレンダリング時に内部的に平均化されます。

.. _viSelect:

選択
'''''''''

多くのアプリケーションでは、点をクリックし、その点/ピクセルが属する3Dオブジェクトを決定する必要があります。これは :ref:`ray collisions <Raycollisions>` を使用する関数 :ref:`mjv_select` で行われます。レイ衝突機能はエンジンレベルであり、ビジュアライザーに依存しません（実際、可視化とは独立して :ref:`rangefinder <sensor-rangefinder>` センサーをシミュレートするためにも使用されます）が、select関数はカメラとビューポートに関する情報が必要なため、ビジュアライザーに実装されています。

関数mjv_selectは、指定されたウィンドウ座標にあるジオムのインデックスを返すか、その座標にジオムがない場合は-1を返します。3D位置も返されます。この関数の使用例については、コードサンプル :ref:`simulate.cc <saSimulate>` を参照してください。内部的には、mjv_selectはエンジンレベルの関数 :ref:`mj_ray` を呼び出し、それがジオムごとの関数 :ref:`mj_rayMesh` 、 :ref:`mj_rayHfield` 、 :ref:`mju_rayGeom` を呼び出します。ユーザーは、これらの関数を直接呼び出すことでカスタム選択メカニズムを実装できます。例えば、VRアプリケーションでは、オブジェクトを選択できる「レーザーポインター」として手持ちコントローラーを使用することが理にかなっています。

.. _viPerturb:

摂動
'''''''''''''

対話的摂動は、モデルダイナミクスを探索したり、クローズドループ制御システムを調査したりする上で非常に有用であることが証明されています。ユーザーは、 ``mjData.qfrc_applied`` または ``mjData.xfrc_applied`` を適切な力（それぞれ一般化座標と直交座標）に設定することで、任意の摂動メカニズムを自由に実装できます。

MuJoCoバージョン1.40より前は、ユーザーコードは摂動を実装するためにオブジェクトのコレクションを維持する必要がありました。これらのオブジェクトはすべて、データ構造 :ref:`mjvPerturb` にグループ化されています。その使用方法は :ref:`simulate.cc <saSimulate>` で説明されています。アイデアは、対象のMuJoCoボディを選択し、そのボディの参照姿勢（つまり、3D位置とクォータニオンの向き）を提供することです。これらはmjPerturb.refpos/quatに格納されます。関数 :ref:`mjv_movePerturb` は、マウスで参照姿勢を制御するためのマウスフックです。関数 :ref:`mjv_initPerturb` は、摂動開始時に参照姿勢を選択されたボディの姿勢と等しく設定するために使用され、ジャンプを避けます。

この摂動オブジェクトは、選択されたボディを直接移動させる（シミュレーションが一時停止されているとき、または選択されたボディがモーキャップボディであるとき）、またはボディに力とトルクを適用するために使用できます。これは、それぞれ関数 :ref:`mjv_applyPerturbPose` と :ref:`mjv_applyPerturbForce` で行われます。後者の関数は、選択されたボディの ``mjData.xfrc_applied`` に外部摂動力を書き込みます。ただし、残りのボディの ``mjData.xfrc_applied`` はクリアしないため、選択されたボディが変更され、前のタイムステップから摂動力が残っている場合に備えて、ユーザーコードでクリアすることをお勧めします。摂動を適用できるデバイスが複数ある場合、またはユーザーコードが他のソースから摂動を追加する必要がある場合、ユーザーは必要なロジックを実装して、 ``mjData.xfrc_applied`` に望ましい摂動のみが存在し、古い摂動がクリアされるようにする必要があります。

シミュレーションに影響を与えることに加えて、摂動オブジェクトは抽象的ビジュアライザーによって認識され、レンダリングできます。これは、位置の差を示す視覚的な文字列と、選択されたボディの参照方向を示す回転する立方体を追加することで行われます。摂動力自体も、 :ref:`mjvOption` の対応する可視化フラグが有効になっているときにレンダリングできます。

.. _viUpdate:

シーン更新
''''''''''''

最後に、上記のすべての要素をまとめて、mjvSceneがOpenGLレンダリングステージに渡される前にどのように更新されるかを説明します。これは、各フレームで関数 :ref:`mjv_updateScene` を1回呼び出すことで実行できます。mjvCameraとmjvPerturbはこの関数の引数であり、NULLポインタにすることもできます。その場合、対応する機能は無効になります。VRアプリケーションでは、mjvScene.camera[n]のパラメータ（n=0,1）も各フレームで設定する必要があります。これはmjv_updateSceneの外でユーザーコードによって行われます。関数mjv_updateSceneは、mjModelとmjDataを調べ、レンダリングする必要があるすべてのジオムを（指定された可視化オプションに従って）構築し、 :ref:`mjvGeom` オブジェクトで配列mjvScene.geomを設定します。mjvGeomは抽象的ジオムであり、mjModelとmjDataのシミュレーションジオムとは1対1で対応していないことに注意してください。特に、mjvGeomには、ジオムの姿勢、スケール、形状（プリミティブまたはmjModelのメッシュインデックス）、マテリアルプロパティ、テクスチャ（mjModelのインデックス）、ラベリング、およびレンダリング方法を指定するために必要なその他すべてが含まれています。mjvSceneには、モデルからコピーされた最大8つのOpenGLライトと、存在する場合はライト位置0にあるヘッドライトも含まれています。

上記の手順が最も一般的なアプローチであり、各フレームでシーン全体を更新します。さらに、より細かい制御のために2つの関数を提供します。 :ref:`mjv_updateCamera` はカメラのみを更新します（つまり、抽象的mjvCameraを低レベルmjvGLCameraにマップします）が、ジオムやライトには触れません。これは、ユーザーがカメラを急速に動かしているがシミュレーション状態が変更されていない場合に便利です。その場合、ジオムとライトのリストを再作成する意味はありません。

より高度なレンダリング効果は、抽象的ジオムのリストを操作することで実現できます。例えば、ユーザーはリストの最後にカスタムジオムを追加できます。時には、現在の状態だけでなく、一連のシミュレーション状態（つまり軌跡）をレンダリングすることが望ましい場合があります。この目的のために、現在のシミュレーション状態に対応するジオムをmjvScene内の既存のリストに追加する関数 :ref:`mjv_addGeoms` を提供しています。ライティングは加算的であり、ライトが多すぎるとシーンが明るくなりすぎるため、ライトのリストは変更しません。重要なのは、ユーザーが列挙型mjtCatBitのビットマスクを介して、どのジオムカテゴリを追加するかを選択できることです。

mjCAT_STATIC
   これは、ワールドボディ（ボディID 0を持つ）に属するMuJoCoジオムとサイトを選択します。
mjCAT_DYNAMIC
   これは、ワールドボディ以外のボディに属するMuJoCoジオムとサイトを選択します。
mjCAT_DECOR
   これは、力の矢印、自動生成されたスケルトン、等価慣性ボックス、および抽象的ビジュアライザーによって追加されたその他の要素（モデルで定義されたMuJoCoジオムとサイトに対応しないもの）などの装飾要素を選択します。
mjCAT_ALL
   これは上記のすべてのカテゴリを選択します。

メイン更新関数mjv_updateSceneは通常mjCAT_ALLで呼び出されます。これはジオムリストをクリアし、mjv_addGeomを呼び出して、現在のモデル状態のジオムのみを追加します。軌跡をレンダリングする場合は、視覚的な混乱を避けるように注意する必要があります。そのため、フレームの1つをmjCAT_ALL（通常はユースケースに応じて最初または最後）でレンダリングし、他のすべてのフレームをmjCAT_DYNAMICでレンダリングすることが理にかなっています。静的/ワールドオブジェクトは移動しないため、各フレームでそれらをレンダリングするとGPUが遅くなり、視覚的なエイリアシングが発生するだけです。装飾要素に関しては、すべてをレンダリングしたい状況があるかもしれません。例えば、時間経過に伴う接触力の進化を可視化する場合などです。要約すると、mjvSceneの構築方法には十分な柔軟性があります。主要なユースケースのための自動化を提供していますが、ユーザーは必要に応じてプログラム的な変更を加えることもできます。

.. _viVR:

バーチャルリアリティ
''''''''''''''''''''''''

デスクトップアプリケーションでは、直感的なマウス制御を可能にする抽象的mjvCameraを使用し、それをレンダリングに使用されるmjvGLCameraに自動的にマップすることが便利です。VRアプリケーションでは状況は大きく異なります。その場合、ユーザーの頭/眼と投影面が追跡されており、したがって部屋に物理的な存在感があります。ユーザーが（マウスまたは他の入力デバイスで）動かすことができるものがあるとすれば、それは部屋に対するモデルの位置、方向、スケールです。これはモデル変換と呼ばれ、mjvSceneで表現されます。関数 :ref:`mjv_moveModel` は、この変換を制御するためのマウスフックです。更新時に抽象的mjvCameraを使用すると、実際のパラメータをクリアするのではなく、フラグmjvScene.enabletransform = 0を設定することで、モデル変換が自動的に無効になります。このようにして、ユーザーはモデル変換パラメータを失うことなく、VRモードとデスクトップカメラモードを切り替えることができます。

2つの空間、つまりモデル空間とルーム空間を導入したので、それらの間をマッピングし、どの空間量がどの空間フレームに対して定義されているかを明確にする必要があります。シミュレーターによってアクセス可能なすべてのものは、モデル空間に存在します。ルーム空間はビジュアライザーによってのみアクセス可能です。ルーム空間で定義される唯一の量はmjvGLCameraパラメータです。関数 :ref:`mjv_room2model` 、 :ref:`mjv_model2room` 、 :ref:`mjv_cameraInModel` 、 :ref:`mjv_cameraInRoom` は、必要な変換を実行し、VRアプリケーションに必要です。

次に、VRアプリケーションでヘッドトラッキングをMuJoCoのビジュアライザーに接続する手順を概説します。これを示すコードサンプルは間もなく投稿されます。トラッキングデバイスが、リアルタイムで2つの眼の位置（通常、頭の位置と方向を追跡し、ユーザー固有のipdを仮定することで生成される）、および前方カメラ方向と上方カメラ方向を提供すると仮定します。これらのデータを2つのmjvGLCameraに直接コピーします。これらはmjvScene.camera[n]にあり、n=0が左眼、n=1が右眼です。前方向は投影面に対して法線であり、必ずしも視線方向と整列しているわけではないことに注意してください。実際、視線方向は不明です（視線追跡デバイスもない限り）し、レンダリングに影響しません。

mjvGLCamera錐台も設定する必要があります。これがどのように行われるかは、VRシステムの性質によって異なります。Oculus RiftやHTC Viveなどのヘッドマウントディスプレイの場合、投影面は頭と一緒に移動するため、錐台は固定されており、SDKによって提供されます。この場合、単にそれをmjvGLCameraにコピーし、左右のエッジの平均を取ってfrustum_centerパラメータを計算します。あるいは、投影面は部屋内で静止しているモニターである可能性があります（zSpaceシステムの場合）。このようなシステムでは、モニターと眼/カメラの間の空間関係を考慮して、各フレームで錐台を計算する必要があります。これは、モニターも追跡されていることを前提としています。ここでの自然なアプローチは、モニターをルーム座標フレームの中心として定義し、それに対して頭を追跡することです。zSpaceシステムでは、これはモーションキャプチャカメラをモニター自体に埋め込むことで行われます。

頭を追跡し、正しい透視投影を使用することとは別に、VRアプリケーションには通常、シミュレートされたオブジェクトの動きにマップする必要がある、またはシミュレーションと他の方法で対話する必要がある手持ち空間コントローラーが含まれます。これらのコントローラーの姿勢は、ルーム空間でモーションキャプチャシステムによって記録されます。提供する変換関数（特にmjv_room2model）を使用して、モデル空間にマップできます。コントローラーの姿勢をモデル空間で取得したら、MuJoCoモーキャップボディ（モデルで定義）を使用して、コントローラーをシミュレーションに挿入できます。これがまさに、モーキャップボディがMuJoCoに導入された理由です。このようなボディは、物理の観点からは固定として扱われますが、ユーザーは各シミュレーションステップでプログラム的に移動させることが期待されています。接触を通じて、またはより良い方法として、通常のボディへのソフト等式制約を通じてシミュレーションと対話できます。後者のアプローチは、フォーラムで利用可能なMPLモデルで説明されています。これは効果的な動的フィルタリングを提供し、無限に重いかのように振る舞うボディ（固定ボディがそうである）を含む接触を避けます。モーキャップボディの時間変化する位置と方向は、mjModelに格納するのではなく、 ``mjData.mocap_pos/quat`` に格納されることに注意してください。これは、mjModelが一定のままであることが想定されているためです。mjModelに格納された固定モーキャップボディ姿勢は、初期化とリセット時にのみ使用されます。その時点では、ユーザーコードはまだmjData.mocap_pos/quatを更新する機会がありません。

.. _Rendering:

OpenGLレンダリング
~~~~~~~~~~~~~~~~~~~~~~~~~~

このステージでは、抽象的可視化ステージで設定されたmjvSceneデータ構造を受け取り、それをレンダリングします。また、基本的な2D描画とフレームバッファアクセスも提供するため、ほとんどのアプリケーションはOpenGLを直接呼び出す必要がありません。

.. _reContext:

コンテキストとGPUリソース
'''''''''''''''''''''''''

レンダリングプロセスの最初のステップは、モデル固有のGPUコンテキスト :ref:`mjrContext` を作成することです。これは、まず関数 :ref:`mjr_defaultContext` でデータ構造をクリアし、次に関数 :ref:`mjr_makeContext` を呼び出すことで行われます。これは既に前述しました。関連するコードは次のとおりです。

.. code-block:: C

   mjModel* m;
   mjrContext con;

   // clear mjrContext only once before first use
   mjr_defaultContext(&con);

   // create window with OpenGL context, make it current
   GLFWwindow* window = glfwCreateWindow(1200, 900, "Demo", NULL, NULL);
   glfwMakeContextCurrent(window);

   // ... load MuJoCo model

   // make model-specific mjrContext
   mjr_makeContext(m, &con, mjFONTSCALE_100);

   // ... load another MuJoCo model

   // make mjrContext for new model (old context freed automatically)
   mjr_makeContext(m, &con, mjFONTSCALE_100);

   // free context when done
   mjr_freeContext(&con);

mjrContextはOpenGLコンテキストとどのように関連していますか？OpenGLコンテキストは、アプリケーションがビデオドライバーと通信し、レンダリングコマンドを送信できるようにするものです。mjr_makeContextが呼び出される前に、呼び出しスレッドで存在し、カレントである必要があります。上記のように、GLFWおよび関連ライブラリが必要な関数を提供します。

mjrContextはMuJoCo固有です。作成後、mjr_makeContextによってGPUにアップロードされたすべてのリソースへの参照（OpenGLでは「名前」と呼ばれる）が含まれています。これには、メッシュやテクスチャなどのモデル固有のリソース、指定されたフォントスケールのフォントビットマップ、シャドウマッピングとオフスクリーンレンダリングのためのフレームバッファオブジェクト、および関連するレンダーバッファなどの汎用リソースが含まれます。また、 ``mjModel.vis`` からコピーされたOpenGL関連オプション、自動的に検出されるデフォルトウィンドウフレームバッファの機能、および現在アクティブなレンダリング用のバッファも含まれています。以下の :ref:`buffers <reBuffer>` を参照してください。MuJoCoは固定機能OpenGLを使用していますが、即時モードレンダリングを避け、代わりにすべてのリソースを事前にGPUにアップロードすることに注意してください。これにより、最新のシェーダーと同じくらい効率的になり、場合によってはより効率的になります。なぜなら、固定機能OpenGLは現在、ビデオドライバー開発者によって書かれ、広範囲に調整された内部シェーダーを介して実装されているからです。

mjrContextのほとんどのフィールドは、mjr_makeContextの呼び出し後に一定のままです。唯一の例外はmjrContext.currentBufferで、アクティブなバッファが変更されるたびに変更されます。一部のGPUリソースも、ユーザーが関数 :ref:`mjr_uploadTexture` 、 :ref:`mjr_uploadMesh` 、 :ref:`mjr_uploadHField` で変更されたリソースをアップロードできるため、変更される可能性があります。これは、ビデオフィードをレンダリングに挿入したり、地形マップを変調したりするなどの動的効果を実現するために使用できます。このような変更は、GPU上に存在するリソースに影響しますが、それらのOpenGL名は再利用されるため、変更は実際にはmjrContextには見えません。

ユーザーは **決して** mjrContextを直接変更してはいけません。MuJoCoのレンダラーは、mjrContextを管理できるのは自分だけであると仮定しています。実際、この種のオブジェクトは通常不透明であり、その内部構造はユーザーに公開されません。MuJoCoはオープンな設計をしているため、また、ユーザーがMuJoCoのレンダラーと独自のOpenGLコードをインターリーブしたい場合があり、その場合、mjrContextの一部のフィールドへの読み取りアクセスが必要になる可能性があるため、それを公開しています。例えば、VRアプリケーションでは、ユーザーはMuJoCoのオフスクリーンバッファからVR SDKによって提供されるテクスチャにブリットする必要があります。

別のMuJoCoモデルがロードされる場合、mjr_makeContextを再度呼び出す必要があります。また、初期化と機能フラグを保持しながらGPUリソースを解放する関数 :ref:`mjr_freeContext` もあります。この関数は、アプリケーションが終了しようとしているときに呼び出す必要があります。mjr_makeContext内から自動的に呼び出されるため、別のモデルがロードされるときに直接呼び出す必要はありませんが、そうすることはエラーではありません。関数mjr_defaultContextは、データ構造mjrContextに割り当てられたメモリをクリアするために、レンダリングが開始される前に1回呼び出す必要があります。mjr_makeContextを呼び出した後に呼び出すと、GPUリソースが割り当てられたという記録を消去せずに解放されてしまうので、それはしないでください。

.. _reBuffer:

レンダリング用バッファ
''''''''''''''''''''''''''

デフォルトのウィンドウフレームバッファに加えて、OpenGLはカスタムレンダリング用に無制限のフレームバッファオブジェクト（FBO）をサポートできます。MuJoCoでは、デフォルトのウィンドウフレームバッファと1つのオフスクリーンフレームバッファの2つのフレームバッファに対する体系的なサポートを提供します。これらは、列挙型 :ref:`mjtFramebuffer` の定数、つまりmjFB_WINDOWとmjFB_OFFSCREENによって参照されます。常に、これら2つのバッファのいずれかがMuJoCoレンダリングの目的でアクティブであり、すべての後続のコマンドがそれに向けられます。mjrContextで参照される2つの追加のフレームバッファオブジェクトがあり、シャドウマッピングとマルチサンプルバッファの解決に必要ですが、これらは内部的に使用され、ユーザーは直接アクセスしようとしないでください。

アクティブバッファは関数 :ref:`mjr_setBuffer` で設定されます。これはmjrContext.activeBufferの値を設定し、それに応じてOpenGL状態を構成します。mjr_makeContextが呼び出されると、内部的にmjFB_WINDOWを引数としてmjr_setBufferを呼び出すため、レンダリングはデフォルトでウィンドウバッファで開始されます。指定されたバッファが存在しない場合、mjr_setBufferは自動的に他のバッファにデフォルト設定されます（Linuxでヘッドレスレンダリングを使用する場合、ウィンドウフレームバッファが存在しない可能性があることに注意してください）。

OpenGLの観点から、ウィンドウフレームバッファとオフスクリーンフレームバッファの間には重要な違いがあり、これらの違いはMuJoCoユーザーがレンダラーとどのように対話するかに影響します。ウィンドウフレームバッファはOpenGLではなく、オペレーティングシステムによって作成および管理されます。その結果、解像度、ダブルバッファリング、クアッドバッファステレオ、マルチサンプル、v-syncなどのプロパティはOpenGLの外部で設定されます。これは、コードサンプルではGLFW呼び出しによって行われます。OpenGLができることは、これらのプロパティを検出することだけです。これをmjr_makeContextで行い、結果をmjrContextのさまざまなウィンドウ機能フィールドに記録します。このため、このようなプロパティはMuJoCoモデルの一部ではありません。それらはセッション/ソフトウェア固有であり、モデル固有ではありません。対照的に、オフスクリーンフレームバッファは完全にOpenGLによって管理されるため、 ``mjModel.vis`` で指定された解像度とマルチサンプルプロパティを持つバッファを作成できます。

ユーザーは2つのバッファのピクセルに直接アクセスできます。これは、関数 :ref:`mjr_readPixels` 、 :ref:`mjr_drawPixels` 、 :ref:`mjr_blitBuffer` で行われます。読み取り/描画は、アクティブなバッファとCPUの間でピクセルを転送します。ブリットは、GPU上の2つのバッファ間でピクセルを転送するため、はるかに高速です。方向は、アクティブなバッファからアクティブでないバッファへです。mjr_blitBufferには、異なるサイズを持つことができるソースビューポートと宛先ビューポートがあり、プロセス中に画像をスケーリングできることに注意してください。

.. _reDraw:

ピクセルの描画
''''''''''''''

メインレンダリング関数は :ref:`mjr_render` です。その引数は、レンダリング用の矩形ビューポート、抽象的ビジュアライザーによって設定されたmjvScene、およびmjr_makeContextによって作成されたmjrContextです。ビューポートは、カスタム効果のために、アクティブなバッファ全体またはその一部にすることができます。バッファ全体に対応するビューポートは、関数 :ref:`mjr_maxViewport` で取得できます。オフスクリーンバッファのサイズは変更されませんが、ウィンドウバッファのサイズは、ユーザーがウィンドウのサイズを変更したり最大化したりするたびに変更されることに注意してください。したがって、ユーザーコードは固定ビューポートサイズを想定しないでください。コードサンプル :ref:`simulate.cc <saSimulate>` では、ウィンドウサイズが変更されるたびにトリガーされるコールバックを使用していますが、 :ref:`basic.cc <saBasic>` では、レンダリングするたびにウィンドウサイズをチェックしています。特定のスケーリングされたディスプレイ（OSXでのみのようです）では、ウィンドウサイズとフレームバッファサイズが異なる場合があります。したがって、GLFW関数でサイズを取得する場合は、glfwGetWindowSizeではなくglfwGetFramebuferSizeを使用してください。一方、マウス座標はフレームバッファ単位ではなくウィンドウ単位でオペレーティングシステムによって返されます。したがって、前述のマウスインタラクション関数は、マウス変位データを正規化するために必要なウィンドウの高さを取得するためにglfwGetWindowSizeを使用する必要があります。

mjr_renderは、リストmjvScene.geomからすべてのmjvGeomをレンダリングします。抽象的可視化オプションmjvOptionはここではもはや関係ありません。それらはmjv_updateSceneによって使用され、どのジオムを追加するかを決定します。mjr_renderに関する限り、これらのオプションはすでに組み込まれています。ただし、mjvSceneに埋め込まれた別のレンダリングオプションセットがあり、これらはOpenGLレンダリングプロセスに影響します。配列mjvScene.flagsには、列挙型 :ref:`mjtRndFlag` でインデックス付けされたフラグが含まれており、ワイヤフレームモード、シャドウ、リフレクション、スカイボックス、フォグを有効および無効にするオプションが含まれています。シャドウとリフレクションには、追加のレンダリングパスが含まれます。MuJoCoのレンダラーは非常に効率的ですが、モデルの複雑さと利用可能なGPUによっては、場合によってはこれらの効果の1つまたは両方を無効にする必要があるかもしれません。

パラメータmjvScene.stereoはステレオモードを決定します。可能な値は列挙型 :ref:`mjtStereo` によって与えられ、次のとおりです。

mjSTEREO_NONE
   ステレオレンダリングは無効です。mjvSceneの2つのOpenGLカメラの平均が使用されます。レンダラーは常に両方のカメラが適切に定義されていることを期待していることに注意してください。ステレオが使用されていない場合でもです。
mjSTEREO_QUADBUFFERED
   このモードは、アクティブなバッファがウィンドウであり、ウィンドウがクアッドバッファOpenGLをサポートしている場合にのみ機能します。これにはプロフェッショナルなビデオカードが必要です。コードサンプル :ref:`simulate.cc <saSimulate>` は、そのようなウィンドウを開こうとします。このモードでは、MuJoCoのレンダラーは、ウィンドウがダブルバッファの場合はGL_BACK_LEFTおよびGL_BACK_RIGHTバッファを使用して2つのビュー（mjvSceneの2つのOpenGLカメラによって決定される）をレンダリングし、それ以外の場合はGL_FRONT_LEFTおよびGL_FRONT_RIGHTを使用します。ウィンドウがクアッドバッファOpenGLをサポートしていない場合、またはアクティブなバッファがオフスクリーンバッファの場合、レンダラーは次に説明するサイドバイサイドモードに戻ります。
mjSTEREO_SIDEBYSIDE
   このステレオモードは特別なハードウェアを必要とせず、常に利用可能です。mjr_renderに与えられるビューポートは、サイドバイサイドに2つの等しい矩形に分割されます。左ビューは左側にレンダリングされ、右ビューは右側にレンダリングされます。原則として、ユーザーは目を交差させて通常のモニターでステレオを見ることができますが、ここでの目標はステレオスコピックデバイスで表示することです。ほとんどのヘッドマウントディスプレイはこのステレオモードをサポートしています。

メインのmjr_render関数に加えて、画像を「装飾」するためのいくつかの関数を提供します。これらは2Dレンダリング関数であり、 :ref:`mjr_overlay` 、 :ref:`mjr_text` 、 :ref:`mjr_rectangle` 、 :ref:`mjr_figure` が含まれます。ユーザーは独自のOpenGLコードで追加の装飾を描画できます。これはmjr_renderの後に行う必要があります。なぜなら、mjr_renderはビューポートをクリアするからです。

また、GPUとの明示的な同期とOpenGLエラーチェックのための関数 :ref:`mjr_finish` と :ref:`mjr_getError` も提供しています。これらは内部的にglFinishとglGetErrorを呼び出します。これは、上記の基本的な2D描画関数と合わせて、ほとんどのユーザーがOpenGLコードを書く必要がないように十分な機能を提供することを意味しています。もちろん、OpenGLのすべてのラッパーを提供しない限り、すべてのケースでこれを達成することはできません。
