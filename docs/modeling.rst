==========
モデリング
==========

はじめに
------------

MuJoCoは、ネイティブの **MJCF** フォーマット、および広く使われているがより制限された **URDF** フォーマットでXMLモデルファイルを読み込むことができます。本章はMJCFモデリングガイドです。リファレンスマニュアルは :doc:`XMLreference` の章で参照できます。URDFのドキュメントは他で見つけることができます。ここではMuJoCo固有の :ref:`URDF拡張 <CURDF>` のみを説明します。

MJCFモデルは、幅広い機能とモデル要素を持つ複雑な動力学システムを表現できます。これらすべての機能にアクセスするには豊富なモデリングフォーマットが必要ですが、使いやすさを考慮して設計されていないと扱いにくくなる可能性があります。そのため、MJCFをスケーラブルなフォーマットとして設計し、ユーザーが小さく始めて後により詳細なモデルを構築できるようにする努力をしてきました。この点で特に役立つのが、HTMLにインライン化されたCascading Style Sheets（CSS）のアイデアに着想を得た広範な :ref:`デフォルト設定 <CDefault>` メカニズムです。これにより、ユーザーは新しいモデルを迅速に作成し、実験することができます。実験はさらに、シミュレーションパイプラインを再構成するために使用できる多数の :ref:`オプション <option>` と、モデル編集をインタラクティブなプロセスにする高速な再読み込みによって支援されます。

MJCFは、モデリングフォーマットとプログラミング言語のハイブリッドと考えることができます。組み込みのコンパイラがあり、これは通常プログラミング言語に関連付けられる概念です。MJCFは汎用プログラミング言語のような能力はありませんが、モデルの設計方法に応じて、多くの洗練されたコンパイル時計算が自動的に呼び出されます。

.. _Load:

モデルの読み込み
~~~~~~~~~~~~~~~~

Overviewの章の :ref:`モデルインスタンス <Instance>` で説明したように、MuJoCoモデルはMJCFまたはURDFフォーマットのプレーンテキストXMLファイルから読み込まれ、低レベルのmjModelにコンパイルされます。あるいは、以前に保存されたmjModelをバイナリMJBファイルから直接読み込むこともできます。MJBファイルのフォーマットは文書化されていませんが、本質的にはmjModelメモリバッファのコピーです。MJCFおよびURDFファイルは :ref:`mj_loadXML` で読み込まれ、MJBファイルは :ref:`mj_loadModel` で読み込まれます。

XMLファイルが読み込まれると、最初にTinyXMLパーサーを内部的に使用してドキュメントオブジェクトモデル（DOM）に解析されます。このDOMは処理され、高レベルの :ref:`mjSpec` オブジェクトに変換されます。変換はモデルフォーマットに依存し、フォーマットはXMLファイルのトップレベル要素から推測されます（ファイル拡張子からではありません）。有効なXMLファイルには一意のトップレベル要素があることを思い出してください。この要素は、MJCFの場合は :el:`mujoco` 、URDFの場合は :el:`robot` でなければなりません。

.. _Compile:

モデルのコンパイル
~~~~~~~~~~~~~~~~~~

高レベルの :ref:`mjSpec` が作成されたら（MJCFファイルまたはURDFファイルを読み込むか、 :doc:`プログラムで<programming/modeledit>` 作成するかによって）、それを :ref:`mjModel` にコンパイルします。コンパイルは読み込みから独立しており、コンパイラは :ref:`mjSpec` がどのように作成されたかに関係なく同じ方法で動作します。パーサーとコンパイラはどちらも広範なエラーチェックを実行し、最初のエラーが検出されたときに中止します。結果として得られるエラーメッセージには、XMLファイルの行番号と列番号が含まれ、自明であるためここでは文書化しません。パーサーはカスタムスキーマを使用して、ファイル構造、要素、属性が有効であることを確認します。その後、コンパイラは多くの追加のセマンティックチェックを適用します。最後に、コンパイルされたモデルの1つのシミュレーションステップが実行され、ランタイムエラーがインターセプトされます。後者は、（一時的に） :ref:`mju_user_error` をC++例外をスローする関数にポイントすることによって行われます。ユーザーは必要に応じて、ランタイム時に同様のエラーインターセプト機能を実装できます。

解析とコンパイルのプロセス全体は非常に高速です。モデルに大きなメッシュやシミュレーションを介して計算する必要があるアクチュエータのlengthrangeが含まれていない場合は、1秒未満です。これにより、頻繁に再読み込みして変更を可視化することで、モデルをインタラクティブに設計することが可能になります。 :ref:`simulate.cc <saSimulate>` コードサンプルには、現在のモデルを再読み込みするためのキーボードショートカット（Ctrl+L）があることに注意してください。

.. _Save:

モデルの保存
~~~~~~~~~~~~~

MJCFモデルは、複数の（インクルードされた）XMLファイル、およびXMLから参照されるメッシュ、ハイトフィールド、テクスチャで構成できます。コンパイル後、これらすべてのファイルの内容がmjModelに組み立てられ、 :ref:`mj_saveModel` でバイナリMJBファイルに保存できます。MJBはスタンドアロンファイルであり、他のファイルを参照しません。また、読み込みも高速です。そのため、一般的に使用されるモデルをMJBとして保存し、シミュレーションに必要なときに読み込むことをお勧めします。

コンパイルされた :ref:`mjSpec` を :ref:`mj_saveLastXML` でMJCFとして保存することもできます。対応するmjModelの実数値フィールドがコンパイル後に変更された場合（これは珍しいですが、たとえばシステム同定アプリケーションで発生する可能性があります）、変更は保存前に自動的に :ref:`mjSpec` にコピーバックされます。コンパイルされたモデルでは構造的な変更はできないことに注意してください。XMLライターは、同じモデルにコンパイルされることが保証された最小のMJCFファイルを生成しようとします（実数値のプレーンテキスト表現によって引き起こされる無視できる数値の違いは除く）。結果のファイルは元のファイルと同じ構造を持たない場合があります。これは、MJCFには多くのユーザー便利機能があり、同じモデルを異なる方法で指定できるためです。XMLライターは、すべての座標がローカルであり、すべてのボディの位置、向き、慣性特性が明示的に指定されているMJCFの「正規」サブセットを使用します。Computationの章では、 `example <_static/example.xml>`__ MJCFファイルと対応する `saved example <_static/example_saved.xml>`__ を示しました。

.. _EditModel:

モデルの編集
~~~~~~~~~~~~~~

MuJoCo 3.2以降、 :ref:`mjSpec` 構造体と関連APIを使用してモデルを作成および変更することが可能です。詳細なドキュメントについては、 :doc:`Model Editing<programming/modeledit>` の章を参照してください。

.. _Mechanisms:

MJCFメカニズム
---------------

MJCFは、複数のモデル要素にまたがるモデル作成のためのいくつかのメカニズムを使用します。繰り返しを避けるため、本セクションでこれらを一度だけ詳しく説明します。これらのメカニズムは、Computationの章で紹介したものを超える新しいシミュレーション概念に対応するものではありません。その役割は、MJCFモデルの作成を簡素化し、正規フォーマットへの手動変換を必要とせずに異なるデータフォーマットの使用を可能にすることです。

.. _CTree:

キネマティックツリー
~~~~~~~~~~~~~~~~~~~~

MJCFファイルのメインパートは、ネストされた :ref:`body <body>` 要素によって作成されるXMLツリーです。トップレベルのボディは特別で、 :el:`worldbody` と呼ばれます。このツリー構造は、リンクのコレクションを作成してから子と親のリンクを指定するジョイントでそれらを接続するURDFとは対照的です。MJCFでは、子ボディは文字通りXMLの意味で親ボディの子です。

ボディ内に :ref:`ジョイント <body-joint>` が定義されている場合、その機能は親と子を接続することではなく、それらの間に運動の自由度を作成することです。特定のボディ内にジョイントが定義されていない場合、そのボディは親に溶接されます。MJCFのボディは複数のジョイントを含むことができるため、複合ジョイントを作成するためにダミーボディを導入する必要はありません。代わりに、同じボディ内に目的の複合ジョイントを形成するすべてのプリミティブジョイントを定義するだけです。たとえば、2つのスライダーと1つのヒンジを使用して、平面内を移動するボディをモデル化できます。

他のMJCF要素は、ネストされたボディ要素によって作成されたツリー内で定義できます。特に :ref:`joint <body-joint>` 、 :ref:`geom <body-geom>` 、 :ref:`site <body-site>` 、 :ref:`camera <body-camera>` 、 :ref:`light <body-light>` などです。要素がボディ内で定義されると、そのボディのローカルフレームに固定され、常にそれと一緒に移動します。複数のボディを参照する要素、またはボディをまったく参照しない要素は、キネマティックツリーの外部の個別のセクションで定義されます。

.. _CDefault:

デフォルト設定
~~~~~~~~~~~~~~~~

MJCFには、デフォルトの属性値を設定するための精巧なメカニズムがあります。これにより、ソフトウェアの豊富な機能を公開するために必要な多数の要素と属性を持ちながら、同時に短く読みやすいモデルファイルを書くことができます。このメカニズムはさらに、ユーザーが1つの場所で変更を導入し、それをモデル全体に伝播させることを可能にします。まず例から始めます。

.. code-block:: xml

   <mujoco>
     <default class="main">
       <geom rgba="1 0 0 1"/>
       <default class="sub">
         <geom rgba="0 1 0 1"/>
       </default>
     </default>

     <worldbody>
       <geom type="box"/>
       <body childclass="sub">
         <geom type="ellipsoid"/>
         <geom type="sphere" rgba="0 0 1 1"/>
         <geom type="cylinder" class="main"/>
       </body>
     </worldbody>
   </mujoco>

この例は、いくつかの必要な情報が欠けているため実際にはコンパイルされませんが、ここではgeomのrgba値の設定のみに関心があります。上記で作成された4つのジオムは、デフォルト設定メカニズムの結果として、以下のrgba値になります：

========= =========
geom type geom rgba
========= =========
box       1 0 0 1
ellipsoid 0 1 0 1
sphere    0 0 1 1
cylinder  1 0 0 1
========= =========


boxは、他のクラスが指定されていないため、トップレベルのデフォルトクラス "main" を使用して未定義の属性の値を設定します。ボディはchildclass "sub" を指定しているため、このボディのすべての子（およびそのすべての子など）は、特に指定されない限りクラス "sub" を使用します。そのため、ellipsoidはクラス "sub" を使用します。sphereは明示的にrgbaを定義しており、これによりデフォルト設定がオーバーライドされます。cylinderはデフォルトクラス "main" を指定しているため、ジオムを含むボディのchildclass属性で後者が指定されているにもかかわらず、"sub" ではなく "main" を使用します。

次に一般的なルールを説明します。MuJoCoは、XML内のネストされた可能性のある :ref:`default <default>` 要素によって作成される無制限の数のデフォルトクラスをサポートします。各クラスには一意の名前があります。これはトップレベルクラスを除いて必須属性であり、トップレベルクラスの名前は未定義のままにすると "main" になります。各クラスには、次のように属性が設定されたダミーモデル要素の完全なコレクションもあります。デフォルトクラスが別のデフォルトクラス内で定義されている場合、子は親からすべての属性値を自動的に継承します。その後、対応する属性を定義することで、それらの一部またはすべてをオーバーライドできます。トップレベルのデフォルトクラスには親がないため、その属性は :doc:`Referenceの章<XMLreference>` に示されている内部デフォルトに初期化されます。

デフォルトクラスに含まれるダミー要素はモデルの一部ではありません。これらは、実際のモデル要素の属性値を初期化するためにのみ使用されます。実際の要素が最初に作成されるとき、そのすべての属性は、現在アクティブなデフォルトクラスの対応するダミー要素からコピーされます。常にアクティブなデフォルトクラスがあり、これは3つの方法のいずれかで決定できます。現在の要素またはその祖先ボディのいずれにもクラスが指定されていない場合、トップレベルクラスが使用されます（"main" と呼ばれるかどうかに関係なく）。現在の要素にクラスが指定されていないが、その祖先ボディの1つ以上がchildclassを指定している場合、最も近い祖先ボディからのchildclassが使用されます。現在の要素がクラスを指定している場合、その祖先ボディのchildclass属性に関係なく、そのクラスが使用されます。

ボディの慣性など、一部の属性は特別な未定義状態にある可能性があります。これは、コンパイラに他の情報から対応する値を推測するよう指示します。この場合、ボディに取り付けられたジオムの慣性から推測します。未定義状態はXMLファイルで入力できません。したがって、特定のクラスで属性が定義されると、そのクラスまたはその子クラスのいずれでも未定義にすることはできません。したがって、特定のモデル要素で特定の属性を未定義のままにすることが目標である場合、アクティブなデフォルトクラスで未定義である必要があります。

ここで最後のひねりはアクチュエータです。これらは、アクチュエータ関連要素の一部が実際にはショートカットであり、ショートカットがデフォルト設定メカニズムと非自明な方法で相互作用するため、異なります。これについては、以下の :ref:`Actuator shortcuts <CActShortcuts>` セクションで説明します。

.. _CFrame:

座標フレーム
~~~~~~~~~~~~~~~~~

キネマティックツリーで定義されたすべての要素の位置と向きは、ローカル座標で表現されます。ボディの場合は親ボディに対する相対座標、ジオム、ジョイント、サイト、カメラ、ライトの場合はそれらを含むボディに対する相対座標です。

関連する属性は :ref:`compiler/angle<compiler-angle>` です。これは、MJCFファイル内の角度が度数法またはラジアンで表現されているかを指定します（コンパイル後、角度は常にラジアンで表現されます）。

位置は次のように指定されます

:at:`pos`: :at-val:`real(3), "0 0 0"`
   親に対する相対位置。

.. _COrientation:

フレームの向き
^^^^^^^^^^^^^^^^^^

いくつかのモデル要素には、右手系の空間フレームが関連付けられています。これらは、ジョイントを除くキネマティックツリーで定義されたすべての要素です。空間フレームは、その位置と向きによって定義されます。3D位置の指定は簡単ですが、3D向きの指定は困難な場合があります。このため、MJCFはいくつかの代替メカニズムを提供しています。ユーザーがどのメカニズムを選択しても、フレームの向きは常に内部的に単位クォータニオンに変換されます。単位ベクトル :math:`(x, y, z)` で与えられる軸の周りの角度 :math:`a` による3D回転は、クォータニオン :math:`(\cos(a/2), \: \sin(a/2) \cdot (x, y, z))` に対応することを思い出してください。また、すべての3D向きは、ある軸の周りのある角度による単一の3D回転によって一意に指定できることも思い出してください。

空間フレームを持つすべてのMJCF要素は、以下にリストされている5つの属性を許可します。フレームの向きは、これらの属性のうち最大1つを使用して指定されます。 :at:`quat` 属性には、回転なしに対応するデフォルト値がありますが、他の属性は特別な未定義状態で初期化されます。したがって、ユーザーがこれらの属性を指定しない場合、フレームは回転されません。

:at:`quat`: :at-val:`real(4), "1 0 0 0"`
   クォータニオンがわかっている場合、これは変換を必要としないため、フレームの向きを指定する好ましい方法です。代わりに、単位長に正規化され、コンパイル中にmjModelにコピーされます。モデルがMJCFとして保存されると、すべてのフレームの向きはこの属性を使用してクォータニオンとして表現されます。
:at:`axisangle`: :at-val:`real(4), optional`
   これらは上記で言及した量 :math:`(x, y, z, a)` です。最後の数値は回転角度で、 :ref:`compiler <compiler>` の :at:`angle` 属性で指定された度数法またはラジアンで表されます。最初の3つの数値は、回転軸である3Dベクトルを決定します。このベクトルはコンパイル中に単位長に正規化されるため、ユーザーは任意の非ゼロ長のベクトルを指定できます。回転は右手系であることに注意してください。ベクトル :math:`(x, y, z)` の方向が逆転すると、反対の回転になります。 :math:`a` の符号を変更することも、反対の回転を指定するために使用できます。
:at:`euler`: :at-val:`real(3), optional`
   3つの座標軸の周りの回転角度。これらの回転が適用される軸のシーケンスは、 :ref:`compiler <compiler>` の :at:`eulerseq` 属性によって決定され、モデル全体で同じです。
:at:`xyaxes`: :at-val:`real(6), optional`
   最初の3つの数値はフレームのX軸です。次の3つの数値はフレームのY軸で、X軸に対して自動的に直交化されます。次に、Z軸はXとY軸の外積として定義されます。
:at:`zaxis`: :at-val:`real(3), optional`
   フレームのZ軸。コンパイラは、ベクトル :math:`(0, 0, 1)` をここで指定されたベクトルにマッピングする最小の回転を見つけます。これにより、フレームのXとY軸が暗黙的に決定されます。これは、Z軸周りの回転対称性を持つジオム、およびそのフレームのZ軸に沿って向けられたライトに役立ちます。

.. _CSolver:

ソルバーパラメータ
~~~~~~~~~~~~~~~~~~

Computationの章の :ref:`Parameters <soParameters>` セクションでは、MuJoCoの制約の動作を決定する量 :math:`d, b, k` の数学的およびアルゴリズム的意味を説明しました。ここでは、それらを設定する方法を説明します。設定は、制約を含むすべてのMJCF要素で利用可能な属性 :at:`solref` および :at:`solimp` を通じて間接的に行われます。これらのパラメータは、制約ごと、またはデフォルトクラスごとに調整できます。または未定義のままにすることもでき、その場合MuJoCoは以下に示す内部デフォルトを使用します。 :ref:`option <option>` で利用可能なオーバーライドメカニズムにも注意してください。これは、パラメータ設定を対話的に実験したり、数値最適化の継続法を実装したりするために、実行時にすべての接触関連ソルバーパラメータを変更するために使用できます。

ここでは、単一のスカラー制約に焦点を当てます。Computationの章とは若干異なる記法を使用して、 :math:`\ac` を加速度、 :math:`v` を速度、 :math:`r` を位置または残差（摩擦次元では0として定義）、 :math:`k` と :math:`b` を参照加速度 :math:`\ar = -b v - k r` を定義するために使用される仮想バネの剛性と減衰とします。 :math:`d` を制約インピーダンス、 :math:`\au` を制約力がない場合の加速度とします。以前の分析により、制約空間の動力学は近似的に次のようになることがわかりました

.. math::
   \ac + d \cdot (b v + k r) = (1 - d)\cdot \au
   :label: eq:constraint

繰り返しますが、ユーザーが制御できるパラメータは :math:`d, b, k` です。残りの量はシステム状態の関数であり、各タイムステップで自動的に計算されます。

.. _CSolverImpedance:

インピーダンス
^^^^^^^^^^^^^^

まず、制約インピーダンス :math:`d` を説明します。

.. admonition:: **インピーダンス** の直感的な説明

   *インピーダンス* :math:`d \in (0, 1)` は、制約の **力を生成する能力** に対応します。 :math:`d` の小さい値は弱い制約に対応し、 :math:`d` の大きい値は強い制約に対応します。インピーダンスは、特にシステムが静止しているときを含め、常に制約に影響を与えます。インピーダンスは :at:`solimp` 属性を使用して設定されます。

:math:`d` は0と1の間でなければならないことを思い出してください。内部的にMuJoCoは、現在[0.0001 0.9999]に設定されている範囲 [:ref:`mjMINIMP mjMAXIMP <glNumeric>`] にクランプします。これにより、ソルバーは強制されていない加速度 :math:`\au` と参照加速度 :math:`\ar` の間で補間します。ユーザーは :math:`d` を定数に設定するか、その補間特性を利用して位置に依存させる、つまり制約違反 :math:`r` の関数にすることができます。位置依存インピーダンスは、オブジェクトの周りの柔らかい接触層をモデル化したり、違反が大きくなるほど強くなる等式制約を定義したりするために使用できます（たとえば、バックラッシュを近似するため）。関数 :math:`d(r)` の形状は、要素固有のパラメータベクトル :at:`solimp` によって決定されます。

**solimp :** real(5), "0.9 0.95 0.001 0.5 2"
   5つの数値 (:math:`d_0`, :math:`d_\text{width}`, :math:`\text{width}`, :math:`\text{midpoint}`, :math:`\text{power}`) は、 :math:`d(r)` をパラメータ化します。これは、制約違反 :math:`r` の関数としてのインピーダンス :math:`d` です。

   最初の3つの値は、インピーダンスが :math:`r` が :math:`0` から :math:`\text{width}` まで変化するにつれて滑らかに変化することを示します：

   .. math::
      d(0) = d_0, \quad d(\text{width}) = d_\text{width}

   4番目と5番目の値、 :math:`\text{midpoint}` と :math:`\text{power}` は、以下のプロットに示すように、 :math:`d_0` と :math:`d_\text{width}` の間を補間するシグモイド関数の形状を制御します。プロットは2つの反射されたシグモイドを示していますが、これはインピーダンス :math:`d(r)` が :math:`r` の絶対値に依存するためです。 :math:`\text{power}` （関数を生成するために使用される多項式スプラインの累乗）は1以上でなければなりません。 :math:`\text{midpoint}` （変曲点を指定）は0と1の間でなければならず、 :math:`\text{width}` の単位で表されます。 :math:`\text{power}` が1の場合、 :math:`\text{midpoint}` に関係なく関数は線形であることに注意してください。

   .. image:: images/modeling/impedance.png
      :width: 600px
      :align: center
      :class: only-light

   .. image:: images/modeling/impedance_dark.png
      :width: 600px
      :align: center
      :class: only-dark

   これらのプロットは、垂直軸にインピーダンス :math:`d(r)` を、水平軸に制約違反 :math:`r` の関数として示しています。

   等式制約の場合、 :math:`r` は制約違反です。リミット、楕円錐の法線方向、および角錐錐のすべての方向の場合、 :math:`r` は（リミットまたは接触）距離から制約がアクティブになるマージンを引いたものです。接触の場合、このマージンは :ref:`margin<body-geom-margin>`-:ref:`gap<body-geom-gap>` です。リミットおよび接触制約は、 :math:`r < 0` （貫入）のときにアクティブです。

   摩擦損失または楕円錐の摩擦次元の場合、違反 :math:`r` は恒等的にゼロであるため、 :math:`d(0)` のみがこれらの制約に影響を与え、他のすべての :at:`solimp` 値は無視されます。

   .. _solimp0:

   .. admonition:: 滑らかさと微分可能性
      :class: tip

      完全に滑らかな（微分可能な）動力学のために、リミットと接触は :math:`d_0=0` （``solimp[0]=0``）を持つべきです。特に接触の場合、ジオムに関連付けられたソルバーパラメータの :ref:`混合ルール<solmixing>` を念頭に置く必要があります。 :ref:`Computationの章<derivatives>` および :ref:`mjd_transitionFD` ドキュメントの導関数の議論も参照してください。

.. _CSolverReference:

参照
^^^^^^^^^

次に、参照加速度 :math:`\ar` を制御する剛性 :math:`k` と減衰 :math:`b` の設定を説明します。

.. admonition:: **参照加速度** の直感的な説明

   *参照加速度* :math:`\ar` は、違反を修正するために制約が達成しようとしている **運動** を決定します。平面上に落とされたボディを想像してください。衝撃時に、制約は特定の運動を使用して貫入を修正しようとする法線力を生成します。この運動が参照加速度です。

   参照加速度を理解する別の方法は、 :ref:`Computationの章<soPrimal>` で説明されているモデル化されていない変形変数を考えることです。2つのボディが押し合わされ、接触部分で変形が発生することを想像してください。次に、ボディを非常に速く引き離します。変形が未変形状態に落ち着くときの運動が参照加速度です。

   この加速度は、2つの数値、剛性 :math:`k` と減衰 :math:`b` によって定義されます。これらは直接設定することも、質量・バネ・ダンパーシステム（ `調和振動子 <https://en.wikipedia.org/wiki/Harmonic_oscillator>`__ ）の時定数と減衰比として再パラメータ化することもできます。参照加速度は :at:`solref` 属性によって制御されます。

この属性には、数値の符号によって決定される2つのフォーマットがあります。両方の数値が正の場合、仕様は :math:`(\text{timeconst}, \text{dampratio})` フォーマットであると見なされます。負の場合、「直接」 :math:`(-\text{stiffness}, -\text{damping})` フォーマットです。

残差が恒等的に0である摩擦制約は1次動力学を持ち、以下の質量・バネ・ダンパー解析は適用されません。この場合、時定数は制約速度の指数減衰の速度であり、減衰比は無視されます。同等に、直接フォーマットでは :math:`\text{stiffness}` が無視されます。

**solref :** real(2), "0.02 1"
   まず、2つの数値が :math:`(\text{timeconst}, \text{dampratio})` であるデフォルトの正値フォーマットを説明します。

   ここでのアイデアは、質量・バネ・ダンパーシステムの時定数と減衰比の観点からモデルを再パラメータ化することです。「時定数」とは、固有周波数と減衰比の積の逆数を意味します。この場合、適切なスケーリング後に :math:`k, b` を計算するために質量・バネ・ダンパーモデルを使用します。実効剛性 :math:`d(r) \cdot k` と減衰 :math:`d(r) \cdot b` は、距離 :math:`r` の関数であるインピーダンス :math:`d(r)` によってスケールされることに注意してください。したがって、 :math:`d` によるスケーリングを完全に元に戻さない限り、指定された質量・バネ・ダンパー特性を常に達成できるわけではありません。しかし、後者は補間特性を台無しにするため望ましくありません。特に、リミット :math:`d=0` は制約を無効にしなくなります。代わりに、減衰比が一定のままであるように剛性と減衰をスケールし、 :math:`d(r)` が小さくなると時定数が増加するようにします。スケーリング式は次のとおりです

   .. math::
      \begin{aligned}
      b &= 2 / (d_\text{width}\cdot \text{timeconst}) \\
      k &= d(r) / (d_\text{width}^2 \cdot \text{timeconst}^2 \cdot \text{dampratio}^2) \\
      \end{aligned}

   timeconst パラメータは、シミュレーションのタイムステップの少なくとも2倍大きくする必要があります。そうでない場合、システムは数値積分器に対して剛性が高くなりすぎ（特にオイラー積分が使用されている場合）、シミュレーションが不安定になる可能性があります。これは、 :ref:`flag <option-flag>` の :ref:`refsafe<option-flag-refsafe>` 属性がfalseに設定されていない限り、内部的に強制されます。 :math:`\text{dampratio}` パラメータは通常1に設定され、臨界減衰に対応します。小さい値は減衰不足またはバウンシーな制約をもたらし、大きい値は過減衰制約をもたらします。上記の式を :eq:`eq:constraint` と組み合わせると、次の結果を導出できます。参照加速度が正の数値フォーマットで与えられ、インピーダンスが定数 :math:`d = d_0 = d_\text{width}` である場合、静止時の貫入深さは次のとおりです

   .. math::
      r = \au \cdot (1 - d) \cdot \text{timeconst}^2 \cdot \text{dampratio}^2

   次に、2つの数値が :math:`(-\text{stiffness}, -\text{damping})` である直接フォーマットを説明します。これにより、特に反発係数を直接制御できます。異なるインピーダンスで同じ数値を使用できるように、いくつかのスケーリングを適用しますが、スケーリングは :math:`r` に依存しなくなり、2つの数値は相互作用しなくなります。スケーリング式は次のとおりです

   .. math::
      \begin{aligned}
      b &= \text{damping} / d_\text{width} \\
      k &= \text{stiffness} \cdot d(r) / d_\text{width}^2 \\
      \end{aligned}

   上記の導出と同様に、参照加速度が負の数値フォーマットで与えられ、インピーダンスが定数である場合、静止時の貫入深さは次のとおりです

   .. math::
      r = \frac{\au (1 - d)}{\text{stiffness}}

.. tip::
   正値のデフォルトフォーマットでは、 :math:`\text{timeconst}` パラメータが制約の **柔軟性** を制御します。これは時間の単位で指定され、「制約がどれだけ速く違反を解決しようとしているか」を意味します。より大きい値はより柔らかい制約に対応します。

   負値の「直接」フォーマットはより柔軟で、たとえば完全弾性衝突（ :math:`\text{damping} = 0` ）を許可します。これはシステム同定に推奨されるフォーマットです。

   正値フォーマットの :math:`\text{dampratio}` 1は、直接フォーマットの :math:`\text{damping} = 2 \sqrt{ \text{stiffness} }` に相当します。

.. _CContact:

接触パラメータ
~~~~~~~~~~~~~~~~~~

各接触のパラメータは、Computationの章の :ref:`Contact <coContact>` セクションで説明されています。ここでは、これらのパラメータがどのように設定されるかを説明します。ジオムペアがXML要素 :ref:`pair <contact-pair>` で明示的に定義されている場合、すべての接触パラメータを直接指定する属性があります。その場合、個々のジオムのパラメータは無視されます。一方、接触が動的メカニズムによって生成される場合、そのパラメータは接触ペアの2つのジオムから推測する必要があります。2つのジオムが同一のパラメータを持っている場合は何もする必要がありませんが、パラメータが異なる場合はどうでしょうか？その場合、ジオム属性 :at:`solmix` と :at:`priority` を使用して、それらを組み合わせる方法を決定します。各接触パラメータの組み合わせルールは次のとおりです：

**condim**
   2つのジオムのうち一方の優先度が高い場合、そのcondimが使用されます。両方のジオムの優先度が同じ場合、2つのcondimの最大値が使用されます。このようにして、摩擦のないジオムと摩擦のあるジオムは、摩擦のないジオムの優先度が高くない限り、摩擦のある接触を形成します。後者は、たとえばパーティクルシステムで、パーティクルがどのオブジェクトにも付着しないようにしたい場合に望ましいです。
**friction**
   接触は最大5つの摩擦係数を持つことができることを思い出してください：2つの接線方向、1つのねじり、2つの転がり。mjData.contactの各接触は実際にこれら5つすべてを持っています。condimが6未満で、すべての係数が使用されていない場合でもです。対照的に、ジオムには3つの摩擦係数しかありません：接線方向（両軸で同じ）、ねじり、転がり（両軸で同じ）。これらの3D摩擦係数ベクトルは、接線および転がりコンポーネントを複製することにより、5D摩擦係数ベクトルに拡張されます。接線、ねじり、転がり係数のセマンティクスの直感的な説明については、Computationの章の :ref:`Contact<coContact>` セクションを参照してください。

   その後、接触摩擦係数は次のルールに従って計算されます：2つのジオムのうち一方の優先度が高い場合、その摩擦係数が使用されます。それ以外の場合、2つのジオムにわたる各摩擦係数の **要素ごとの最大値** が使用されます。

   接触ごとに5つの係数があり、ジオムごとに3つしかない理由は次のとおりです。接触ペアの場合、ソルバーが処理できる最も柔軟なモデルを許可したいと考えています。前述のように、異方性摩擦はスケートなどの効果をモデル化するために利用できます。ただし、これには接触接線面の2つの軸がどのように向いているかを知る必要があります。事前定義された接触ペアの場合、2つのジオムタイプを事前に知っており、対応する衝突関数は常に同じ方法で向けられた接触フレームを生成します。これについてはここでは説明しませんが、ビジュアライザーで見ることができます。ただし、個々のジオムの場合、どの他のジオムと衝突する可能性があるか、そのジオムタイプが何であるかわからないため、個々のジオムを指定するときに接触接線面がどのように向けられるかを知る方法はありません。これが、MuJoCoが個々のジオム仕様では異方性摩擦を許可せず、明示的な接触ペア仕様でのみ許可する理由です。
**margin**, **gap**
   2つのジオムマージン（またはギャップ）の最大値が使用されます。マージンとギャップは距離プロパティであり、片側の仕様はあまり意味がないため、ジオムの優先度はここでは無視されます。

.. _solmixing:

**solref**, **solimp**
   2つのジオムのうち一方の :ref:`priority<body-geom-priority>` が高い場合、そのsolrefおよびsolimpパラメータが使用されます。両方のジオムの優先度が同じ場合、加重平均が使用されます。重みはsolmix属性に比例します。つまり、weight1 = solmix1 / (solmix1 + solmix2)、同様にweight2です。この加重平均ルールには1つの重要な例外があります。いずれかのジオムのsolrefが非正、つまり直接フォーマットに依存している場合、solmixに関係なく要素ごとの最小値が使用されます。これは、異なるフォーマットのsolrefパラメータを平均化することが無意味だからです。

.. _COverride:

接触オーバーライド
~~~~~~~~~~~~~~~~~~

MuJoCoは、Computationの章で説明されている精巧で新しい :ref:`制約モデル <Constraint>` を使用しています。このモデルがどのように機能するかについての直感を得るには、いくつかの実験が必要です。このプロセスを容易にするために、実際のモデルを変更することなく、一部のソルバーパラメータをオーバーライドするメカニズムを提供しています。オーバーライドが無効になると、シミュレーションはモデルで指定されたパラメータに戻ります。このメカニズムは、数値最適化（最適制御や状態推定など）のコンテキストで継続法を実装するためにも使用できます。これは、最適化の初期段階で接触が距離から作用できるようにすることで行われます。これにより、オプティマイザーが勾配を見つけ、良い解に近づくのを助け、後でこの効果を減らして最終的な解を物理的に現実的にします。

ここで関連する設定は、このメカニズムを有効および無効にする :ref:`flag <option-flag>` の :at:`override` 属性と、新しいソルバーパラメータを指定する :ref:`option <option>` の :at:`o_margin` 、 :at:`o_solref` 、 :at:`o_solimp` 属性です。オーバーライドは接触にのみ適用され、他のタイプの制約には適用されないことに注意してください。原理的には、MuJoCoモデルには同様のオーバーライドメカニズムの恩恵を受ける可能性のある多くの実数値パラメータがあります。ただし、どこかで線を引く必要があり、接触は自然な選択です。なぜなら、接触は最も豊富でありながら調整が最も難しい動作を引き起こすからです。さらに、接触動力学は数値最適化の観点から課題を提示することが多く、経験によれば、接触パラメータに対する継続法は局所最小値を回避するのに役立つことが示されています。

.. _CUser:

ユーザーパラメータ
~~~~~~~~~~~~~~~~~~

多くのMJCF要素には、カスタムの要素固有パラメータ配列を定義するオプション属性 :at:`user` があります。これは、 :ref:`size <size>` 要素の対応する"nuser_XXX"属性と相互作用します。たとえば、 :at:`nuser_geom` を5に設定すると、mjModelのすべてのジオムには5つの実数値パラメータのカスタム配列があります。これらのジオム固有のパラメータは、 :ref:`geom <body-geom>` の :at:`user` 属性を介してMJCFファイルで定義されるか、この属性が省略された場合はコンパイラによって0に設定されます。すべての"nuser_XXX"属性のデフォルト値は-1であり、これはコンパイラにこの値をモデルで定義された関連する :at:`user` 属性の最大長に自動的に設定するよう指示します。MuJoCoはこれらのパラメータを内部計算で使用しません。代わりに、カスタム計算に使用できます。パーサーはXMLで任意の長さの配列を許可し、コンパイラは後でそれらをnuser_XXXの長さにサイズ変更します。

通常内部計算で使用される一部の要素固有パラメータは、カスタム計算でも使用できます。これは、シミュレーションパイプラインの一部をオーバーライドするユーザーコールバックをインストールすることによって行われます。たとえば、 :ref:`general <actuator-general>` アクチュエータ要素には属性 :at:`dyntype` および :at:`dynprm` があります。 :at:`dyntype` が"user"に設定されている場合、MuJoCoは内部関数を呼び出す代わりに :ref:`mjcb_act_dyn` を呼び出してアクチュエータダイナミクスを計算します。 :ref:`mjcb_act_dyn` が指すユーザー関数は、 :at:`dynprm` で定義されたパラメータを好きなように解釈できます。ただし、このパラメータ配列の長さは変更できません（長さがMJCFファイルで定義される以前に説明したカスタム配列とは異なります）。他のコールバックにも同じことが当てはまります。

上記で説明した要素固有のユーザーパラメータに加えて、 :ref:`custom <custom>` 要素を介してモデルにグローバルデータを含めることができます。シミュレーションの過程で変化するデータの場合、配列mjData.userdataもあり、そのサイズは :ref:`size <size>` 要素の :at:`nuserdata` 属性によって決定されます。

.. _CAlgorithms:

ソルバー設定
~~~~~~~~~~~~~~~

制約力と制約加速度の計算には、最適化問題を数値的に解くことが含まれます。MuJoCoには、この最適化問題を解くための3つのアルゴリズムがあります：CG、Newton、PGS。それぞれは、摩擦円錐の角錐モデルまたは楕円モデルに適用でき、密または疎の制約ヤコビアンで適用できます。さらに、ユーザーは反復の最大数と、早期終了を制御する許容レベルを指定できます。また、正の数のnoslip反復を指定することで有効になる後処理ステップである2番目のNoslipソルバーもあります。これらすべてのアルゴリズム設定は、 :ref:`option <option>` 要素で指定できます。

デフォルト設定はほとんどのモデルでうまく機能しますが、場合によってはアルゴリズムを調整する必要があります。これを行う最良の方法は、関連する設定を試し、 :ref:`simulate.cc <saSimulate>` のビジュアルプロファイラーを使用することです。これは、反復ごとの異なる計算のタイミングとソルバー統計を示します。次の一般的なガイドラインと観察を提供できます：

-  制約ヤコビアンは、小さいモデルでは密、大きいモデルでは疎であるべきです。デフォルト設定は'auto'です。自由度の数が60以下の場合は密に、60を超える場合は疎に解決されます。ただし、しきい値はアクティブな制約の数の観点からより適切に定義されることに注意してください。これはモデルと動作に依存します。
-  角錐摩擦円錐と楕円摩擦円錐の選択は、アルゴリズムの選択ではなくモデリングの選択です。つまり、同じアルゴリズムで解かれる異なる最適化問題につながります。楕円錐は物理的現実により近く対応します。ただし、角錐錐はアルゴリズムのパフォーマンスを向上させることができますが、必ずしもそうとは限りません。デフォルトは角錐ですが、楕円錐を試すことをお勧めします。接触滑りが問題である場合、それを抑制する最良の方法は、楕円錐、大きなimpratio、および非常に小さい許容値を持つNewtonアルゴリズムを使用することです。それで十分でない場合は、Noslipソルバーを有効にします。
-  Newtonアルゴリズムはほとんどのモデルに最適な選択です。大域的最小値の近くで2次収束があり、驚くほど少ない反復でそこに到達します。通常は約5回、20回を超えることはめったにありません。（最後の2次収束により）追加の遅延なしに高精度を達成できるため、積極的な許容値、たとえば1e-10で使用する必要があります。速度が低下するのを見た唯一の状況は、楕円錐と多くの滑り接触を持つ大きなモデルです。その領域では、ヘッセ行列の因数分解に多くの更新が必要です。また、モデル要素の不適切な順序付けにより高いフィルインが発生する一部の大きなモデルでは速度が低下する可能性があります（最適な消去順序の計算はNP困難であるため、ヒューリスティックに依存しています）。因数分解されたヘッセ行列の非ゼロの数はプロファイラーで監視できることに注意してください。
-  CGアルゴリズムは、Newtonが遅くなる上記の状況でうまく機能します。一般に、CGは良好な速度で線形収束を示しますが、特に高精度が望まれる場合、反復数の点でNewtonと競合することはできません。ただし、その反復ははるかに高速であり、フィルインや楕円錐による複雑さの増加の影響を受けません。Newtonが遅すぎることが判明した場合は、次にCGを試してください。
-  PGSソルバーは、自由度の数が制約の数よりも大きい場合に最適です。PGSは制約付き最適化問題を解き、私たちの経験では線形未満の収束を示しますが、通常は最初の数回の反復で急速に進歩します。したがって、不正確な解が許容できる場合に適した選択です。大きな質量比やその他の条件不良を引き起こすモデル特性を持つシステムの場合、PGS収束は非常に遅い傾向があります。PGSは逐次更新を実行するため、物理が対称であるべきシステムで対称性を破ることに注意してください。対照的に、CGとNewtonは並列更新を実行し、対称性を保持します。
-  Noslipソルバーは修正されたPGSソルバーです。これは、メインソルバー（Newton、CG、またはPGSのいずれか）の後の後処理ステップとして実行されます。メインソルバーはすべての未知数を更新します。対照的に、Noslipソルバーは摩擦次元の制約力のみを更新し、制約正則化を無視します。これにより、柔軟制約モデルによって引き起こされるドリフトまたは滑りを抑制する効果があります。ただし、この最適化ステップのカスケードは、明確に定義された最適化問題（または他の問題）を解いていません。代わりに、単なるアドホックメカニズムです。通常はその仕事をしますが、複数の接触間のより複雑な相互作用を持つモデルでいくつかの不安定性を見てきました。
-  PGSには、制約空間で逆慣性を計算するためのセットアップコスト（CPU時間の観点から）があります。同様に、Newtonにはヘッセ行列の初期因数分解のセットアップコストがあり、後で必要な因数分解更新の数に応じて追加の因数分解コストが発生します。CGにはセットアップコストがありません。NoslipソルバーもPGSソルバーであるため、メインソルバーがCGまたはNewtonであっても、Noslipが有効になっている場合はPGSセットアップコストが支払われます。メインPGSとNoslip PGSのセットアップ操作は同じであるため、両方が有効になっている場合、セットアップコストは1回だけ支払われます。

.. _CActuators:

アクチュエータ
~~~~~~~~~~~~~~

このセクションでは、MuJoCoにおけるアクチュエータの使用に関する様々な側面について説明します。計算モデルについては :ref:`Actuation model <geActuation>` を参照してください。

.. _CActDisable:

グループの無効化
^^^^^^^^^^^^^^^^

:ref:`actuatorgroupdisable<option-actuatorgroupdisable>` 属性は、ランタイム時に :ref:`mjOption.disableactuator<mjOption>` 整数ビットフィールドを設定することで変更でき、ユーザーは :ref:`group<actuator-general-group>` に応じてアクチュエータのセットを無効化できます。この機能は、同じキネマティックツリーに対して複数のタイプのアクチュエータを使用したい場合に便利です。例えば、トルク制御や位置制御など、複数の制御モードをサポートするファームウェアを持つロボットを考えてみましょう。この場合、同じMJCFモデル内に両方のタイプのアクチュエータを定義し、一方のタイプのアクチュエータをグループ0に、もう一方をグループ1に割り当てることができます。

.. youtube:: H9qG9Zf2W44
   :aspect: 2:1
   :align: right
   :width: 40%

:ref:`actuatorgroupdisable<option-actuatorgroupdisable>` MJCF属性は、デフォルトでどのグループが無効化されるかを選択し、 :ref:`mjOption.disableactuator<mjOption>` はランタイム時にアクティブなセットを切り替えるために設定できます。アクチュエータの総数 ``mjModel.nu`` は変わらず、アクチュエータのインデックスも同様であるため、無効化されたアクチュエータの ``mjData.ctrl`` 値が無視され、力を生成しないことをユーザーが把握する必要があることに注意してください。 `このサンプルモデル
<https://github.com/google-deepmind/mujoco/blob/main/test/engine/testdata/actuation/actuator_group_disable.xml>`__
には3つのアクチュエータグループがあり、 :ref:`simulate<saSimulate>` インタラクティブビューアでランタイム時に切り替えることができます。 `サンプルモデル
<https://github.com/google-deepmind/mujoco/blob/main/test/engine/testdata/actuation/actuator_group_disable.xml>`__
と右側の画面キャプチャを参照してください。

.. _CActShortcuts:

ショートカット
^^^^^^^^^^^^^^

Computationチャプターの :ref:`Actuation model <geActuation>` セクションで説明されているように、MuJoCoは伝達、活性化ダイナミクス、力の生成の各コンポーネントを独立して指定できる柔軟なアクチュエータモデルを提供しています。完全な機能はXML要素 :ref:`general <actuator-general>` を介してアクセスでき、ユーザーは様々なカスタムアクチュエータを作成できます。さらに、MJCFは一般的なアクチュエータを設定するためのショートカットを提供しています。これはXML要素 :ref:`motor <actuator-motor>`、 :ref:`position <actuator-position>`、 :ref:`velocity
<actuator-velocity>`、 :ref:`intvelocity <actuator-intvelocity>`、 :ref:`damper<actuator-damper>`、
:ref:`cylinder<actuator-cylinder>`、 :ref:`muscle <actuator-muscle>`、 :ref:`adhesion <actuator-adhesion>` を介して行われます。これらは独立したモデル要素では *ありません*。内部的にMuJoCoは1つのアクチュエータタイプのみをサポートしており、そのためMJCFモデルが保存されると、すべてのアクチュエータは :el:`general` として書き込まれます。ショートカットは暗黙的に一般アクチュエータを作成し、その属性を適切な値に設定し、おそらく異なる名前で属性のサブセットを公開します。例えば、 :el:`position` は属性 :at:`kp` を持つ位置サーボを作成します。これはサーボゲインです。しかし :el:`general` には属性 :at:`kp` がありません。代わりに、パーサーは一般アクチュエータのゲインとバイアスパラメータを協調的に調整して、位置サーボを模倣します。同じ効果は、 :el:`general` を直接使用し、その属性を以下に説明する特定の値に設定することで達成できます。

アクチュエータのショートカットはデフォルト設定とも相互作用します。 :ref:`default setting <CDefault>` メカニズムはクラスを伴うことを思い出してください。各クラスは、実際のモデル要素の属性を初期化するために使用されるダミー要素の完全なコレクション（各要素タイプごとに1つ）を持っています。特に、各デフォルトクラスは1つの一般アクチュエータ要素のみを持っています。同じデフォルトクラスで :el:`position` を指定し、その後 :el:`velocity` を指定するとどうなるでしょうか？ XML要素は順番に処理され、アクチュエータ関連の要素に遭遇するたびに、単一の一般アクチュエータの属性が設定されます。したがって :el:`velocity` が優先されます。ただし、デフォルトクラスで :el:`general` を指定した場合、明示的に指定された属性のみが設定され、残りは変更されません。実際のモデル要素を作成するときにも、同様の複雑さが生じます。アクティブなデフォルトクラスが :el:`position` を指定し、今度は :el:`general` を使用してアクチュエータを作成し、その属性の一部を省略したとします。欠落している属性は、このアクチュエータが位置サーボとして意図されていない場合でも、位置サーボをモデル化するために使用される値に設定されます。

これらの潜在的な複雑さを考慮して、シンプルなアプローチをお勧めします。デフォルトクラスと実際のモデル要素の作成の両方で、同じアクチュエータのショートカットを使用してください。特定のモデルが異なるアクチュエータを必要とする場合は、複数のデフォルトクラスを作成するか、アクチュエータにデフォルトを使用せず、すべての属性を明示的に指定してください。

.. _CForceRange:

力の制限
^^^^^^^^

アクチュエータの力は通常、下限と上限の間で制限されます。これらの制限は3つの方法で強制できます：

:ref:`ctrlrange<actuator-general-ctrlrange>` による制御のクランプ:
  このアクチュエータ属性が設定されている場合、入力制御値がクランプされます。シンプルな :ref:`motors<actuator-motor>` の場合、制御入力をクランプすることは、力出力をクランプすることと同等です。

:ref:`forcerange<actuator-general-forcerange>` によるアクチュエータ出力での力のクランプ:
  このアクチュエータ属性が設定されている場合、アクチュエータの出力力がクランプされます。この属性は、例えば :ref:`position actuators<actuator-position>` で力を制限内に保つために便利です。位置アクチュエータは通常、ジョイント限界に到達しないように制御範囲のクランプも必要とすることに注意してください。

:ref:`joint/actuatorfrcrange<body-joint-actuatorfrcrange>` によるジョイント入力での力のクランプ:
  このジョイント属性は、 :ref:`transmission<geTransmission>` を通過した後、ジョイントに作用するすべてのアクチュエータからの入力力をクランプします。ジョイントでアクチュエータの力をクランプすることは、伝達が自明（アクチュエータとジョイントの間に1対1の関係がある）である場合、アクチュエータでクランプすることと同等です。しかし、複数のアクチュエータが1つのジョイントに作用する、または1つのアクチュエータが複数のジョイントに作用する状況では、実際のトルクはジョイントの単一の物理的アクチュエータによって適用されるため、ジョイント自体で力をクランプすることが望ましいです。以下は、アクチュエータではなくジョイントでアクチュエータの力をクランプすることが望ましい3つの例です：

  - `このサンプルモデル
    <https://github.com/google-deepmind/mujoco/blob/main/test/engine/testdata/actuation/joint_force_clamp.xml>`__ では、2つのアクチュエータ、 :ref:`motor<actuator-motor>` と :ref:`damper<actuator-damper>` が単一のジョイントに作用します。
  - `このサンプルモデル <https://github.com/google-deepmind/mujoco/blob/main/model/car/car.xml>`__ （「Dubin's Car」に類似）では、2つのアクチュエータが :ref:`fixed tendon<tendon-fixed>` 伝達を介して2つのホイールに作用し、対称（前後にロール）および非対称（左右にターン）トルクを適用します。
  - `このサンプルモデル <https://github.com/google-deepmind/mujoco/tree/main/test/engine/testdata/actuation/refsite.xml>`__ では、 :ref:`site transmission<actuator-general-refsite>` がアームのエンドエフェクターの直交座標コントローラーを実装します。計算されたトルクが個別のトルク制限されたジョイントモーターによって実現可能であるためには、ジョイントでクランプする必要があります。

  このケースでは、力/トルクが伝達によって結合されるため、 :ref:`jointactuatorfrc<sensor-jointactuatorfrc>` センサーを使用して、ジョイントに作用する総アクチュエータ力を報告する必要があります。標準の :ref:`actuatorfrc<sensor-actuatorfrc>` センサーは、クランプ前のアクチュエータ力を報告し続けます。

:ref:`tendon/actuatorfrcrange<tendon-spatial-actuatorfrcrange>` によるテンドン入力での力のクランプ:
  このテンドン属性は、テンドンに作用するすべてのアクチュエータからの入力力をクランプします。

上記のクランプオプションは排他的ではなく、必要に応じて組み合わせることができます。

.. _CLengthRange:

長さ範囲
^^^^^^^^

フィールド ``mjModel.actuator_lengthrange`` には、実行可能なアクチュエータの長さ（より正確には、アクチュエータの伝達の長さ）の範囲が含まれています。これは :ref:`muscle actuators <CMuscle>` をシミュレートするために必要です。ここでは、actuator_lengthrangeが何を意味し、どのように設定するかに焦点を当てます。

正確な物理的または幾何学的な量である他のすべてのmjModelのフィールドとは異なり、actuator_lengthrangeは近似です。直感的には、モデルのすべての「実行可能な」構成にわたって、アクチュエータの伝達が到達できる最小および最大長に対応します。ただし、MuJoCoの制約は柔軟であるため、原理的にはあらゆる構成が実行可能です。それでも、マッスルモデリングには明確に定義された範囲が必要です。この範囲を設定する方法は3つあります：（1）すべてのアクチュエータで利用可能な新しい属性lengthrageを使用して明示的に提供する、（2）アクチュエータが接続されているジョイントまたはテンドンの限界からコピーする、（3）このセクションの残りで説明するように自動的に計算する。ここには多くのオプションがあり、新しいXML要素 :ref:`lengthrange <compiler-lengthrange>` で制御されます。

アクチュエータの長さ範囲の自動計算はコンパイル時に行われ、結果はコンパイルされたモデルのmjModel.actuator_lengthrangeに保存されます。モデルがその後保存される（XMLまたはMJBのいずれか）場合、次の読み込み時に計算を繰り返す必要はありません。これは、大規模な筋骨格モデルでは計算によりモデルコンパイラが遅くなる可能性があるため重要です。実際、この操作を高速化するためにコンパイラをマルチスレッド化しました（異なるアクチュエータが異なるスレッドで並列に処理されます）。

自動計算は、修正された物理シミュレーションに依存しています。各アクチュエータについて、アクチュエータの伝達を通じて力を適用し（最小値を計算するときは負、最大値を計算するときは正）、不安定性を避けて減衰レジームでシミュレーションを進め、落ち着くのに十分な時間を与え、結果を記録します。これは運動量を持つ勾配降下法に関連しており、実際に明示的な勾配ベースの最適化を実験しましたが、問題は、最適化すべき目的が明確でないことです（柔軟な制約の混合を考えると）。シミュレーションを使用することで、本質的に物理学に何を最適化すべきかを教えさせています。ただし、これは依然として最適化プロセスであり、そのため調整が必要なパラメータがあることを覚えておいてください。ほとんどのモデルで機能する保守的なデフォルトを提供していますが、機能しない場合は、 :ref:`lengthrange <compiler-lengthrange>` の属性を使用して微調整してください。

この機能を使用するときは、モデルのジオメトリを念頭に置くことが重要です。ここでの暗黙の仮定は、実行可能なアクチュエータの長さが実際に制限されているということです。さらに、制限要因として接触を考慮していません（実際、このシミュレーションでは、受動力、重力、摩擦損失、アクチュエータの力とともに、内部的に接触を無効にします）。これは、接触を持つモデルは絡まり合い、多くの局所最小値を生成する可能性があるためです。したがって、アクチュエータは、モデルで定義されたジョイントまたはテンドンの限界のいずれか（このシミュレーション中に有効になります）、またはジオメトリのために制限されるべきです。後者を説明するために、一方の端が世界に接続され、もう一方の端が世界に接続されたヒンジジョイントの周りを回転するオブジェクトに接続されたテンドンを考えてみましょう。この場合、テンドンの最小および最大長は明確に定義されており、接続点が空間で描く円のサイズに依存しますが、ジョイントもテンドンもユーザーによって定義された限界を持っていません。しかし、アクチュエータがジョイントに接続されている場合、またはジョイントに等しい固定テンドンに接続されている場合、それは無制限です。この場合、コンパイラはエラーを返しますが、エラーが収束の欠如によるものか、アクチュエータの長さが無制限であるためかを判断できません。これらすべてが過度に複雑に聞こえますが、ここではすべての可能なコーナーケースを考慮しているという意味でそうです。実際には、長さ範囲はほとんどの場合、空間テンドンに接続されたマッスルアクチュエータで使用され、モデルにはジョイント限界が定義されており、マッスルアクチュエータの長さを効果的に制限します。このようなモデルで収束エラーが発生した場合、最も可能性の高い説明は、ジョイント限界を含めるのを忘れたということです。

.. _CActivation:

状態を持つアクチュエータ
^^^^^^^^^^^^^^^^^^^^^^^^

Computationチャプターの :ref:`Actuation model <geActuation>` セクションで説明されているように、MuJoCoは「活性化」と呼ばれる状態を持つ内部ダイナミクスを持つアクチュエータをサポートしています。

.. _CActRange:

活性化の制限
''''''''''''

状態を持つアクチュエータの有用なアプリケーションの1つは、 :ref:`intvelocity<actuator-intvelocity>` ショートカットによって実装される「積分速度」アクチュエータです。伝達ターゲットの速度に対する直接フィードバックを実装する :ref:`pure velocity<actuator-velocity>` アクチュエータとは異なり、*積分速度* アクチュエータは *積分器* と *位置フィードバック* アクチュエータを結合します。この場合、活性化状態のセマンティクスは「位置アクチュエータのセットポイント」であり、制御信号のセマンティクスは「位置アクチュエータのセットポイントの速度」です。実際のロボットシステムでは、この積分速度アクチュエータが、速度セマンティクスを持つアクチュエータの最も一般的な実装であり、速度に対する純粋なフィードバックではないことに注意してください。これは、実生活とシミュレーションの両方でしばしば非常に不安定です。

積分速度アクチュエータの場合、活性化状態を *クランプ* することが望ましいことがよくあります。そうしないと、位置ターゲットがジョイント限界を超えて積分し続け、制御可能性が失われるためです。活性化クランプの効果を確認するには、以下のサンプルモデルを読み込んでください：

.. collapse:: 活性化制限のあるサンプルモデル

   .. code-block:: xml

      <mujoco>
      <default>
         <joint axis="0 0 1" limited="true" range="-90 90" damping="0.3"/>
         <geom size=".1 .1 .1" type="box"/>
      </default>

      <worldbody>
         <body>
            <joint name="joint1"/>
            <geom/>
         </body>
         <body pos=".3 0 0">
            <joint name="joint2"/>
            <geom/>
         </body>
      </worldbody>

      <actuator>
         <general name="unclamped" joint="joint1" gainprm="1" biastype="affine"
            biasprm="0 -1" dyntype="integrator"/>
         <intvelocity name="clamped" joint="joint2" actrange="-1.57 1.57"/>
      </actuator>
      </mujoco>

:at:`actrange` 属性は、ジョイント範囲が度数（デフォルト）かラジアンかに関係なく、常にネイティブ単位（ラジアン）で指定されることに注意してください。これは :ref:`compiler/angle <compiler>` 属性に依存します。

.. _CMuscle:

マッスル
''''''''

生物学的マッスルをモデル化するための一連のツールを提供しています。最小限の労力でマッスルを追加したいユーザーは、アクチュエータセクションでXMLの1行でそれを行うことができます：

.. code-block:: xml

   <actuator>
       <muscle name="mymuscle" tendon="mytendon">
   </actuator>

生物学的マッスルは互いに非常に異なって見えますが、特定のスケーリングを適用すると、驚くほど類似した動作をします。デフォルト設定では、このようなスケーリングを適用するため、パラメータを調整せずに合理的なマッスルモデルを取得できます。もちろん、より詳細なモデルを構築するには、このセクションで説明するように、パラメータの調整が必要です。

マッスルモデルは非常に精巧ですが、それでもMuJoCoアクチュエータの一種であり、他のすべてのアクチュエータと同じ規則に従うことを覚えておいてください。マッスルは :ref:`general <actuator-general>` を使用して定義できますが、ショートカット :ref:`muscle <actuator-muscle>` の方が便利です。他のすべてのアクチュエータと同様に、力の生成メカニズムと伝達は独立して定義されます。それにもかかわらず、マッスルはテンドンまたはジョイント伝達に接続されている場合にのみ（生物）物理的な意味を持ちます。具体性のために、ここではテンドン伝達を仮定します。

まず、長さと長さのスケーリングについて説明します。伝達（すなわち、MuJoCoテンドン）の実行可能な長さの範囲は重要な役割を果たします。上記の :ref:`Length range <CLengthRange>` セクションを参照してください。バイオメカニクスでは、マッスルとテンドンは直列に接続され、マッスル-テンドンアクチュエータを形成します。私たちの規則は多少異なります。MuJoCoでは、空間的特性（特に長さと速度）を持つエンティティはテンドンであり、マッスルはテンドンを引っ張る抽象的な力生成メカニズムです。したがって、MuJoCoのテンドン長は、バイオメカニクスにおけるマッスル+テンドン長に対応します。生物学的テンドンは非弾性で、定数長 :math:`L_T` を持つと仮定し、一方、生物学的マッスル長 :math:`L_M` は時間とともに変化します。MuJoCoのテンドン長は、生物学的マッスルとテンドンの長さの合計です：

.. math::
   \texttt{actuator\_length} = L_T + L_M

もう1つの重要な定数は、マッスルの最適な静止長であり、 :math:`L_0` と表記されます。これは、マッスルが速度ゼロで最大活性力を生成する長さ :math:`L_M` に等しいです。 :math:`L_0` と :math:`L_T` を直接指定するようにユーザーに求めることはありません。なぜなら、テンドンルーティングとラッピングの空間的複雑さを考えると、それらの数値を知ることは困難だからです。代わりに、 :math:`L_0` と :math:`L_T` を次のように自動的に計算します。上記で説明した長さ範囲の計算により、 :math:`L_T+L_M` の動作範囲がすでに提供されています。さらに、（まだ不明な）定数 :math:`L_0` でスケーリングされたマッスル長 :math:`L_M` の動作範囲を指定するようにユーザーに求めます。これは属性rangeで行われます。デフォルトのスケーリングされた範囲は :math:`(0.75, 1.05)` です。これで、実際の範囲とスケーリングされた範囲が互いにマップする必要があるという事実を使用して、2つの定数を計算できます：

.. math::
   \begin{aligned}
   (\texttt{actuator\_lengthrange[0]} - L_T) / L_0 &= \texttt{range[0]} \\
   (\texttt{actuator\_lengthrange[1]} - L_T) / L_0 &= \texttt{range[1]} \\
   \end{aligned}

ランタイム時に、スケーリングされたマッスル長と速度を次のように計算します：

.. math::
   \begin{aligned}
   L &= (\texttt{actuator\_length} - L_T) / L_0 \\
   V &= \texttt{actuator\_velocity} / L_0 \\
   \end{aligned}

スケーリングされた量の利点は、すべてのマッスルがその表現で同様に動作することです。この動作は、多くの実験論文で測定されたForce-Length-Velocity (:math:`\text{\small FLV}`) 関数によって捉えられます。この関数を次のように近似します：

.. image:: images/modeling/musclemodel.png
   :width: 650px
   :align: center
   :class: only-light

.. image:: images/modeling/musclemodel_dark.png
   :width: 650px
   :align: center
   :class: only-dark

関数は次の形式です：

.. math::
   \text{\small FLV}(L, V, \texttt{act}) = F_L(L)\cdot F_V(V)\cdot \texttt{act} + F_P(L)

MuJoCoアクチュエータの一般的な形式と比較すると、 :math:`F_L\cdot F_V` がアクチュエータゲインであり、 :math:`F_P` がアクチュエータバイアスであることがわかります。 :math:`F_L` は長さの関数としての活性力であり、 :math:`F_V` は速度の関数としての活性力です。これらは、全体的な活性力を取得するために乗算されます（actによるスケーリングに注意してください。これはアクチュエータの活性化です）。 :math:`F_P` は、活性化に関係なく常に存在する受動力です。 :math:`\text{\small FLV}` 関数の出力は、スケーリングされたマッスル力です。スケーリングされた力にマッスル固有の定数 :math:`F_0` を乗算して、実際の力を取得します：

.. math::
   \texttt{actuator\_force} = -\text{\small FLV}(L, V, \texttt{act}) \cdot F_0

負の符号は、正のマッスル活性化が引っ張り力を生成するためです。定数 :math:`F_0` は、速度ゼロでのピーク活性力です。これはマッスルの厚さ（すなわち、生理学的断面積またはPCSA）に関連しています。既知の場合、要素 :ref:`muscle <actuator-muscle>` の属性forceで設定できます。不明な場合、デフォルトである :math:`-1` に設定します。この場合、より大きなマッスルは、より多くの重量を動かすジョイントに作用する傾向があるという事実に依存します。属性scaleは、この関係を次のように定義します：

.. math::
   F_0 = \text{scale} / \texttt{actuator\_acc0}

量 :math:`\texttt{actuator\_acc0}` は、モデルコンパイラによって事前計算されます。これは、アクチュエータ伝達に作用する単位力によって引き起こされるジョイント加速度のノルムです。直感的には、 :math:`\text{scale}` はマッスルが「平均して」どれだけ強いかを決定し、その実際の強度はモデル全体のジオメトリと慣性特性に依存します。

これまでに、個々のマッスルの特性を定義する3つの定数に遭遇しました： :math:`L_T, L_0, F_0`。さらに、 :math:`\text{\small FLV}` 関数自体には、上の図に示されているいくつかのパラメータがあります： :math:`l_\text{min}, l_\text{max}, v_\text{max}, f_\text{pmax}, f_\text{vmax}`。これらはすべてのマッスルで同じであると想定されていますが、異なる実験論文はFLV関数の異なる形状を示唆しているため、その文献に精通しているユーザーはそれらを調整したい場合があります。上の図を生成するために使用されたMATLAB関数 `FLV.m <_static/FLV.m>`__ を提供しており、 :math:`\text{\small FLV}` 関数を計算する方法を示しています。

より正確な :math:`\text{\small FLV}` 関数を設計するミッションに着手する前に、マッスルの動作範囲が :math:`\text{\small FLV}` 関数の形状よりも大きな効果を持ち、多くの場合、このパラメータは不明であるという事実を考慮してください。以下はグラフィカルな図です：

.. image:: images/modeling/musclerange.png
   :width: 500px
   :align: center
   :class: only-light

.. image:: images/modeling/musclerange_dark.png
   :width: 500px
   :align: center
   :class: only-dark

この図の形式は、バイオメカニクス文献で一般的であり、各マッスルの動作範囲を正規化された :math:`\text{FL}` 曲線に重ねて示しています（垂直変位を無視）。デフォルトの範囲は黒で表示されています。青い曲線は、2つのアームマッスルの実験データです。小さな範囲のマッスル、大きな範囲のマッスル、 :math:`\text{FL}` 曲線の上昇部分にまたがる範囲、または下降部分、または両方の一部を見つけることができます。今、50個のマッスルを持つモデルがあるとします。誰かが注意深い実験を行い、モデルのすべてのマッスルの動作範囲を測定し、マッスルがまたがるすべてのジョイントを考慮に入れたと信じますか？そうでない場合、筋骨格モデルは、さまざまな詳細で異なりながら、生物学的システムと同じ一般的な動作を持つと考える方が良いです。これには、一部の研究コミュニティにとって非常に興味深い詳細が含まれます。モデラーが定数で既知であると考えるほとんどのマッスル特性について、それらがいくつかの条件下で変化することを示す実験論文があります。これは、人々が正確なモデルを構築することを妨げるものではありませんが、むしろ、人々が自分のモデルを過度に信じることを妨げるものです。

マッスルモデルに戻ると、マッスル活性化 ``act`` があります。これは、制御信号が入力である1次非線形フィルターの状態です。フィルターダイナミクスは次のとおりです：


.. math::
   \frac{\partial}{\partial t}\texttt{act} = \frac{\texttt{ctrl} - \texttt{act}}{\tau(\texttt{ctrl}, \texttt{act})}

内部的に、制御信号は、アクチュエータに制御範囲が指定されていない場合でも、[0, 1]にクランプされます。属性timeconstで指定される2つの時定数があります。すなわち、 :math:`\text{timeconst} = (\tau_\text{act},
\tau_\text{deact})` で、デフォルトは :math:`(0.01, 0.04)` です。 `Millard et al. (2013)
<https://doi.org/10.1115/1.4023390>`__ に従って、有効な時定数 :math:`\tau` は、ランタイム時に次のように計算されます：

.. math::
   \tau(\texttt{ctrl}, \texttt{act}) =
   \begin{cases}
      \tau_\text{act} \cdot (0.5 + 1.5\cdot\texttt{act}) & \texttt{ctrl}-\texttt{act} \gt 0 \\
      \tau_\text{deact} / (0.5 + 1.5\cdot\texttt{act}) & \texttt{ctrl} - \texttt{act} \leq 0
   \end{cases}

上記の式は不連続な切り替えを記述しているため、導関数ベースの最適化を使用する場合は望ましくない可能性があります。オプションの平滑化パラメータ :ref:`tausmooth<actuator-muscle-tausmooth>` を導入します。0より大きい場合、切り替えは :ref:`mju_sigmoid` に置き換えられ、範囲 :math:`(\texttt{ctrl}-\texttt{act}) \pm \text{tausmooth}/2` 内で2つの値をスムーズに補間します。

ここで、要素 :ref:`muscle <actuator-muscle>` の属性をまとめます。ユーザーは、バイオメカニクス文献への精通と特定のモデルに関する詳細な測定の可用性に応じて、調整したい場合があります：

Defaults
   組み込みのデフォルトをすべての場所で使用します。このセクションの冒頭で示したように、マッスルをテンドンに接続するだけです。これにより、一般的でありながら合理的なモデルが得られます。
scale
   個々のマッスルの強度がわからないが、すべてのマッスルをより強く、またはより弱くしたい場合は、scaleを調整します。これは、各マッスルに対して個別に調整できますが、 :ref:`default <default>` 要素で一度設定する方が理にかなっています。
force
   個々のマッスルのピーク活性力 :math:`F_0` がわかっている場合は、ここに入力してください。多くの実験論文にこのデータが含まれています。
range
   スケーリングされた長さでのマッスルの動作範囲も、いくつかの論文で入手できます。このような測定がどれほど信頼できるかは不明です（マッスルが多くのジョイントに作用することを考えると）が、それらは存在します。範囲はマッスルによって大きく異なることに注意してください。
timeconst
   マッスルは、遅筋繊維と速筋繊維で構成されています。典型的なマッスルは混合ですが、一部のマッスルは一方または他方の繊維タイプの割合が高く、より速く、またはより遅くなります。これは、時定数を調整することでモデル化できます。 :math:`\text{\small FLV}` 関数のvmaxパラメータも、それに応じて調整する必要があります。
tausmooth
   正の場合、活性化と非活性化の時定数の間の遷移を平滑化します。単一の `motor unit <https://en.wikipedia.org/wiki/Motor_unit>`__ は活性化または非活性化のいずれかですが、マッスル全体は多くのユニットの混合を持ち、対応するタイムスケールの混合につながります。
lmin, lmax, vmax, fpmax, fvmax
   これらは、 :math:`\text{\small FLV}` 関数の形状を制御するパラメータです。上級ユーザーは、それらを実験できます。MATLAB関数 `FLV.m <_static/FLV.m>`__ を参照してください。scale設定と同様に、すべてのマッスルの :math:`\text{\small FLV}` パラメータを変更したい場合は、 :ref:`default <default>` 要素で行います。
Custom model
   マッスルモデルのパラメータを調整する代わりに、ユーザーは、 :ref:`general <actuator-general>` アクチュエータのgaintype、biastype、dyntypeを「user」に設定し、ランタイム時にコールバックを提供することで、異なるモデルを実装できます。または、これらのタイプの一部を「muscle」に設定したままにして、私たちのモデルを使用し、他のコンポーネントを置き換えます。テンドンジオメトリの計算は、標準のMuJoCoパイプラインによって処理され、actuator_length、actuator_velocity、actuator_lengthrangeをユーザーのマッスルモデルへの入力として提供することに注意してください。その後、カスタムコールバックは、弾性テンドンまたは私たちが省略することを選択した他の詳細をシミュレートできます。

**OpenSimとの関係**

バイオメカニクスの研究者が使用する標準的なソフトウェアはOpenSimです。可能な限りOpenSimモデルに類似するようにマッスルモデルを設計しましたが、大幅に高速で安定したシミュレーションをもたらす簡略化を行っています。OpenSimモデルを変換するMuJoCoユーザーを支援するために、ここでは類似点と相違点をまとめます。

活性化ダイナミクスモデルは、デフォルトの時定数を含め、OpenSimと同一です。

:math:`\text{\small FLV}` 関数は、OpenSimとまったく同じではありませんが、MuJoCoとOpenSimの両方が同じ実験データを近似するため、非常に近いです。OpenSimモデルの説明と関連する実験データの要約については、 `Millards et al. (2013) <https://doi.org/10.1115/1.4023390>`__ を参照してください。

テンドンの弾性をモデル化できるOpenSimとは異なり、非弾性テンドンを仮定しています。ここでそれを行わないことに決めました。なぜなら、テンドンの弾性には高速平衡の仮定が必要であり、それにはさまざまな調整が必要で、シミュレーションの不安定性を起こしやすいためです。実際には、テンドンは非常に硬く、その効果は、非弾性ケースに対応する :math:`\text{FL}` 曲線を伸ばすことで近似的に捉えることができます（ `Zajac (1989)
<https://pubmed.ncbi.nlm.nih.gov/2676342/>`__ ）。これは、マッスルの動作範囲を短縮することでMuJoCoで行うことができます。

羽状角（すなわち、マッスルと力の線の間の角度）は、MuJoCoでモデル化されておらず、0であると仮定されます。この効果は、マッスル力をスケールダウンし、動作範囲も調整することで近似できます。

テンドンラッピングも、MuJoCoではより限定的です。球と無限円筒をラッピングオブジェクトとして許可し、2つのラッピングオブジェクトをテンドンパス内の固定サイトで分離する必要があります。これは、テンドンパスの反復計算の必要性を避けるためです。また、球または円筒の内部に「サイドサイト」を配置することもできます。これにより、逆ラップが発生します。テンドンパスは、周りを回るのではなく、オブジェクトを通過するように制約されます。これは、OpenSimで使用されるトーラスラッピングオブジェクトを置き換えて、テンドンパスを特定の領域内に保つことができます。全体として、テンドンラッピングは、OpenSimモデルをMuJoCoモデルに変換する最も困難な部分であり、いくつかの手作業が必要です。明るい面では、使用されている高品質のOpenSimモデルは少数であるため、それらが変換されれば、私たちは完了です。

以下に、利用可能な4種類のテンドンラッピングを示します。ラッピングテンドンの湾曲したセクションはまっすぐにレンダリングされますが、ジオメトリパイプラインは実際の曲線で動作し、それらの長さとモーメントを解析的に計算することに注意してください：

|image3|

.. _CSensor:

センサー
~~~~~~~~

MuJoCoは、以下の :ref:`sensor <sensor>` 要素で説明されているように、多種多様なセンサーをシミュレートできます。ユーザーセンサータイプも定義でき、コールバック :ref:`mjcb_sensor` によって評価されます。センサーはシミュレーションに影響を与えません。代わりに、その出力は配列mjData.sensordataにコピーされ、ユーザー処理に利用できます。

ここでは、後で繰り返しを避けるために、すべてのセンサータイプに共通のXML属性について説明します。

:at:`name`: :at-val:`string, optional`
   センサーの名前。
:at:`noise`: :at-val:`real, "0"`
   このセンサーのノイズモデルの標準偏差。バージョン3.1.4以前では、これによりセンサーにノイズが追加されていました。リリース3.1.4でこの機能は削除されました。詳細な正当化については `3.1.4 changelog <https://mujoco.readthedocs.io/en/stable/changelog.html#version-3-1-4-march-13-2024>`__ を参照してください。それ以降のバージョンでは、この属性は後で使用するための標準偏差情報を保存するための便利な場所として機能します。
:at:`cutoff`: :at-val:`real, "0"`
   この値が正の場合、センサー出力の絶対値を制限します。また、 :ref:`simulate.cc <saSimulate>` のセンサーデータプロットでセンサー出力を正規化するためにも使用されます。
:at:`user`: :at-val:`real(nuser_sensor), "0 0 ..."`
   :ref:`User parameters <CUser>` を参照してください。

.. _CCamera:

カメラ
~~~~~~

デフォルトのユーザー制御可能なフリーカメラの他に、「固定」カメラをキネマティックツリーに接続できます。

Extrinsics
   デフォルトでは、カメラフレームは含まれるボディに接続されます。オプションの :ref:`mode<body-camera-mode>` および :ref:`target<body-camera-target>` 属性を使用して、ボディまたはサブツリーを追跡（一緒に移動）またはターゲット（見る）するカメラを指定できます。カメラはカメラフレームの負のZ軸方向を向き、正のXとYは、それぞれ画像平面の *右* と *上* に対応します。

Intrinsics
   カメラの内部パラメータは、 :ref:`ipd<body-camera-ipd>` （瞳孔間距離、ステレオスコピックレンダリングとVRに必要）と :ref:`fovy<body-camera-fovy>` （垂直視野角、度数）を使用して指定されます。

   上記の仕様は、収差のない完全な点カメラを意味します。ただし、実際のカメラをキャリブレーションする場合、標準のレンダリングパイプラインを使用して表現できる2種類の線形収差があります。1つ目は、垂直方向と水平方向で焦点距離が異なる場合（軸に沿った非点収差）です。2つ目は、中心からずれた主点です。これらは :ref:`focal<body-camera-focal>` および :ref:`principal<body-camera-principal>` 属性を使用して指定できます。これらのキャリブレーション関連の属性を使用する場合、物理的な :ref:`sensor size<body-camera-sensorsize>` とカメラの :ref:`resolution<body-camera-resolution>` も指定する必要があります。この場合、レンダリングの視錐台を可視化できます。

.. _CComposite:

コンポジットオブジェクト
~~~~~~~~~~~~~~~~~~~~~~~~

コンポジットオブジェクトは新しいモデル要素ではありません。代わりに、パーティクルシステム、ロープ、布、ソフトボディをシミュレートするために元々設計された既存の要素のコレクションです。時間の経過とともに、これらのタイプのほとんどは :ref:`replicate<replicate>` （繰り返しオブジェクト用）と :ref:`flexcomp<body-flexcomp>` （ソフトオブジェクト用）に置き換えられました。したがって、現在サポートされている唯一のコンポジットタイプは ``cable`` であり、ボールジョイントで接続された非伸張性のボディチェーンを生成します。

コンポジットオブジェクトは通常のMuJoCoボディで構成されており、このコンテキストでは「要素ボディ」と呼びます。要素ボディのコレクションは、モデルコンパイラによって自動的に生成されます。ユーザーは、XMLリファレンスチャプターで説明されているように、新しいXML要素 :ref:`composite <body-composite>` とその属性およびサブ要素を使用して、自動ジェネレータを高レベルで構成します。コンパイルされたモデルが保存されると、 :el:`composite` は存在せず、自動的に生成された通常のモデル要素のコレクションに置き換えられます。したがって、モデルコンパイラによって展開されるマクロと考えてください。要素ボディは、 :el:`composite` が表示されるボディの子として作成されます。したがって、コンポジットオブジェクトは、通常の子ボディが定義されていた可能性のあるXMLの同じ場所に表示されます。自動生成された各要素ボディには、単一のジオムが接続されています。コンポジットオブジェクトジェネレータは、可能な限り直感的な高レベルコントロールを持つように設計していますが、同時に、互いに相互作用し、結果の物理に深く影響を与える可能性のある多数のオプションを公開しています。したがって、ある時点で、ユーザーは :ref:`reference documentation <body-composite>` を注意深く読む必要があります。

物理のセットアップに加えて、コンポジットオブジェクトジェネレータは適切なレンダリングを作成します。オブジェクトは :ref:`skins <asset-skin>` としてレンダリングできます。スキンは自動的に生成され、バイキュービック補間を使用してテクスチャリングおよび細分化することもできます。実際の物理、特に衝突検出は要素ボディとそのジオムに基づいていますが、スキンは純粋に可視化オブジェクトです。それでも、 `このモデル
<https://github.com/google-deepmind/mujoco/blob/main/model/plugin/elasticity/belt.xml>`__ のように、スキン表現を見る方が好ましい状況もあります。このモデルのスキンは、不連続な薄いボックスのコレクションではなく、連続した柔軟な表面です。ただし、モデルを微調整し、その背後にある物理を理解しようとする場合、ジオムをレンダリングできることが便利です。レンダリングスタイルを切り替えるには、スキンのレンダリングを無効にし、ジオムとテンドンのグループ3を有効にします。

**Cable**。

クイックスタートとして、MuJoCoにはコンポジットケーブルの例が付属しています。すべての例では、モデルに含まれる静的シーンの後に、単一のコンポジットオブジェクトが続きます。以下のXMLスニペットは、コンポジットオブジェクトの定義のみです。完全な例については、配布物のXMLモデルファイルを参照してください。

|coil|

.. code-block:: xml

   <extension>
      <plugin plugin="mujoco.elasticity.cable"/>
   </extension>

   <worldbody>
      <composite prefix="actuated" type="cable" curve="cos(s) sin(s) s" count="41 1 1"
                 size="0.25 .1 4" offset="0.25 0 .05" initial="none">
         <plugin plugin="mujoco.elasticity.cable">
            <!--Units are in Pa (SI)-->
            <config key="twist" value="5e8"/>
            <config key="bend" value="15e8"/>
            <config key="vmax" value="0"/>
         </plugin>
         <joint kind="main" damping="0.15" armature="0.01"/>
         <geom type="capsule" size=".005" rgba=".8 .2 .1 1"/>
      </composite>
   </worldbody>

ケーブルは、ねじり剛性と曲げ剛性を持つ非伸張性の弾性1Dオブジェクトをシミュレートします。カプセルまたはボックスのシーケンスを使用して離散化されます。その剛性と慣性特性は、与えられたパラメータと断面の形状から直接計算され、ベルトやコンピュータケーブルなどに見られる異方性の動作を可能にします。これは単一のキネマティックツリーであるため、追加の制約を使用せずに正確に非伸張性であり、大きなタイムステップの使用を可能にします。弾性モデルは幾何学的に正確であり、中心線（すなわち、断面の中心を通過する線）のビショップフレームまたはねじれのないフレームを計算することに基づいています。ジオムの向きはこのフレームに対して表現され、その後、ねじりと曲げ成分に分解されるため、異なる剛性を独立して設定できます。さらに、コイルスプリングの場合のように、応力のない構成が平坦か曲線かを指定できます。ケーブルは、ファーストパーティの :ref:`engine plugin<exPlugin>` を使用する必要があり、将来エンジンに直接統合される可能性があります。

**Particle**。

パーティクルタイプは非推奨です。例えば `このモデル <https://github.com/google-deepmind/mujoco/blob/main/model/replicate/particle.xml>`__ のように、より汎用的な :ref:`replicate<replicate>` を使用することをお勧めします。

**Grid**。

グリッドコンポジットタイプは削除されました。薄い弾性構造をシミュレートするには、2D flex :ref:`deformable objects <CDeformable>` を使用することをお勧めします。

**Rope and loop**。

ロープとループは非推奨です。曲げられ、ねじられた非伸張性の弾性ロッドをシミュレートするにはケーブルを使用し、引張荷重シナリオ（例：引き伸ばされたゴムバンド）での伸張可能な弦には1D flex :ref:`deformable objects <CDeformable>` を使用することをお勧めします。

**Cloth**。

布は非推奨です。薄い弾性構造をシミュレートするには、2D flex :ref:`deformable objects <CDeformable>` を使用することをお勧めします。

**Box, cylinder and ellipsoid**。


ボックスタイプ、および円筒と楕円体タイプは、3D flex :ref:`deformable
objects <CDeformable>` 要素を優先して非推奨になりました。

.. _CDeformable:

変形可能オブジェクト
~~~~~~~~~~~~~~~~~~~~

先に説明した :ref:`コンポジットオブジェクト <CComposite>` は、実質的に剛体シミュレータである中で柔軟体をエミュレートすることを意図していました。これはMuJoCoの制約が柔軟であるため可能でしたが、それでも機能とモデリング能力には限界がありました。MuJoCo 3.0では、新しいモデル要素を含む真の変形可能オブジェクトを導入しました。先に説明した :ref:`スキン<deformable-skin>` は実際にそのような要素の1つでしたが、単に可視化のために使用されるものです。現在、関連する要素として :ref:`フレックス<deformable-flex>` があり、これは接触力、制約力、および受動力を生成し、広範囲の変形可能エンティティをモデリングするために必要とされます。スキンとフレックスの両方が、XML内で :ref:`deformable<deformable>` と呼ばれる新しいグループ化要素内に定義されるようになりました。フレックスは、ランタイムに必要なすべてを指定する低レベル要素ですが、モデリング時に設計するのは困難です。モデリングを支援するため、さらに要素 :ref:`flexcomp<body-flexcomp>` を導入しました。これは低レベルのフレックスの作成を自動化するもので、 :ref:`composite<body-composite>` が柔軟体をエミュレートするために必要なMuJoCoオブジェクトの（コレクション）作成を自動化する方法に似ています。フレックスは最終的にコンポジットに取って代わる可能性がありますが、現時点では両方がやや異なる目的で有用です。

フレックスは、質量のない伸縮可能な要素で接続されたMuJoCoボディのコレクションです。これらの要素は、カプセル（1Dフレックス）、三角形（2Dフレックス）、または四面体（3Dフレックス）のいずれかになります。すべてのケースで半径を許容し、これにより要素が滑らかになり、1Dおよび2Dでも体積を持つようになります。基本要素を以下に示します：

.. image:: images/modeling/flexelem.png
   :width: 600px
   :align: center

これまでのところ、これらはジオムのように見えます。しかし重要な違いは、これらが変形することです：ボディ（頂点）が互いに独立して移動すると、要素の形状がリアルタイムで変化します。衝突と接触力は、これらの変形可能な幾何要素を扱うように一般化されました。2つのそのような要素が衝突する場合、接触は2つのボディだけでなく、最大8つのボディ（両方の要素が四面体の場合）を含む可能性があることに注意してください。接触力は、接触フレームとそのフレームで表現された関連する量が与えられた場合、以前と同様に計算されます。しかし、その後接触力はすべての相互作用するボディに分散されます。接触点がどのボディフレームにも固定されているとは見なせないため、接触ヤコビアンの概念は複雑になります。代わりに、各接触点を複数のボディに「割り当てる」ための重み付けスキームを使用します。すべての頂点を同じボディに割り当てることで、剛体フレックスを作成することも可能です。これは、新しいフレックス衝突機構を再利用して、剛体の非凸メッシュ衝突を実装する方法です（衝突目的のために凸化されるメッシュジオムとは異なります）。

**変形モデル**

フレックスの形状を（柔軟な意味で）保持するためには、受動力または制約力を生成する必要があります。MuJoCo 3.0より前は、これには多数のテンドンに加えて、テンドンとジョイントに対する制約が必要でした。これはここでも可能ですが、フレックスが大きい場合はモデリングとシミュレーションの両方の観点から非効率的です。代わりに、設計哲学は単一のパラメータセットを使用し、2つのモデリング選択肢を提供することです：特定のフレックスのすべてのエッジに適用される新しい（柔軟な）等式制約タイプで、大きなタイムステップを許容するもの、または離散化された連続体表現で、各要素が一定の応力状態にあり、これは区分線形有限要素と同等であり、改善された現実性と精度を達成します。エッジベースのモデルは、「集中」剛性モデルと見なすことができ、変形モードの正しい結合（例えば、せん断と体積の）が単一の量で平均化されます。連続体モデルは、材料の `ポアソン比 <https://en.wikipedia.org/wiki/Poisson%27s_ratio>`__ を使用して、せん断剛性と体積剛性を個別に指定することを可能にします。詳細については、 `Saint Venant-Kirchhoff <https://en.wikipedia.org/wiki/Hyperelastic_material#Saint_Venant%E2%80%93Kirchhoff_model>`__ 超弾性モデルを参照してください。

**作成と可視化**

.. code-block:: xml

   <option timestep=".001"/>

   <worldbody>
      <flexcomp type="grid" count="24 4 4" spacing=".1 .1 .1" pos=".1 0 1.5"
                radius=".0" rgba="0 .7 .7 1" name="softbody" dim="3" mass="7">
         <contact condim="3" solref="0.01 1" solimp=".95 .99 .0001" selfcollide="none"/>
         <edge damping="1"/>
         <elasticity poisson="0.2" young="5e4">
      </flexcomp>
   </worldbody>

:ref:`flexcomp<body-flexcomp>` 要素を使用すると、四面体メッシュを含むメッシュからフレックスを作成し、すべてのボディ/頂点を自動的に生成し、適切な要素で接続できます。また、グリッドやその他のトポロジーを自動的に作成することもできます。この機構により、数千または数万のボディ、要素、エッジを含む非常に大きなフレックスを簡単に作成できます。明らかに、そのようなシミュレーションは高速ではありません。中規模のフレックスであっても、衝突ペアの枝刈りが不可欠です。これが、自己衝突の枝刈りのための精巧な方法を開発した理由です。XMLリファレンスを参照してください。

四面体で構成される3Dフレックスの場合、フレックスが内部的にどのように「三角形分割」されているかを調べると役立つ場合があります。外側の層を剥がす特別な可視化モードがあります。以下はStanford Bunnyの例です。外側に小さい四面体があり、内側に大きい四面体がある様子に注意してください。このメッシュ設計は理にかなっています。なぜなら、衝突表面を正確にしたいが、内部では柔らかい材料特性だけが必要だからです。これには空間解像度が少なくて済みます。表面メッシュを四面体メッシュに変換するには、 `fTetWild library <https://github.com/wildmeshing/fTetWild>`__ などのオープンツールをお勧めします。

|bunny1| |bunny2|


.. _CInclude:

ファイルのインクルード
~~~~~~~~~~~~~~~~~~~~~~

MJCFファイルは、 :ref:`include <include>` 要素を使用して他のXMLファイルをインクルードできます。機構的には、パーサーはマスターファイル内のinclude要素に対応するDOMノードを、インクルードされたファイル内のトップレベル要素の子であるXML要素のリストで置き換えます。トップレベル要素自体は破棄されます。なぜなら、それはXML目的のグループ化要素であり、インクルードされるとMJCFフォーマットに違反するからです。

この機能により、モジュラーMJCFモデルが可能になります。モデルライブラリのMPLファミリーのモデルを参照してください。モジュール性の一例は、ロボットのモデル（これは通常精巧です）を構築し、それを複数の「シーン」、つまりロボットの環境内のオブジェクトを定義するMJCFモデルにインクルードすることです。別の例は、よく使用されるアセット（例えば、慎重に調整されたrgba値を持つマテリアル）を含むファイルを作成し、それらのアセットを参照する複数のモデルにインクルードすることです。

インクルードされたファイルは、それ自体で有効なMJCFファイルである必要はありませんが、通常はそうです。実際、私たちはこの機構を、MJCFモデルを他のMJCFモデルにインクルードできるように設計しました。これを可能にするため、単一のモデルのコンテキストで意味的に意味をなさない場合でも、繰り返されるMJCFセクションが許可されます。例えば、キネマティックツリーが複数のルート（つまり、複数の :el:`worldbody` 要素）を持つことを許可し、これらはパーサーによって自動的にマージされます。そうでなければ、ロボットをシーンにインクルードすることは不可能でしょう。

繰り返されるMCJFセクションの柔軟性には代償があります：モデル全体に適用されるグローバル設定、例えば :ref:`compiler <compiler>` の :at:`angle` 属性などは、複数回定義できます。MuJoCoはこれを許可し、すべてのinclude要素が処理された後、複合モデルで遭遇した最後の定義を使用します。したがって、モデルAが度数で定義され、モデルBがラジアンで定義され、AがBの :el:`compiler` 要素の後にBにインクルードされる場合、複合モデル全体は度数で定義されたかのように扱われ、この場合は望ましくない結果につながります。ユーザーは、互いにインクルードされるモデルがこの意味で互換性があることを確認する必要があります。ローカル座標とグローバル座標の違いも、もう1つの互換性要件です。

最後に、次に説明するように、要素名は同じタイプのすべての要素の中で一意でなければなりません。したがって、例えば同じジオム名が2つのモデルで使用され、1つのモデルが他方にインクルードされる場合、これはコンパイルエラーになります。同じXMLファイルを複数回インクルードすることは解析エラーです。この制限の理由は、繰り返される要素名とインクルードによる無限再帰を避けたいためです。

.. _CName:

要素の命名
~~~~~~~~~~~~~~~

MJCFのほとんどのモデル要素は名前を持つことができます。名前は、対応するXML要素の :at:`name` 属性で定義されます。特定のモデル要素に名前が付けられている場合、その名前は同じタイプのすべての要素の中で一意でなければなりません。名前は大文字と小文字を区別します。名前はコンパイル時に対応する要素を参照するために使用され、ランタイムにユーザーの便宜のためにmjModelにも保存されます。

名前は通常オプションの属性です。特定の理由がない限り、未定義のままにしておく（モデルファイルを短く保つため）ことをお勧めします。いくつかの理由が考えられます：

-  一部のモデル要素は、作成の一部として他の要素を参照する必要があります。例えば、空間テンドンは、通過する経由点を指定するためにサイトを参照する必要があります。参照は名前によってのみ実行できます。アセットは参照される目的のためだけに存在するため、名前を持つ必要があることに注意してください。ただし、対応するファイル名から暗黙的に設定することで省略できます。
-  ビジュアライザーは、特定のタイプのすべてのモデル要素にラベルを付けるオプションを提供します。名前が利用可能な場合、3Dビューでオブジェクトの横に出力されます。そうでない場合、「body 7」の形式の汎用ラベルが出力されます。
-  関数 :ref:`mj_name2id` は、指定されたタイプと名前を持つモデル要素のインデックスを返します。逆に、関数 :ref:`mj_id2name` はインデックスが与えられた場合に名前を返します。これは、XML内で名前によって識別されるモデル要素を含むカスタム計算に役立ちます（モデルが編集されると変更される可能性のある固定インデックスに依存するのとは対照的に）。
-  モデルファイルは、特定の要素に名前を付けることで、原理的にはより読みやすくなる可能性があります。ただし、XML自体にコメント機構があり、その機構は読みやすさを達成するのに適していることに留意してください。特に、ほとんどのテキストエディタがXMLコメントを検出する構文強調表示を提供しているためです。

.. _CURDF:

URDF拡張
~~~~~~~~~~~~~~~

Unified Robot Description Format（URDF）は、多くの既存のロボットがモデリングされている人気のあるXMLファイルフォーマットです。これが、MuJoCoで利用可能なモデル要素のサブセットしか表現できないにもかかわらず、URDFのサポートを実装した理由です。標準のURDFファイルに加えて、MuJoCoは、トップレベル要素 :el:`robot` の子としてカスタム（URDFの観点から）の :el:`mujoco` 要素を持つファイルをロードできます。このカスタム要素は、MJCFと同じ機能を持つサブ要素 :ref:`compiler <compiler>`、 :ref:`option <option>`、 :ref:`size <size>` を持つことができます。ただし、デフォルトのコンパイラ設定は、URDFモデリング規約に対応するように変更されています。特に :ref:`compiler <compiler>` 拡張は非常に有用であることが証明されており、実際、その属性のいくつかは、多くの既存のURDFモデルが非物理的な動力学パラメータを持っているために導入されました。これらはMuJoCoの組み込みコンパイラが変更されないままだと拒否します。この拡張は、メッシュディレクトリを指定するためにも必要です。また、コンパイラ属性 :ref:`strippath<compiler-strippath>`、 :ref:`angle<compiler-angle>`、 :ref:`fusestatic<compiler-fusestatic>`、 :ref:`discardvisual<compiler-discardvisual>` は、URDFとMJCFで異なるデフォルト値を持つことに注意してください。

MJCFモデルはパーサーによってカスタムXMLスキーマに対してチェックされますが、URDFモデルはチェックされないことに注意してください。URDFファイルに埋め込まれたMuJoCo固有の要素もチェックされません。その結果、誤って入力された属性名は静かに無視され、誤字に気付かないままだと大きな混乱を引き起こす可能性があります。

URDFモデルの拡張セクションの例を次に示します：

.. code-block:: xml

   <robot name="darwin">
     <mujoco>
       <compiler meshdir="../mesh/darwin/" balanceinertia="true" discardvisual="false"/>
     </mujoco>
     <link name="MP_BODY">
       ...
   </robot>

上記の拡張により、URDFはより使いやすくなりますが、それでも制限されています。ユーザーがMuJoCoを最大限に活用したモデルを構築し、同時にURDF互換性を維持したい場合、次の手順をお勧めします。必要に応じてURDFに拡張を導入し、それをロードしてMJCFとして保存します。次に、可能な限り :ref:`include <include>` 要素を使用してMJCFに情報を追加します。このようにすれば、URDFが変更された場合、対応するMJCFを簡単に再作成できます。しかし、私たちの経験では、URDFファイルは静的である傾向があり、MJCFファイルは頻繁に編集されます。したがって、実際には通常、URDFをMJCFに一度変換し、その後はMJCFのみで作業すれば十分です。

.. _CMocap:

MoCapボディ
~~~~~~~~~~~~

``mocap`` ボディは、ワールドの静的な子（つまり、ジョイントを持たない）であり、その :at:`mocap` 属性が"true"に設定されています。これらは、モーションキャプチャデバイスからのデータストリームをMuJoCoシミュレーションに入力するために使用できます。VRコントローラーや、モーションキャプチャマーカー（例えばVicon）で計測されたオブジェクトを手に持っていて、シミュレートされたオブジェクトが同じように動きながら他のシミュレートされたオブジェクトとも相互作用するようにしたいとします。ここにはジレンマがあります：仮想オブジェクトは物理的な手を押すことができないため、手（およびそれによって制御しているオブジェクト）はシミュレートされた物理を侵害する可能性があります。しかし同時に、結果のシミュレーションが合理的であることを望みます。どうすればよいでしょうか？

最初のステップは、MJCFモデルでmocapボディを定義し、ランタイムにデータストリームを読み取り、mjModel.mocap_posとmjModel.mocap_quatをモーションキャプチャシステムから受信した位置と向きに設定するコードを実装することです。 :ref:`simulate.cc <saSimulate>` コードサンプルは、マウスをモーションキャプチャデバイスとして使用し、ユーザーがmocapボディを動かせるようにします：

|particle|

mocapボディについて理解すべき重要なことは、シミュレーターがそれらを固定されたものとして扱うことです。シミュレーションタイムステップから次へと、位置と向きを直接更新することでそれらを移動させていますが、物理モデルに関する限り、それらの位置と向きは一定です。では、通常の動的ボディと接触を起こすとどうなるでしょうか？MuJoCoディストリビューションで提供されている粒子の例を思い出してください（これらの例では、マウスで動かすmocapボディであるカプセルプローブがあります）。2つの通常のボディ間の接触は、貫通と相対速度の両方を経験しますが、mocapボディとの接触は相対速度成分が欠けています。なぜなら、シミュレーターはmocapボディ自体が移動していることを知らないからです。したがって、結果の接触力は小さく、接触が動的オブジェクトを押しのけるのに時間がかかります。また、より複雑なシミュレーションでは、物理と矛盾することをしているという事実が不安定性を引き起こす可能性があります。

しかし、より良い動作をする代替手段があります。mocapボディに加えて、2番目の通常のボディを含め、それをweld等式制約でmocapボディに接続します。以下のプロットでは、ピンクのボックスがmocapボディであり、手のベースに接続されています。他の制約がない場合、手はmocapボディをほぼ完璧に追跡します（バネ・ダンパーよりもはるかに良く）。なぜなら、制約は暗黙的に処理され、シミュレーションを不安定にすることなく大きな力を生成できるからです。しかし、手がテーブルと接触せざるを得ない場合（右のプロット）、接触制約とmocapボディの追跡を同時に尊重することはできません。これは、mocapボディがテーブルを貫通する自由があるためです。では、どちらの制約が勝つのでしょうか？それは、接触制約に対するweld制約の柔軟性に依存します。対応する :at:`solref` および :at:`solimp` パラメータを調整して、望ましいトレードオフを達成する必要があります。例については、MuJoCo Forumで入手可能なModular Prosthetic Limb（MPL）ハンドモデルを参照してください。以下のプロットはそのモデルで生成されています。

|image18| |image19|

.. _CSize:

メモリ割り当て
~~~~~~~~~~~~~~~~~

MuJoCoは、ランタイムに必要なすべてのメモリを :ref:`mjData` に事前割り当てし、モデル作成後にヒープアロケーターにアクセスしません。 :ref:`mjData` のメモリは、 :ref:`mj_makeData` によって2つの連続したブロックに割り当てられます：

- ``mjData.buffer`` には固定サイズの配列が含まれます。
- ``mjData.arena`` には動的サイズの配列が含まれます。

``arena`` メモリ空間に割り当てられる動的配列には2つのタイプがあります。

- 接触および制約関連の配列は、 ``arena`` の先頭から配置されます。
- :ref:`スタック <siStack>` 配列は、 ``arena`` の末尾から配置されます。

``arena`` 空間の両端から動的量を割り当てることにより、可変サイズのメモリ割り当ては単一の数値によって制御されます： :ref:`size <size>` MJCF要素の :at:`memory` 属性。 ``buffer`` 内の固定サイズ配列とは異なり、arenaの可変サイズ配列は ``NULL`` になる可能性があります。例えば、 :ref:`mj_resetData` の呼び出し後などです。 ``arena`` メモリが不足した場合、要求されたメモリのタイプに応じて、3つのうちの1つが発生します：

- 接触割り当て中にメモリが不足した場合、警告が発生し、後続の接触はこのステップで追加されませんが、シミュレーションは通常通り継続します。
- 制約関連の割り当て中にメモリが不足した場合、警告が発生し、このステップで制約ソルバーが無効になりますが、シミュレーションは通常通り継続します。制約ソルバーなしの物理は一般に非常に異なることに注意してください。しかし、シミュレーションを継続できることは、多くのボディが一時的に重なっているシーン初期化中などで依然として役立ちます。
- スタック配列の割り当て中にメモリが不足した場合、ハードエラーが発生します。

``buffer`` のサイズとは異なり、 ``arena`` のサイズは事前に計算できません。なぜなら、接触の数とスタック使用量は事前にわからないからです。では、どのように選択すべきでしょうか？現在、次の簡単なヒューリスティックが使用されていますが、将来改善される可能性があります：100個の接触と500個のスカラー制約に十分なメモリが、最悪の条件下で割り当てられます。このヒューリスティックが不十分な場合、次の手順をお勧めします。 :at:`memory` 属性を使用して ``arena`` メモリを大幅に増やし、ランタイムに実際に使用されるメモリを検査します。 ``mjData.maxuse_arena`` は、最後のリセット以降の最大 ``arena`` メモリ使用率を追跡します。 :ref:`simulate <saSimulate>` ビューアーは、この数値を総arena空間の分数として表示します（左下の情報ウィンドウ）。したがって、大きな数値で開始し、しばらくシミュレートし、分数が小さければXMLに戻って割り当てサイズを減らすことができます。ただし、メモリ使用率はシミュレーションの過程で劇的に変化する可能性があることに留意してください。これは、アクティブな制約の数と使用される制約ソルバーによって異なります。CGソルバーは最もメモリ効率が良く、次にニュートンソルバー、PGSソルバーが最もメモリ集約的です。モデルを設計するとき、通常、モデルを探索している間に遭遇する最悪のシナリオで50％の使用率を目指します。CGソルバーのみを使用する予定の場合、かなり小さいarena割り当てで済ませることができます。

.. attention::

   メモリ割り当ての動作はMuJoCo 2.3.0で変更されました。このバージョンより前では、 :ref:`size <size>` MJCF要素の :at:`njmax`、 :at:`nconmax`、 :at:`nstack` 属性は、接触、制約、スタックに割り当てられる最大メモリのセマンティクスを持っていました。それ以前のバージョンのMuJoCoを使用している場合は、以前の動作について読むために `以前の <https://mujoco.readthedocs.io/en/2.2.2/modeling.html#model-sizes>`_ ドキュメントバージョンに切り替えてください。

.. _Tips:

ヒントとテクニック
------------------

ここでは、いくつかの一般的なモデリングタスクを達成する方法についてのガイダンスを提供します。このセクションに新しい内容はありません。つまり、このセクションのすべては、ドキュメントの残りの部分から推論できます。それでも、推論プロセスは必ずしも明白ではないため、明示的に説明することが有用な場合があります。

.. _CPerformance:

パフォーマンスチューニング
~~~~~~~~~~~~~~~~~~~~~~~~~~

シミュレーションのスループットを最大化するために実行できるステップのリストを以下に示します。すべての推奨事項はパラメータの調整に関するものです。 :ref:`simulate<saSimulate>` ユーティリティの組み込みプロファイラーを見ながら、インタラクティブな方法で実行することをお勧めします。より詳細で有用なプロファイルは、 :ref:`testspeed<saTestspeed>` ユーティリティによっても報告されます。以下のより精巧なステップに着手する際は、プロファイラーによって報告された最も高価なパイプラインコンポーネントをターゲットにしてください。これらのいくつかはMJXではわずかに異なることに注意してください。 :ref:`専用のセクション<MjxPerformance>` を参照してください。

1. :ref:`Timestep<option-timestep>`: シミュレーションタイムステップを増やしてみてください。 :ref:`数値積分<geIntegration>` セクションの最後で説明されているように、タイムステップはどのモデルでも最も重要なパラメータです。デフォルト値は効率性よりも安定性のために選択されており、多くの場合増やすことができます。ある時点で、さらに増やすと発散が発生するため、最適なタイムステップは、発散が起こらないか非常にまれな最大のタイムステップです。実際の値はモデルに依存します。
2. :ref:`Integrator<option-integrator>`: :ref:`数値積分<geIntegration>` セクションの最後にある推奨事項に従って積分器を選択してください。デフォルトの推奨選択は ``implicitfast`` 積分器です。
3. :ref:`Constraint Jacobians<option-jacobian>`: ヤコビアン設定を「dense」と「sparse」の間で切り替えてみてください。これら2つのオプションは、密または疎な代数を使用する別々のコードパスを使用しますが、計算的には同一であるため、常により速い方が好まれます。デフォルトの「auto」ヒューリスティックは常に正しい選択をするとは限りません。
4. **制約ソルバー:** プロファイラーがソルバーに多くの時間が費やされていることを報告している場合、以下を検討してください：

   - :ref:`solver<option-solver>`: デフォルトのニュートンは、収束するために必要な反復回数が最も少ないため、多くの場合最速のソルバーです。大きなモデルの場合、CGソルバーの方が速い可能性があり、制約よりも自由度が多いモデルの場合、PGSソルバーが最速ですが、この状況は一般的ではありません。
   - :ref:`iterations<option-iterations>` および :ref:`tolerance<option-tolerance>`: 反復回数を減らすか、同等に、ソルバーの終了許容誤差を増やしてみてください。特に、通常2〜3回の（高価な）反復で数値収束を達成するニュートンソルバーの場合、最後の反復は目立った効果のないレベルまで精度を高めるため、スキップできます。
5. **衝突:** プロファイラーが衝突検出が計算時間の大部分を占めていることを報告している場合、以下のステップを検討してください：

   - :ref:`衝突検出<Collision>` セクションで説明されている :ref:`contype<body-geom-contype>` / :ref:`conaffinity<body-geom-conaffinity>` 機構を使用して、チェックされる衝突の数を減らします。
   - 衝突ジオメトリを変更し、高価な衝突テスト（例：メッシュとメッシュ）をより安価なプリミティブ対プリミティブの衝突に置き換えます。経験則として、 `engine_collision_driver.c <https://github.com/google-deepmind/mujoco/blob/main/src/engine/engine_collision_driver.c>`__ の先頭にある衝突テーブルにカスタムペア関数を持つ衝突は、汎用の凸対凸コライダー ``mjc_Convex`` を使用する衝突よりもかなり安価です。最も高価な衝突は、SDFジオメトリを含むものです。
   - 衝突メッシュをプリミティブに置き換えることが不可能な場合は、メッシュを可能な限り間引きます。trimesh、Blender、MeshLab、CoACDなどのオープンソースツールはこの点で非常に有用です。
6. :ref:`摩擦円錐<option-cone>`: 楕円錐は、高い :ref:`impratio<option-impratio>` で滑りを防ぐのにより正確で優れていますが、より高価です。正確な摩擦が重要でない場合は、角錐錐に切り替えてみてください。
7. MuJoCoを32ビット浮動小数点精度でコンパイルします（デフォルトの64ビットではなく）。マルチスレッドモードで実行される大きなモデルの場合、メモリアクセスが計算よりも高価であり、これは（最大）2倍のパフォーマンス向上につながる可能性があります。詳細については :ref:`mjtNum` を参照してください。

.. _CSlippage:

滑りの防止
~~~~~~~~~~~~~~~

接触滑りを診断および解決するために実行できるステップのリストを以下に示します。これは操作タスクで特に問題になります。滑りを診断するには、 :ref:`simulate<saSimulate>` ユーティリティの組み込み可視化オプションを使用して、接触と接触力を検査することをお勧めします。接触と力の視覚的サイズ（グローバルな :ref:`meansize<statistic-meansize>` または特定の :ref:`contactwidth<visual-scale-contactwidth>`、 :ref:`contactheight<visual-scale-contactheight>`、 :ref:`forcewidth<visual-scale-forcewidth>` 属性を使用）および :ref:`力のスケーリング<visual-map-force>` 属性を調整して、接触構成と結果の力をよりよく可視化し理解することが役立つ場合があります。

**滑りを防ぐ接触力が摩擦円錐の外側にある**
  これは、物理的に原理的に滑りを防げないことを意味します。これは次の場合に発生します：

  a. *法線力が小さすぎる。* グリッパーが加えられる最大の力に滑り摩擦係数を掛けたものが、オブジェクトの重量よりも大幅に大きいことを確認してください。
  b. *滑り摩擦係数が低すぎる。* 滑り :ref:`摩擦<body-geom-friction>` 係数を増やしてください。
  c. *ねじり摩擦が必要なトルクを加えるのに不十分。* :ref:`condim<body-geom-condim>` を4または6に増やし、適切な摩擦係数を選択してください。
     **condim 4** はねじり摩擦を有効にし、法線周りの回転を防ぎます。
     **condim 6** は転がり摩擦も有効にし、接線方向周りの回転を防ぎます。
     詳細とこれらの係数の具体的なセマンティクスについては、 :ref:`接触<coContact>` セクションを参照してください。

**ジオメトリが必要な力やトルクをサポートしていない**
  これは一般的な現実世界の問題であり、グリッパーとハンドルの改善された設計によって解決されます。

  a. 接触するジオムのジオメトリを改善して、より多くの接触点を追加します。可能であれば平坦でないジオメトリ（例：バンプ）を使用して、滑りが法線力によって防止され、摩擦成分だけでなくなるようにします。
  b. 接触が平面間の場合、 :ref:`multiccd<option-flag-multiccd>` フラグを有効にしてみてください。これにより、検出器は凸対凸コライダーが返す単一の接触よりも多くの接触を見つけることができます。
  c. :ref:`nativeccd<option-flag-nativeccd>` フラグを設定してネイティブ衝突検出パイプラインを有効にしてみてください。これは、より正確で効率的な凸衝突検出アルゴリズムを使用します。

**高周波振動**
  高周波で低振幅の振動は、多くの産業環境における現実世界の問題でもありますが、シミュレーションとは異なり、現実世界では可聴です。そのような振動は、非常に高いゲインを持つコントローラーによって引き起こされることが多く、時には接触やジョイントからのスティックスリップフィードバックが機構の固有モードと共振することによって引き起こされます。そのような振動を診断する最も簡単な方法は、 :ref:`simulate<saSimulate>` で接触力を可視化することです。解決策は通常、 :ref:`タイムステップ<option-timestep>` を減らすか、関連するジョイントに :ref:`アーマチュア<body-joint-armature>` を追加することです。振動のもう1つの理由は、明示的な減衰からのフィードバックです。 :ref:`数値積分<geIntegration>` セクションで文書化されているように、implicitまたはimplicitfast積分器を使用してください。

**遅い滑り**
  速い滑りにつながる上記の問題とは異なり、遅い、段階的な滑りは、逆動力学が定義されないためにMuJoCoの接触モデルの設計上の特性です。これは :ref:`柔軟性と滑り<Soft>` の説明で詳細に議論されています。このタイプの滑りは2つの方法で対処できます。

  a. :ref:`impratio<option-impratio>` パラメータを増やします。これにより、遅い滑りが減少します（ただし、完全には防止されません）。高いimpratio値は :ref:`楕円錐<option-cone>` でのみうまく機能することに注意してください。
  b. :ref:`noslip_iterations<option-noslip_iterations>` を正の整数に増やすことで、noslipソルバーを有効にします。小さな数（1、2、または3）で通常十分です。noslip後処理ソルバーは、逆動力学を不定にし、追加の計算コストを犠牲にして、滑りを完全に防ぎます。

.. _CBacklash:

バックラッシュ
~~~~~~~~~~~~~~

バックラッシュは多くのロボットジョイントに存在します。これは通常、ギアボックス内のギア間の小さな隙間によって引き起こされますが、ジョイント機構のいくらかのがたつきによって引き起こされることもあります。効果は、ジョイントが回転する前にモーターが小さな角度だけ回転できること、またはその逆（外部の力がジョイントに加えられたとき）です。バックラッシュは、MuJoCoで次のようにモデル化できます。ボディ内に単一のヒンジジョイントを持つ代わりに、同じ位置と向きを持つ2つのヒンジジョイントを定義します：

.. code-block:: xml

   <body>
     <joint name="J1" type="hinge" pos="0 0 0" axis="0 0 1" armature="0.01"/>
     <joint name="J2" type="hinge" pos="0 0 0" axis="0 0 1" limited="true" range="-1 1"/>
   </body>

したがって、親に対するボディの全体的な回転はJ1+J2です。J1にのみ作用するアクチュエータを定義します。J2の小さなジョイント範囲はそれを0近くに保ちますが、それに作用する力の方向に少し動くことを許容し、バックラッシュ効果を生成します。J1の :at:`armature` 属性に注意してください。これがないと、関節空間慣性行列は特異になります。なぜなら、2つのジョイントが慣性に遭遇せずに反対方向に加速できるからです。バックラッシュの原因となる物理的なギアは実際に回転慣性を持っています（私たちはこれをアーマチュアと呼びます）ので、これは現実的なモデリングアプローチです。この例の数値は、望ましい動作を得るために調整する必要があります。ジョイント制限制約の :at:`solref` および :at:`solimp` パラメータも調整して、バックラッシュ回転がより柔らかいまたはより硬い制限で終わるようにすることができます。

J2でジョイント制限を指定する代わりに、J2=0を保つ柔軟な等式制約を指定できます。次に、制約インピーダンス関数を調整して、J2=0の近くで制約が弱く、0から離れるにつれて強くなるようにする必要があります。 :ref:`ソルバーパラメータ <CSolver>` に示されているインピーダンス関数の新しいパラメータ化がこれを可能にします。ジョイント制限と比較して、等式制約アプローチは、バックラッシュ領域と制限領域の間でより柔らかい遷移を生成します。また、常にアクティブになるため、制約違反または制約力を入力として必要とするユーザーコードで便利です。

.. _CRestitution:

反発
~~~~~~~~~~~

:at:`solref` を指定するための別の機構が存在し、 :ref:`ソルバーパラメータ <CSolver>` で説明されています。両方の数値が非正の場合、それらは（-剛性、-減衰）として解釈され、制約インピーダンスによってスケーリングされます。接触やその他の制約に対して完全な反発を達成するには、剛性を合理的に大きな値に設定し、減衰をゼロに設定します。以下は、反発係数1で平面上でバウンドする球の例です。そのため、接触の前後のエネルギーがほぼ保存されます。接触自体が柔らかく、数タイムステップかかり、それらのタイムステップ中の（陰的な）変形が厳密にはエネルギー保存的ではないため、正確には保存されません。しかし、全体的な効果は、ボールが視覚的に見えるようにピーク高さを変えることなく非常に長い時間バウンドし、エネルギーがドリフトする代わりに初期値の周りで変動することです。

.. code-block:: xml

   <worldbody>
     <geom type="plane" size="1 1 .1"/>

     <body pos="0 0 1">
       <freejoint/>
       <geom type="sphere" size="0.1" solref="-1000 0"/>
     </body>
   </worldbody>


.. |image3| image:: images/modeling/tendonwraps.png
   :width: 500px
.. |image4| image:: images/modeling/particle.png
   :height: 300px
.. |image5| image:: images/modeling/particle2.png
   :height: 300px
.. |image6| image:: images/modeling/grid1.png
   :height: 200px
.. |image7| image:: images/modeling/grid1pin.png
   :height: 200px
.. |image8| image:: images/modeling/grid2.png
   :height: 300px
.. |image9| image:: images/modeling/grid2pin.png
   :height: 300px
.. |image10| image:: images/modeling/rope.png
   :height: 200px
.. |image11| image:: images/modeling/loop.png
   :height: 200px
.. |image12| image:: images/modeling/cloth.png
   :height: 300px
.. |image13| image:: images/modeling/cloth2.png
   :height: 300px
.. |image14| image:: images/modeling/box.png
   :height: 300px
.. |image15| image:: images/modeling/box2.png
   :height: 300px
.. |image16| image:: images/modeling/cylinder.png
   :height: 300px
.. |image17| image:: images/modeling/ellipsoid.png
   :height: 300px
.. |image18| image:: images/modeling/mocap1.png
   :height: 250px
.. |image19| image:: images/modeling/mocap2.png
   :height: 250px
.. |particle| image:: images/models/particle.gif
   :width: 270px
.. |bunny1| image:: images/modeling/bunny1.png
   :width: 300px
.. |bunny2| image:: images/modeling/bunny2.png
   :width: 300px
.. |coil| image:: images/modeling/coil.png
   :width: 300px
