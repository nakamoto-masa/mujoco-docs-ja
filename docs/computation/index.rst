計算
====

.. toctree::
    :hidden:

    fluid


はじめに
--------

この章では、MuJoCoの数学的およびアルゴリズム的な基盤について説明します。全体的なフレームワークは、一般化座標（関節座標）でのモデリングとシミュレーションに精通した読者にとっては比較的標準的なものです。そのため、その部分は簡潔にまとめます。この章の大部分は、接触やその他の制約をどのように扱うかに充てられています。このアプローチは我々の最近の研究に基づいており、MuJoCoに固有のものであるため、その動機付けと詳細な説明に時間を割きます。追加情報は以下の論文に記載されていますが、この章の技術的なアイデアの一部は新しいものであり、他では説明されていません。

   `Analytically-invertible dynamics with contacts and constraints: Theory and implementation in MuJoCo <https://scholar.google.com/scholar?cluster=9217655838195954277>`__ E. Todorov (2014).

.. _Motivation:

ソフト接触モデル
----------------

ロボットも人間も、主に物理的な接触を通じて環境と相互作用します。ロボティクス、機械学習、アニメーション、バーチャルリアリティ、バイオメカニクスなどの分野で物理モデリングの重要性が増していることから、物理的に正確かつ計算効率の高い接触動力学のシミュレーションモデルが必要とされています。シミュレーションモデルの一つの用途は、推定および制御戦略の候補を物理システムに展開する前に評価することです。もう一つの用途は、それらの戦略の設計を自動化することであり、これは通常、内部ループでシミュレーションを使用する数値最適化によって行われます。後者の用途は追加の制約を課します：接触動力学に関して定義される目的関数は、数値最適化に適したものでなければなりません。MuJoCoの基盤となる接触モデルは、これらおよびその他の関連する側面において利点を持ちます。以下のセクションでは、その利点について議論しつつ、 *事実上の* 標準である線形相補性問題（LCP）ファミリーの接触モデルとの違いを明確にします。

.. _moRealism:

物理的リアリズムとソフト接触
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

我々の接触モデルの多くの利点は、LCP定式化の中心にある厳密な相補性制約を緩和するという事実に遡ることができます。我々はこのモデルファミリーを凸と呼びます。関連する研究については :ref:`References` を参照してください。摩擦のない接触では、明示的な相補性制約を緩和しても違いはありません。なぜなら、結果として得られる凸二次計画問題のカルーシュ・クーン・タッカー（KKT）最適性条件はLCPと等価だからです。しかし、摩擦のある接触では違いがあります。

凸モデルをLCPの近似として見る場合、その近似がどの程度良いかを問うのが自然な問いです。しかし、我々はそのようには考えません。むしろ、LCPモデルも凸モデルも、それぞれ長所と短所を持つ物理的現実の異なる近似であると考えます。厳密な相補性を緩和しコストで置き換えることの直接的な帰結として、相補性が破られる可能性があります。つまり、接触法線方向の力と速度が同時に正になりうるし、摩擦力が最大散逸的でない場合もあります。関連する現象として、滑りを開始する唯一の方法は法線方向にいくらかの運動を生成することです。これらの効果は数値的に小さいが望ましくありません。しかし、この欠点は実用上ほとんど関係がありません。なぜなら、それはハード接触の仮定に基づいているからです。しかし、すべての物理的材料はある程度の変形を許容します。これはロボティクスにおいて特に重要であり、環境と接触するロボットの部分は通常、柔らかく設計されています。ソフト接触では相補性は破られなければなりません：貫入があり材料が接触するボディを押し離しているとき、法線方向の力と速度はともに正となります。さらに、ある物体がある程度の貫入を持ってソフトな表面上に静止しており、横方向に押すと、滑り始めるときにわずかに上に持ち上がることが期待されます。したがって、LCPからの逸脱は実際にはソフト接触の存在下で物理的リアリズムを向上させます。

もちろん、すべてのソフトモデルが望ましいわけではありません。例えば、バネ・ダンパーモデルはソフトですが不安定性に悩まされます。同時に、異なる材料は異なるプロファイルを持つため、ハード接触モデルとは異なり、ソフトモデルは複数の対象システムに適応するために十分に豊富なパラメータ化を持たなければなりません。これにより、接触モデルパラメータのシステム同定が容易になります。

.. _moEfficiency:

計算効率
~~~~~~~~

摩擦接触を伴うLCPモデルはNP困難な最適化問題に対応します。このことが近似ソルバーの産業を生み出し、不幸な副作用として、多くの一般的な物理エンジンが十分に文書化されていないショートカットを使用しており、結果として得られる運動方程式の特性を把握することが困難になっています。公平を期すと、NP困難は最悪ケースの性能に関する記述であり、LCPを実際に素早く解くことが不可能であることを意味するわけではありません。それでも、凸最適化には確立された利点があります。MuJoCoでは、典型的なロボティクスモデルにおいて、射影ガウス・ザイデル法（PGS）の10回のスイープで、実用上グローバル最小値と区別がつかない解が得られることが観察されています。もちろん、凸であっても数値的に解くことがはるかに困難な問題もあり、そのような問題には高次の収束性を持つ共役勾配ソルバーがあります。

計算効率の要件は用途によって異なります。リアルタイムシミュレーションのみが必要な場合、現代のコンピュータは非効率なソルバーであっても、ほとんどの対象ロボティクスシステムを扱うのに十分な速度を持ちます。しかし、最適化の文脈では、十分に高速なシミュレーションというものは存在しません。目的関数とその導関数がより速く計算できれば、それはより大きな探索範囲、トレーニングセット、またはサンプルサイズに直結し、ひいてはパフォーマンスの向上につながります。これが、効率的なソルバーの開発に多大な労力を投入してきた理由です。

.. _moContinuous:

連続時間
~~~~~~~~

あらゆる物理システムの運動方程式は連続時間で一意に定義されると思われるかもしれません。しかし、摩擦接触は、クーロン摩擦モデルが連続時間で十分に定義されていないため問題があります（パンルヴェのパラドックス）。このことが、離散時間近似および関連する速度ステッピングスキームを非常に一般的なものにしました。これらのモデルの連続時間極限が調べられることはほとんどありません。単一の接触に対して、印加される力に関する必ずしも現実的でない仮定の下では、その極限はクーロン摩擦モデルの微分包含形式を満たします。一方、複数の同時接触に対しては、連続時間極限の取り方によって複数の解が存在しえます。これらの困難は、ハード接触の仮定に起因します。

摩擦接触の凸モデルも過去には離散時間近似に依存してきましたが、これは必須ではありません。本モデルは連続時間で、力と加速度に関して定義されています。これは、現実世界で時間が連続であることを考えれば、より自然です。また、制御の文献で好まれている定式化でもあり、実際、MuJoCoがそのコミュニティからのユーザーを引き付けることを期待しています。連続時間定式化のもう一つの利点は、離散時間変分積分器の計算オーバーヘッド（慣性が構成依存の場合には必然的に陰的になる）を支払うことなく、洗練された数値積分を適用できることです。連続時間のダイナミクスは時間の逆方向にも十分に定義されており、これは一部の最適化アルゴリズムで必要とされます。

.. _moInverse:

逆動力学と最適化
~~~~~~~~~~~~~~~~

逆動力学の目的は、多関節システムの位置、速度、加速度が与えられた場合に、印加力と接触力を回復することです。ハード接触では、この計算は不可能です。壁を動かずに押している場合を考えてください。接触力は運動学から回復できません。もちろん、材料の変形を考慮すれば別ですが、その場合にはソフト接触モデルが必要になります。バネ・ダンパーモデルによる接触では逆動力学の計算は自明です。なぜなら、その場合の接触力は位置と速度のみの関数であり、印加力に依存しないからです。しかし、これがバネ・ダンパーモデルが望ましくない理由でもあります：印加力を無視するということは、各タイムステップで誤差が導入され、シミュレータが常にエラー修正モードにあり、それが不安定性を引き起こすことを意味します。対照的に、現代の接触ソルバーは接触力/インパルスの計算時に印加力（およびすべての内力）を考慮します。しかし、これにより逆問題が複雑になります。本接触モデルは一意に定義された逆を持ちます。逆動力学は実際には順動力学よりも計算が容易です。なぜなら、最適化問題が対角的になり、個々の接触に関する独立した最適化問題に分解されるからであり、これは解析的に解くことができます。

逆動力学は、システム同定、推定、制御に関連する最適化アルゴリズムにおいて重要な役割を果たします。逆動力学により、位置の系列（またはそのパラメトリック表現）を最適化対象として扱うことが可能になります。速度と加速度は位置を微分することで計算され、逆動力学を使用して印加力と接触力が計算されます。そして最終的に、これらすべてに依存しうる目的関数が構築されます。これは、時空間最適化、スペクトル法、直接コロケーションと互換的に呼ばれます。MuJoCoは、接触やその他の制約が存在する場面でのこのような計算を支援するのに独自に適しています。

.. _Framework:

一般的なフレームワーク
----------------------

我々の記法を以下の表にまとめます。制約に固有の追加記法については後で導入します。利用可能な場合は、数学的記法に対応する主要なデータ構造 :ref:`mjModel` と :ref:`mjData` のフィールドも示します。

.. list-table::
   :widths: 2 2 7 4
   :header-rows: 1

   * - 記号
     - サイズ
     - 説明
     - MuJoCoフィールド
   * - :math:`\nq`
     -
     - 位置座標の数
     - ``mjModel.nq``
   * - :math:`\nv`
     -
     - 自由度の数
     - ``mjModel.nv``
   * - :math:`\nc`
     -
     - アクティブな制約の数
     - ``mjData.nefc``
   * - :math:`q`
     - :math:`\nq`
     - 関節位置
     - ``mjData.qpos``
   * - :math:`v`
     - :math:`\nv`
     - 関節速度
     - ``mjData.qvel``
   * - :math:`\tau`
     - :math:`\nv`
     - 印加力：受動、アクチュエーション、外部
     - ``mjData.qfrc_passive`` + ``mjData.qfrc_actuator`` + ``mjData.qfrc_applied``
   * - :math:`c(q, v)`
     - :math:`\nv`
     - バイアス力：コリオリ、遠心、重力
     - ``mjData.qfrc_bias``
   * - :math:`M(q)`
     - :math:`\nv \times \nv`
     - 関節空間の慣性
     - ``mjData.qM``
   * - :math:`J(q)`
     - :math:`\nc \times \nv`
     - 制約ヤコビアン
     - ``mjData.efc_J``
   * - :math:`r(q)`
     - :math:`\nc`
     - 制約残差
     - ``mjData.efc_pos``
   * - :math:`f(q, v,\tau)`
     - :math:`\nc`
     - 制約力
     - ``mjData.efc_force``

すべてのモデル要素はコンパイル時に列挙され、上記のシステムレベルのベクトルと行列に組み立てられます。先述の腕モデルの :ref:`例 <Examples>` では、モデルは :math:`\nv = 13` 自由度を持ちます：ボールジョイントに3、4つのヒンジジョイントにそれぞれ1、自由浮遊する物体に6です。これらは、次元が :math:`\nv` であるすべてのシステムレベルのベクトルと行列で同じ順序で現れます。特定のモデル要素に対応するデータは、概要の章の :ref:`Clarifications` セクションで説明されているようなインデックス操作によって取得できます。次元が :math:`\nq` のベクトルと行列は、アクティブな :ref:`制約 <Constraint>` が実行時に変化するため、やや異なります。その場合でも固定の列挙順序（モデル要素が ``mjModel`` に現れる順序に対応）がありますが、非アクティブな制約は省略されます。

位置座標の数 :math:`\nq` は、3D方向の表現にクォータニオンが使用される場合、自由度の数 :math:`\nv` より大きくなります。これは、モデルにボールジョイントまたはフリージョイントが含まれる場合（すなわち、ほとんどのモデル）に発生します。その場合、 :math:`\dot{q}` は :math:`v` と等しくなりません。少なくとも通常の意味では等しくなりません。代わりに、剛体の方向の群 :math:`SO(3)` を考慮する必要があります。これは4D空間の単位球面の幾何学を持ちます。速度はこの球面への3D接線空間に存在します。これはすべての内部計算で考慮されています。カスタム計算のために、MuJoCoは関数 :ref:`mj_differentiatePos` を提供しており、次元 :math:`\nq` の2つの位置ベクトルを「減算」し、次元 :math:`\nv` の速度ベクトルを返します。クォータニオン関連のユーティリティ関数も多数提供されています。

MuJoCoは連続時間で順動力学と逆動力学の両方を計算します。順動力学は、選択された :ref:`数値積分器 <geIntegration>` によって、指定された ``mjModel.opt.timestep`` にわたって積分されます。連続時間における一般的な運動方程式は以下の通りです。

.. math::
   M \dot{v} + c = \tau + J^T f
   :label: eq:motion

ヤコビアンは、関節座標と制約座標の間の量の関係を確立します。運動ベクトル（速度と加速度）を関節座標から制約座標にマッピングします：関節速度 :math:`v` は制約座標の速度 :math:`J v` にマッピングされます。ヤコビアンの転置は、力ベクトルを制約座標から関節座標にマッピングします：制約力 :math:`f` は関節座標の力 :math:`J^T f` にマッピングされます。

関節空間の慣性行列 :math:`M` は常に可逆です。したがって、制約力 :math:`f` が既知になれば、順動力学と逆動力学の計算を以下のように完了できます。

.. math::
   \begin{aligned}
   \text{forward:} & & \dot{v} &= M^{-1} (\tau + J^T f - c) \\
   \text{inverse:} & & \tau    &= M \dot{v} + c - J^T f \\
   \end{aligned}

制約力の計算は困難な部分であり、後で説明します。しかしまず、制約ヤコビアンまでの上記の量がどのように計算されるかをまとめることで、一般的なフレームワークの説明を完了します。

-  印加力 :math:`\tau` には、バネ・ダンパーと流体動力学による :ref:`受動 <gePassive>` 力、 :ref:`アクチュエーション <geActuation>` 力、およびユーザーが指定した追加の力が含まれます。
-  バイアス力 :math:`c` には、コリオリ力、遠心力、重力が含まれます。これらの合計は、加速度を0に設定した再帰ニュートン・オイラー（RNE）アルゴリズムを使用して計算されます。
-  関節空間の慣性行列 :math:`M` は、複合剛体（CRB）アルゴリズムを使用して計算されます。この行列は通常かなりスパースであり、キネマティックツリーに合わせたカスタムフォーマットでスパースとして表現します。
-  :math:`M` の逆との乗算が頻繁に必要となるため、スパース性を保持する方法で :math:`L^T D L` 分解を計算します。後で :math:`M^{-1} x` の形の量が必要になった場合、スパース後退代入によって計算されます。

これらの計算の前に、すべての空間オブジェクトのグローバル位置と方向および関節軸を計算する順運動学を適用します。RNEとCRBをローカル座標で適用することがよく推奨されますが、ここではグローバル座標で行われる衝突検出の準備をしているため、RNEとCRBもグローバル座標で実装されています。それにもかかわらず、浮動小数点精度を向上させるために、各キネマティックサブツリーのデータをサブツリー重心に中心を置いたグローバルフレームで表現します（ ``mjData`` のcで始まるフィールド）。 :ref:`シミュレーションパイプライン <Pipeline>` の詳細なまとめは章末に記載されています。

.. _geActuation:

アクチュエーションモデル
~~~~~~~~~~~~~~~~~~~~~~~~

MuJoCoは柔軟なアクチュエータモデルを提供します。すべてのアクチュエータは単一入力単一出力（SISO）です。アクチュエータ :math:`i` への入力は、ユーザーが指定するスカラー制御 :math:`u_i` です。出力はスカラー力 :math:`p_i` であり、伝達によって決定されるモーメントアームのベクトルによって関節座標にマッピングされます。アクチュエータは、独自のダイナミクスを持つ活性化状態 :math:`w_i` を持つこともできます。すべてのアクチュエータの制御入力は ``mjData.ctrl`` に、力の出力は ``mjData.actuator_force`` に、活性化状態（ある場合）は ``mjData.act`` に格納されます。

アクチュエータのこれら3つの構成要素——伝達、活性化ダイナミクス、力の生成——がアクチュエータの動作を決定します。ユーザーは最大の柔軟性のためにこれらを独立に設定できますし、一般的なアクチュエータタイプをインスタンス化する :ref:`アクチュエータショートカット <CActShortcuts>` を使用することもできます。

.. _geTransmission:

伝達
^^^^

各アクチュエータは、伝達の種類とそのパラメータによって定義されるスカラー長さ :math:`l_i(q)` を持ちます。勾配 :math:`\nabla l_i` は :math:`\nv` 次元のモーメントアームベクトルです。これは、スカラーアクチュエータ力から関節力へのマッピングを決定します。伝達の特性は、アクチュエータが取り付けられるMuJoCoオブジェクトによって決定されます。取り付け可能なオブジェクトの種類は :at:`joint` 、 :at:`tendon` 、 :at:`jointinparent` 、 :at:`slider-crank` 、 :at:`site` 、および :at:`body` です。

:at:`joint` と :at:`tendon`
   :at:`joint` と :at:`tendon` の伝達タイプは期待通りに動作し、アクチュエータが対象オブジェクトに力またはトルクを加えることに対応します。ボールジョイントは特殊です。詳細は :ref:`actuator/general/joint<actuator-general-joint>` のドキュメントを参照してください。

:at:`jointinparent`
   :at:`jointinparent` 伝達はボールジョイントとフリージョイントに固有であり、回転が子フレームではなく親フレームで測定されることを指定します。

:at:`slider-crank`
   :at:`slider-crank` `伝達 <https://en.wikipedia.org/wiki/Slider-crank_linkage>`_ は、ピストン駆動の燃焼エンジンのように、線形力をトルクに変換します。 `このモデル <https://github.com/google-deepmind/mujoco/blob/main/model/slider_crank/slider_crank.xml>`__ には教育的な例が含まれています。スライダークランクは、MuJoCoボディを作成し等式制約で結合することで明示的にモデル化することもできますが、それは効率も安定性も低くなります。

:at:`body`
   :el:`body` 伝達は、真空グリッパーや生体力学的粘着付属器官をモデル化するために、ボディに属する接触点に力を加えることに対応します。粘着に関する詳細は、 :ref:`adhesion<actuator-adhesion>` アクチュエータのドキュメントを参照してください。これらの伝達対象は固定のゼロ長さ :math:`l_i(q) = 0` を持ちます。

:at:`site`
   サイト伝達は、サイトのフレームにおけるデカルト力/トルクを加えることに対応します。 :at:`refsite` が定義されていない場合（下記参照）、これらの対象は固定のゼロ長さ :math:`l_i(q) = 0` を持ち、ジェットやプロペラ（サイトフレームに固定された力とトルク）のモデル化に有用です。

   :at:`site` 伝達がオプションの :at:`refsite` 属性で定義されている場合、力とトルクはサイト自身のフレームではなく参照サイトのフレームで加えられます。参照サイトが定義されている場合、アクチュエータの長さは非ゼロとなり、参照フレームの選択された方向に射影された2つのサイトの姿勢差に対応します。この長さは :el:`position` アクチュエータで制御でき、デカルトエンドエフェクタ制御が可能になります。詳細は :ref:`refsite<actuator-general-refsite>` のドキュメントを参照してください。

.. _geActivation:

状態を持つアクチュエータ
^^^^^^^^^^^^^^^^^^^^^^^^

空気圧シリンダや油圧シリンダ、生体筋肉などの一部のアクチュエータは、「活性化」と呼ばれる内部状態を持ちます。これは、関節位置 :math:`q` と速度 :math:`v` を超えた真のダイナミック状態です。このようなアクチュエータをモデルに含めると、3次のダイナミクスになります。アクチュエータの活性化ベクトルを :math:`w` と表記します。これらは以下の1次ダイナミクスを持ちます。

.. math::
   \dot{w}_i \left( u_i, w_i, l_i, \dot{l}_i \right)

活性化の種類と対応するモデルパラメータによって決定されます。各アクチュエータは他のアクチュエータとは独立したスカラーダイナミクスを持つことに注意してください。現在実装されている活性化タイプは以下の通りです。

.. math::
   \begin{aligned}
   \text{integrator}:  & & \dot{w}_i &= u_i \\
   \text{filter}:      & & \dot{w}_i &= (u_i - w_i) / \texttt{t} \\
   \text{filterexact}: & & \dot{w}_i &= (u_i - w_i) / \texttt{t} \\
   \text{muscle}:      & & \dot{w}_i &= \textrm{muscle}(u_i, w_i, l_i, \dot{l}_i)
   \end{aligned}

ここで :math:`\texttt{t}` はアクチュエータ固有の時定数で、 ``mjModel.actuator_dynprm`` に格納されています。さらに、タイプを"user"にすることもでき、その場合 :math:`w_i` はユーザー定義のコールバック :ref:`mjcb_act_dyn` によって計算されます。タイプを"none"にすることもでき、これは活性化状態を持たない通常のアクチュエータに対応します。 :math:`w` の次元は、活性化タイプが"none"以外のアクチュエータの数と等しくなります。

筋肉の活性化ダイナミクスに関する詳細は :ref:`CMuscle` を参照してください。

``filterexact`` の活性化ダイナミクスでは、 :math:`\dot{w}` のオイラー積分が解析的積分に置き換えられます：

.. math::
   \begin{aligned}
   \text{filter}:      & & w_{i+1} &= w_i + h (u_i - w_i) / \texttt{t} \\
   \text{filterexact}: & & w_{i+1} &= w_i + (u_i - w_i) (1 - e^{-h / \texttt{t}}) \\
   \end{aligned}

2つの式は :math:`h \rightarrow 0` の極限で同じ値に収束します。オイラー積分されたフィルタは :math:`\texttt{t} < h` で発散しますが、正確に積分されたフィルタは任意の正の :math:`\texttt{t}` に対して安定であることに注意してください。

:ref:`actearly<actuator-general-actearly>`:
  :ref:`actearly<actuator-general-actearly>` 属性が"true"に設定されている場合、 ``mjData.actuator_force`` は :math:`w_{i+1}` （次の活性化）に基づいて計算され、 :math:`u` の変更から加速度への影響までの遅延が1タイムステップ削減されます（したがって、全体のダイナミクスは3次ではなく2次になります）。

.. _geActuatorForce:

力の生成
^^^^^^^^

各アクチュエータは、以下の関数であるスカラー力 :math:`p_i` を生成します。

.. math::
   p_i \left( u_i, w_i, l_i, \dot{l}_i \right)

活性化ダイナミクスと同様に、力の生成メカニズムはアクチュエータ固有であり、モデル内の他のアクチュエータと相互作用することはできません。現在のところ、力は活性化状態が存在する場合はそれに対してアフィン、そうでない場合は制御に対してアフィンです：

.. math::
   p_i = (a w_i \; \text{or} \; a u_i) + b_0 + b_1 l_i + b_2 \dot{l}_i

ここで :math:`a` はアクチュエータ固有のゲインパラメータ、 :math:`b_0, b_1, b_2` はアクチュエータ固有のバイアスパラメータであり、それぞれ ``mjModel.actuator_gainprm`` と ``mjModel.actuator_biasprm`` に格納されています。ゲインとバイアスパラメータの異なる設定により、直接力制御だけでなく位置サーボや速度サーボもモデル化できます。その場合、制御/活性化は参照位置または参照速度の意味を持ちます。コールバック :ref:`mjcb_act_gain` と :ref:`mjcb_act_bias` をインストールし、ゲインとバイアスのタイプを"user"に設定することで、カスタムのゲインとバイアス項を計算することもできます。アフィンな力の生成により、逆動力学で計算された印加力からモーメントアーム行列の擬似逆行列を使用して制御/活性化を推定することが可能になることに注意してください。ただし、実世界で使用されるアクチュエータの一部はアフィンではなく（特に組み込みの低レベルコントローラーを持つもの）、上記モデルの拡張を検討しています。

これらすべてを統合すると、すべてのアクチュエータが一般化座標で寄与する正味の力は以下の通りです。

.. math::
   \sum_i \nabla l_i(q) \; p_i \left(u_i, w_i, l_i(q), \dot{l}_i(q, v) \right)

この量は ``mjData.qfrc_actuator`` に格納されます。これは、ユーザー定義の関節座標またはデカルト座標の力（それぞれ ``mjData.qfrc_applied`` と ``mjData.xfrc_applied`` に格納）とともに、印加力ベクトル :math:`\tau` に加算されます。

.. _gePassive:

受動力
~~~~~~

受動力は、順動力学における制御や逆動力学における加速度に依存せず、位置と速度のみに依存する力として定義されます。その結果、このような力は順動力学と逆動力学の両方の計算への入力であり、両方の場合で同一です。これらは ``mjData.qfrc_passive`` に格納されます。MuJoCoが計算する受動力は、物理学の意味でも受動的です。すなわち、エネルギーを増加させません。ただし、ユーザーはコールバック :ref:`mjcb_passive` をインストールし、エネルギーを増加させる可能性のある力を ``mjData.qfrc_passive`` に追加できます。そのようなユーザー力が位置と速度のみに依存する限り、MuJoCoの動作を妨げることはありません。

MuJoCoは3種類の受動力を計算できます：

- ジョイントとテンドンのバネ・ダンパー。詳細は以下の属性を参照してください。
  |br| **ジョイント：**
  :ref:`stiffness<body-joint-stiffness>` 、 :ref:`springref<body-joint-springref>` 、
  :ref:`damping<body-joint-damping>` 、 :ref:`springdamper<body-joint-springdamper>` 。
  |br| **テンドン：** :ref:`stiffness<tendon-spatial-stiffness>` 、
  :ref:`springlength<tendon-spatial-springlength>` 、 :ref:`damping<tendon-spatial-damping>` 。
- 重力補償力。詳細はボディの :ref:`gravcomp<body-gravcomp>` 属性を参照してください。
- 周囲媒質が及ぼす流体力。詳細は :doc:`流体力 <fluid>` の章を参照してください。

.. _geIntegration:

数値積分
~~~~~~~~

MuJoCoは連続時間で順動力学と逆動力学を計算します。順動力学の最終結果は、関節加速度 :math:`a=\dot{v}` と、モデルに存在する場合はアクチュエータの活性化 :math:`\dot{w}` です。これらは、シミュレーション時間を :math:`t` から :math:`t+h` に進め、状態変数 :math:`q, v, w` を更新するために使用されます。

4つの数値積分器が利用可能であり、3つの単段積分器と多段の4次ルンゲ・クッタ積分器があります。積分器の説明に入る前に、単段オイラー積分器の一般的な説明から始めます： *陽的* 、 *半陰的* 、および *速度に関して陰的* な方法です。 *陽的* オイラー法はMuJoCoではサポートされていませんが、教育的な価値があります。以下のように書くことができます。

.. math::
   :label: eq_explicit

   \begin{aligned}
      \textrm{activation:}\quad w_{t+h} &= w_t + h \dot{w}_t \\
      \textrm{velocity:}\quad v_{t+h} &= v_t + h a_t \\
      \textrm{position:}\quad q_{t+h} &= q_t + h v_t
   \end{aligned}

クォータニオンが存在する場合、演算 :math:`q_t + h v_t` は :math:`q` と :math:`v` の次元が異なるため、単純な加算よりも複雑になることに注意してください。陽的オイラーが実装されていない理由は、 *半陰的* オイラーとして知られる以下の定式化が `厳密に優れている <https://en.wikipedia.org/wiki/Semi-implicit_Euler_method>`_ ためであり、物理シミュレーションでは標準的です。

.. math::
  :label: eq_semimplicit

   \begin{aligned}
      v_{t+h} &= v_t + h a_t \\
      q_{t+h} &= q_t + h v_{\color{red}t+h}
   \end{aligned}

:eq:`eq_explicit` と :eq:`eq_semimplicit` を比較すると、半陰的オイラーでは位置が *新しい* 速度を使って更新されていることがわかります。 *陰的* オイラーは以下を意味します。

.. math::
   :label: eq_implicit

   \begin{aligned}
      v_{t+h} &= v_t + h a_{\color{red}t+h} \\
      q_{t+h} &= q_t + h v_{t+h}
   \end{aligned}

:eq:`eq_semimplicit` と :eq:`eq_implicit` を比較すると、速度更新の右辺にある加速度 :math:`a_{t+h}=\dot{v}_{t+h}` が *次のタイムステップ* で評価されていることがわかります。次の加速度をステップを踏まずに評価することはできませんが、1次テイラー展開を使ってこの量を近似し、ニュートン法の1ステップを取ることができます。展開が速度に関してのみ（位置に関してではなく）行われる場合、この積分器は *速度に関して陰的な* オイラーとして知られています。このアプローチは、速度依存の力によって不安定性が引き起こされるシステムで特に効果的です：多関節振り子、空間で回転する物体、揚力と抗力のあるシステム、テンドンとアクチュエータに大きな減衰があるシステムなどです。加速度を速度の関数として :math:`a_t = a(v_t)` と書くと、近似したい速度更新は以下のようになります。

.. math:: v_{t+h} = v_t + h a(v_{t+h})

これは未知ベクトル :math:`v_{t+h}` に関する非線形方程式であり、 :math:`a(v_{t+h})` の :math:`v_t` 周りの1次展開を使って各タイムステップで数値的に解くことができます。順動力学は以下であることを思い出してください。

.. math::
   :label: eq_forward

   a(v) = M^{-1} \big(\tau(v) - c(v) + J^T f(v)\big)

したがって、微分を以下のように定義します。

.. math::
   \begin{aligned}
       {\partial a(v) \over \partial v} &= M^{-1} D \\
       D &\equiv {\partial \over \partial v} \Big(\tau(v) - c (v) + J^T f(v)\Big)
   \end{aligned}

ニュートン法に対応する速度更新は以下の通りです。まず、右辺を1次まで展開します。

.. math::
   \begin{aligned}
      v_{t+h} &= v_t + h a(v_{t+h}) \\
              &\approx v_t + h \big( a(v_t) + {\partial a(v) \over \partial v} \cdot (v_{t+h}-v_t) \big) \\
              &= v_t + h a(v_t) + h M^{-1} D \cdot (v_{t+h}-v_t)
   \end{aligned}

:math:`M` を左から掛けて整理すると

.. math:: (M-h D) v_{t+h} = (M-h D) v_t + h M a(v_t)

:math:`v_{t+h}` について解くと、速度に関して陰的な更新が得られます。

.. math::
   :label: eq_implicit_update

   \begin{aligned}
       v_{t+h} &= v_t + h \widehat{M}^{-1} M a(v_t) \\
       \widehat{M} &\equiv M-h D
   \end{aligned}

.. _geIntegrators:

積分器
^^^^^^
MuJoCoは4つの積分器をサポートしています：3つの単段積分器と多段の4次ルンゲ・クッタ積分器です。MuJoCoの3つの単段積分器はすべて更新 :eq:`eq_implicit_update` を使用し、 :math:`D` 行列の定義が異なります。 :math:`D` は常に解析的に計算されます。

陰的ジョイント減衰を伴う半陰的（ ``Euler`` ）
   この方法では、 :math:`D` にはジョイント減衰の微分のみが含まれます。この場合、 :math:`D` は対角行列であり、 :math:`\widehat{M}` は対称行列であるため、 :math:`L^TL` 分解（コレスキー分解の変種）を使用できます。この分解は ``mjData.qLD`` に格納されます。モデルにジョイント減衰がない場合、または :ref:`eulerdamp<option-flag-eulerdamp>` 無効化フラグが設定されている場合、陰的減衰は無効化され、 :eq:`eq_implicit_update` ではなく半陰的更新 :eq:`eq_semimplicit` が使用されます。これにより、 :math:`\widehat{M}` の追加の分解が回避されます（ *追加の* というのは、 :math:`M` は加速度更新 :eq:`eq_forward` のためにすでに分解されているためです）。

速度に関して陰的（ ``implicit`` ）
   この方法では、 :math:`D` には制約力 :math:`J^T f(v)` を除くすべての力の微分が含まれます。制約力は現在のところ無視されています。制約力の計算は可能ですが複雑であり、数値テストではそれを含めても大きな利点がないことが示されているためです。ただし、制約力の解析的微分は将来のバージョンで計画されています。さらに、計算効率のため、 :math:`D` を :math:`M` と同じスパースパターンに制限しています。この制限により、キネマティックツリーの異なる分岐にあるボディを接続するテンドンの減衰は除外されます。 :math:`D` は対称ではないため、コレスキー分解は使用できませんが、 :math:`D` と :math:`M` がキネマティックツリーのトポロジーに対応する同じスパースパターンを持つため、 :math:`\widehat{M}` の逆順 :math:`LU` 分解は `フィルインなし <https://link.springer.com/book/10.1007/978-1-4899-7560-7>`_ であることが保証されています。この分解は ``mjData.qLU`` に格納されます。

高速な速度に関して陰的（ ``implicitfast`` ）
   この方法では、 :math:`D` にはimplicit法で使用されるすべての力の微分が含まれますが、RNEアルゴリズムで計算される遠心力とコリオリ力 :math:`c (v)` は例外です。さらに、 :math:`D \leftarrow (D + D^T)/2` として対称化されます。RNEの微分を除外する理由の1つは、それらの計算コストが最も高いことです。2つ目の理由は、これらの力が急速に変化するのは複雑な振り子の高い回転速度や回転する物体の場合のみであり、これらのシナリオは一般的ではなく、ルンゲ・クッタ積分器（下記参照）によってすでに適切に処理されているためです。RNEの微分は :math:`D` の非対称性の主な原因でもあるため、それらを除外して対称化することで、 :math:`LU` 分解ではなくより高速な :math:`L^TL` 分解を使用できます。

4次ルンゲ・クッタ（ ``RK4`` ）
   我々の連続時間定式化の利点の1つは、ルンゲ・クッタ法や多段法などの高次積分器を使用できることです。現在実装されている唯一のそのような積分器は、固定ステップの `4次ルンゲ・クッタ法 <https://en.wikipedia.org/wiki/Runge–Kutta_methods#Derivation_of_the_Runge–Kutta_fourth-order_method>`__ ですが、ユーザーは :ref:`mj_forward` を呼び出して加速度を自分で積分することで、他の積分器を容易に実装できます。エネルギー保存システム（ `例 <../_static/pendulum.xml>`__ ）において、RK4はタイムステップを4分の1に減らした場合（つまり計算量が同等の場合）でも、安定性と精度の両面で単段法より質的に優れていることが観察されています。大きな速度依存の力が存在する場合、選択した単段法がそれらの力を陰的に積分するならば、単段法はRK4よりも大幅に安定することがあります。

.. admonition:: タイムステップと積分器の選択
   :class: tip

   :ref:`timestep<option-timestep>`
    すべての積分器の精度と安定性は、タイムステップ :math:`h` を小さくすることで改善できます。もちろん、タイムステップを小さくするとシミュレーションも遅くなります。タイムステップは、ユーザーが調整できる最も重要なパラメータと言えるでしょう。大きすぎるとシミュレーションが不安定になります。小さすぎると、精度の有意な改善なしにCPU時間が浪費されます。タイムステップが「ちょうど良い」快適な範囲が常に存在しますが、その範囲はモデルに依存します。

   :ref:`integrator<option-integrator>`
    要約：推奨される積分器は ``implicitfast`` であり、通常、安定性と性能のトレードオフが最も優れています。

    **Euler**:
     古いモデルとの互換性のために ``Euler`` を使用してください。
    **implicitfast**:
     ``implicitfast`` 積分器は ``Euler`` と同程度の計算コストでありながら、安定性が向上するため、厳密に改善されたものです。ほとんどのモデルに推奨される積分器です。
    **implicit**:
     ``implicitfast`` に対する利点は、ジャイロスコピック力を含むコリオリ力と遠心力の陰的積分です。このような力を陰的に積分することで顕著な改善が得られる最も一般的なケースは、非対称な慣性を持つ自由物体が高速で回転している場合です。 `gyroscopic.xml <../_static/gyroscopic.xml>`__ は、傾斜面上を転がる楕円体が ``implicitfast`` では急速に発散するが、 ``implicit`` では安定する例を示しています。
    **RK4**:
     この積分器は、エネルギー保存的、またはほぼエネルギー保存的なシステムに最適です。 `pendulum.xml <../_static/pendulum.xml>`__ は、 ``Euler`` や ``implicitfast`` では急速に発散するが、 ``RK4`` ではエネルギーをよく保存する複雑な振り子機構を示しています。 ``implicit`` ではこのモデルは発散しませんが、エネルギーを失うことに注意してください。


.. Leave links below to sections that were previously here and have moved to the simulation chapter.
.. _gePhysicsState:
.. _geFullPhysics:
.. _geInput:
.. _geWarmstart:
.. _geIntegrationState:
.. _geSimulationState:

.. _geState:

状態
~~~~

一般的なフレームワークの説明を完了するために、 *状態* の概念について簡単に議論します。MuJoCoはコンパクトで明確に定義された内部状態を持ち、 :ref:`決定論的パイプライン<piReproducibility>` と合わせて、状態の（再）設定や動力学の微分の計算などの操作も明確に定義されています。

状態は :ref:`mjData` 構造体に完全にカプセル化されており、いくつかのコンポーネントで構成されています。コンポーネントは :ref:`mjtState` にビットフラグとして列挙されています。連結された状態ベクトルは、それぞれ :ref:`mj_getState` と :ref:`mj_setState` を使用して :ref:`mjData` から便利に読み取りおよび書き込みできます。

詳細については、シミュレーションの章の :ref:`状態と制御<siStateControl>` セクションを参照してください。

.. _Constraint:

制約モデル
----------

MuJoCoは非常に柔軟な制約モデルを持ちますが、後述する :ref:`ソルバー <Solver>` によって統一的に処理されます。ここでは、個々の制約が概念的に何であるか、そしてそれらが次元 :math:`\nq` のシステムレベルのベクトルと行列にどのように配置されるかを説明します。各概念的な制約は、総数 :math:`\nq` に対して1つ以上のスカラー制約を寄与でき、各スカラー制約は制約ヤコビアン :math:`J` の対応する行を持ちます。アクティブな制約は、以下で説明する順序でタイプごとに並べられ、各タイプ内ではモデル要素ごとに並べられます。タイプは、等式、摩擦損失、リミット、接触です。リミットはソルバーによって摩擦なし接触として処理され、内部的には別のタイプとして扱われません。 ``mjData`` では、制約関連データのシステムレベルのベクトルと行列を示すために接頭辞 ``efc`` を使用します。

.. _coEquality:

等式制約
~~~~~~~~

MuJoCoは一般的な形式 :math:`r(q) = 0` の等式制約をモデル化できます。ここで :math:`r` は位置ベクトル :math:`q` の任意の微分可能なスカラーまたはベクトル関数です。これは残差の意味を持ちます。ソルバーは非ホロノミック制約も扱うことができますが、そのような制約タイプはまだ定義されていません。各等式制約は、総制約数 :math:`\nq` に :math:`\dim(r)` 個の要素を寄与します。 :math:`J` の対応するブロックは単に残差のヤコビアン、すなわち :math:`\partial r / \partial q` です。クォータニオンの性質により、 :math:`q` に関する微分は :math:`\nq` ではなく :math:`\nv` のサイズのベクトルを生成することに注意してください。

等式制約は、他の用途のほかに、「ループジョイント」、すなわちキネマティックツリーではモデル化できないジョイントを作成するために使用できます。ゲームエンジンはすべてのジョイントをこの方法で表現します。MuJoCoでも同様のことが可能ですが、推奨されません。これは、シミュレーションがより遅くかつ精度が低くなり、MuJoCoを事実上ゲームエンジンに変えてしまうためです。ジョイントを等式制約で表現する唯一の理由は、ソフトジョイントをモデル化するためです。これは制約ソルバーを通じて可能ですが、キネマティックツリーでは不可能です。

次に5種類の等式制約を説明します。見出しの数字は、各ケースにおける制約残差の次元を示しています。

``connect`` : 3
   この制約は2つのボディを点で接続し、キネマティックツリーの外でボールジョイントを実質的に作成します。モデルは接続する2つのボディと、各ボディのローカルフレーム内の点（「アンカー」）を指定します。制約残差は、これらの点のグローバル3D位置の差として定義されます。同じボディペアに対して2つのconnect制約を指定すると、キネマティックツリーの外でヒンジジョイントをモデル化できることに注意してください。3つ以上のconnect制約（アンカーが一直線上にない）を指定することは、数学的にはweld制約と等価ですが、計算効率は劣ります。

``weld`` : 6
   この制約は2つのボディを溶接し、それらの間のすべての相対的な自由度を抑制します。制約ソルバーによって強制される相対的なボディの位置と方向は ``mjModel`` のパラメータです。コンパイラはモデルが定義された初期構成（ ``mjModel.qpos0`` ）からそれらを計算しますが、ユーザーは後から変更できます。6D残差は、connect制約と同一の3D位置成分に続いて3D方向成分を持ちます。後者は :math:`\sin(\theta/2) (x, y, z)` として定義されます。ここで :math:`\theta` はラジアン単位の回転角、 :math:`(x, y, z)` は回転軸に対応する単位ベクトルです。小さい角度では、これは方向差の指数写像表現に近づきます（2の因子を除く）。大きい角度では、 :math:`\theta` を直接使用した場合に生じるラップアラウンドの不連続性を回避します。ただし、角度が180度に近づくと制約が弱くなるという欠点があります。また、一方のボディが他方のボディの子である場合、weld制約を実装するより速く正確な方法は、子ボディに定義されたすべてのジョイントを単に削除することです。

``joint`` : 1
   この制約はスカラージョイント（ヒンジとスライド）にのみ適用されます。1つのジョイントを一定の位置にロックする、または4次多項式を介して2つのジョイントを結合するために使用できます。ジョイントのロックはジョイントを削除することで達成する方が良いですが、バックラッシュのモデル化（ソフト等式制約を使用）などの特殊なケースでは有用です。2つのジョイントの結合は、ヘリカルジョイントや他の形式の機械的結合のモデル化に有用です。4次多項式モデルは以下のように定義されます。 :math:`y` を第1ジョイントの位置、 :math:`x` を第2ジョイントの位置とし、添字0はモデルが初期構成 ``mjModel.qpos0`` にあるときの対応するジョイント位置を示すものとします。すると等式制約は以下のようになります。

   .. math::
      y-y_0 = a_0 + a_1 \left( x-x_0 \right) + a_2 \left( x-x_0 \right)^2 +
              a_3 \left( x-x_0 \right)^3 + a_4 \left( x-x_0 \right)^4

   ここで :math:`a_0, \ldots, a_4` はモデルで定義された係数です。制約が1つのジョイントのみに関わる場合、 :math:`y-y_0 = a_0` に簡約されます。

``tendon`` : 1
   この制約は上記のジョイント制約と非常に似ていますが、ジョイントの位置ではなくテンドンの長さに適用されます。テンドンは位置ベクトルに依存する長さの量です。この依存関係は、スカラージョイント位置の線形結合、または空間的な障害物を巻き付く最短長の紐であり得ます。モデル構成 ``mjModel.qpos0`` におけるジョイント位置を位置ベクトルから直接読み取れるジョイントとは異なり、テンドン長の計算はより複雑です。そのため、すべてのテンドンの「静止長」はコンパイラによって計算され ``mjModel`` に格納されます。一般に、 ``mjModel`` のフィールド名の末尾が0であるものはすべて、コンパイラが初期モデル構成 ``mjModel.qpos0`` で計算した量です。

``distance`` : 1
   .. attention::
      距離等式制約はMuJoCoバージョン2.2.2で削除されました。それ以前のバージョンを使用している場合は、対応するバージョンのドキュメントを参照してください。

.. _coFriction:

摩擦損失
~~~~~~~~

摩擦損失は乾燥摩擦、静摩擦、または荷重非依存摩擦（法線力に比例するクーロン摩擦との対比で）としても知られています。減衰や粘性と同様に、運動に対抗する効果がありますが、運動の開始前に先制的に作用するため、速度依存の力としてモデル化できません。代わりに、摩擦が生成できる力の絶対値の上限、すなわち制約としてモデル化されます。この上限は対応するモデル要素のfrictionloss属性を介して指定され、ジョイントとテンドンに適用できます。

摩擦損失は、関連付けられる位置残差がないという点で他のすべての制約タイプと異なります。そのため、 :math:`r(q)` の対応する成分を形式的にゼロに設定します。実際、後で見るように、この制約を組み込むには制約ソルバーの定式化を通常とは異なる方法で拡張する必要があります。それにもかかわらず、影響を受けるジョイントまたはテンドンの速度は速度「残差」として機能します。制約の効果はこの速度を減少させ、理想的にはゼロに保つことだからです。したがって、制約ヤコビアンの対応するブロックは、ジョイント位置（またはテンドン長）の :math:`q` に関するヤコビアンです。スカラージョイントの場合、ジョイントアドレスの位置に1があり残りが0のベクトルです。テンドンの場合、モーメントアームベクトルとして知られています。

``joint`` : 1, 3 または 6
   摩擦損失はスカラージョイント（スライドとヒンジ）だけでなく、3自由度のボールジョイントと6自由度のフリージョイントにも定義できます。定義された場合、影響を受けるジョイントのすべての自由度に独立して適用されます。frictionlossパラメータには、ジョイント（並進または回転）と互換性のある暗黙の単位があります。フリージョイントは並進成分と回転成分の両方を持つため例外であり、MJCFモデルフォーマットではジョイントごとに1つのfrictionlossパラメータしか許可されません。その場合、同じパラメータが並進成分と回転成分の両方に使用されます。フリージョイントの摩擦損失は許可すべきでないという議論もあり得ます。しかし、十分な力で押されるまで物体をその場に保つなど、有用な非物理的効果をモデル化できるため許可しています。

``tendon`` : 1
   テンドンはスカラー量であるため、テンドンに摩擦損失を定義すると常に1つのスカラー制約が追加されます。空間テンドンの場合、テンドンと巻き付く表面との間の摩擦をモデル化するために使用できます。ただし、この摩擦は荷重非依存になります。この現象のより詳細なモデルを構築するには、いくつかの小さな浮遊する球体を作成し、テンドンで直列に接続します。すると、球体と周囲の表面との間の接触は荷重依存（すなわちクーロン）摩擦を持ちますが、シミュレーション効率は低下します。

.. _coLimit:

リミット
~~~~~~~~

リミットと接触には明確に定義された空間残差がありますが、等式制約とは異なり片側的です。すなわち、等式制約ではなく不等式制約を導入します。リミットはジョイントとテンドンに定義できます。これは、対応するモデル要素を「limited」としてタグ付けし、その「range」パラメータを定義することで行われます。残差 :math:`r(q)` は、現在の位置/長さとrangeで指定された2つの制限値のうち近い方との間の距離です。この距離の符号は自動的に調整され、リミットに達していない場合は正、リミットに達した場合はゼロ、リミットが違反されている場合は負になります。制約はこの距離が「margin」パラメータを下回ったときにアクティブになります。ただし、これはリミットをmarginだけオフセットしてmarginを0に設定することとは同じではありません。代わりに、制約力は後述するソルバー :ref:`パラメータ <soParameters>` を通じて距離に依存します。

与えられたジョイントまたはテンドンに対して下限と上限の両方がアクティブになることがあり得ます。その場合、両方がスカラー制約のリストに含まれますが、この状況は避けるべきです。rangeを広げるかmarginを狭めることで回避できます。特に、等式制約を近似するために狭いrangeを使用することは避けてください。代わりに明示的な等式制約を使用し、ある程度の遊びが必要な場合はソルバーパラメータを調整して制約を柔らかくしてください。これは計算効率が良くなります。1つではなく2つのスカラー制約を含むためだけでなく、等式制約力の解法が一般に高速であるためです。

``joint`` : 1 または 2
   リミットはスカラージョイント（ヒンジとスライド）およびボールジョイントに定義できます。スカラージョイントは上述の通り処理されます。ボールジョイントのリミットは、ジョイントクォータニオンの指数写像または角度-軸表現、すなわちベクトル :math:`(\theta x, \theta y, \theta z)` に適用されます。ここで :math:`\theta` は回転角、 :math:`(x, y, z)` は回転軸に対応する単位ベクトルです。リミットは回転角 :math:`\theta` の絶対値に適用されます。実行時に、リミットは2つのrangeパラメータのうち大きい方によって決定されます。ただし、意味の明確さのために、2番目のrangeパラメータを使用してリミットを指定し、最初のrangeパラメータを0に設定するべきです。このルールはコンパイラによって強制されます。

``tendon`` : 1 または 2
   テンドンはスカラー量であり、そのリミットは上述の通り処理されます。固定テンドン（スカラージョイント位置の線形結合）は正と負の両方の「長さ」を持ち得ることに注意してください。ジョイント位置はジョイント参照に対して相対的に定義され、正にも負にもなり得るためです。ただし、空間テンドンは負にならない真の長さを持ちます。テンドンリミットのrangeとmarginを設定する際にはこの点を念頭に置いてください。

.. _coContact:

接触
~~~~

接触は最も精巧な制約タイプであり、モデルでの指定と必要な計算の両面で最も複雑です。これは、接触モデリングが元来困難であることに加え、接線方向、ねじり方向、転がり方向の摩擦、ならびに楕円および角錐摩擦円錐を含む一般的な接触モデルをサポートしているためです。

MuJoCoは点接触を使用します。点接触は、2つのジオム間の点とその点を中心とする空間フレームによって幾何学的に定義され、いずれもグローバル座標で表現されます。このフレームの第1軸（ :math:`x` ）は接触法線方向であり、残りの軸（ :math:`y` と :math:`z` ）は接線面を定義します。MuJoCoの可視化規則では法線が :math:`z` 軸に対応することを予想するかもしれませんが、法線軸のみを使用する摩擦なし接触をサポートしているため、法線を最初の位置に配置しています。リミットと同様に、接触距離は2つのジオムが離れている場合は正、接触している場合はゼロ、貫入している場合は負です。接触点は法線軸に沿って2つの表面の中間にあります（メッシュ衝突の場合、これは近似的な場合があります）。 :ref:`衝突検出 <Collision>` は別のトピックであり、後で詳しく議論します。今のところ必要なのは、接触点、空間フレーム、法線距離が衝突検出器によって与えられることだけです。

上記のオンラインで計算される量に加えて、各接触にはモデル定義から得られるいくつかのパラメータがあります。

.. list-table::
   :widths: 1 5
   :header-rows: 1

   * - パラメータ
     - 説明
   * - ``condim``
     - 接触フレームにおける接触力/トルクの次元。 |br| 1、3、4、または6を取ることができます。
   * - ``friction``
     - 次元が ``condim-1`` の摩擦係数ベクトル。個々の係数の意味については以下を参照してください。
   * - ``margin``
     - 接触をグローバル接触配列 ``mjData.contact`` に含めるべきかどうかを判定するために使用される距離マージン。
   * - ``gap``
     - カスタム計算のために、接触を ``mjData.contact`` に含めるが接触力を生成しないことが便利な場合があります。これが ``gap`` の機能です：接触力は法線距離が (margin - gap) を下回った場合にのみ生成されます。
   * - ``solref`` と ``solimp``
     - :ref:`ソルバー <Solver>` パラメータ。後述します。

接触摩擦円錐は楕円型または角錐型のいずれかです。これは制約ソルバーの選択によって決まるグローバル設定です：楕円ソルバーは楕円錐を、角錐ソルバーは角錐錐を使用し、後で定義されます。 ``condim`` パラメータは接触タイプを決定し、以下の意味を持ちます。

``condim = 1`` : 楕円で1、角錐で1
   これは摩擦なし接触に対応し、1つのスカラー制約のみを追加します。接触フレームの第1軸が接触法線であることを思い出してください。摩擦なし接触は法線方向の力のみを生成できます。これはジョイントまたはテンドンのリミットに非常に似ていますが、2つのジオム間の距離に適用されます。

``condim = 3`` : 楕円で3、角錐で4
   これは通常の摩擦接触であり、法線力と滑りに対抗する接線摩擦力を生成できます。この数値の解釈として、重力下で平らな物体が滑り始める表面の傾きがあります。

``condim = 4`` : 楕円で4、角錐で6
   法線力と接線力に加えて、この接触は接触法線周りの回転に対抗するねじり摩擦トルクを生成できます。これは接触表面パッチによって生成されるトルクに対応します。ソフトフィンガーのモデル化に有用であり、シミュレーションされた把持の安定性を大幅に改善できます。ねじり摩擦係数は **長さの単位** を持ち、表面接触パッチの直径として解釈できます。

``condim = 6`` : 楕円で6、角錐で10
   この接触は2つのジオム間のすべての相対的な自由度における運動に対抗できます。特に転がり摩擦を追加し、例えば平面上でボールが無限に転がることを防ぐために使用できます。現実世界の転がり摩擦は、接触点付近の局所的な変形によって散逸するエネルギーから生じます。タイヤと路面間の転がり摩擦のモデル化や、一般的に接触の安定化に使用できます。転がり摩擦係数も **長さの単位** を持ち、エネルギーが散逸する局所変形の深さとして解釈できます。

condimは2または5にはできないことに注意してください。これは、2つの接線方向と2つの転がり方向がペアとして扱われるためです。ただし、ペア内の摩擦係数は異なることができ、例えばスケーティングのモデル化に使用できます。

次に摩擦円錐と対応するヤコビアンをより形式的に説明します。このセクションでのみ、 :math:`f` を（システムレベルの制約力ベクトルではなく）単一の接触に対する制約力のベクトル、 :math:`\mu` を摩擦係数のベクトル、 :math:`n` を接触次元condimとします。 :math:`n > 1` の場合、楕円および角錐摩擦円錐は以下のように定義されます。

.. math::
   \begin{aligned}
   \text{elliptic cone}: & & \mathcal{K} &=
      \left\{ f \in \mathbb{R}^n : f_1 \geq 0,
              f_1^2 \geq \sum_{i=2}^n {f_i^2 / \mu_{i-1}^2} \right\} \\
   \text{pyramidal cone}: & & \mathcal{K} &=
      \left\{ f \in \mathbb{R}^{2(n-1)} : f \geq 0 \right\} \\
  \end{aligned}

角錐錐の定義におけるベクトル不等式は要素ごとを意味します。 :math:`n=1` の場合、両方の錐は非負の半直線として定義されます（これは錐の特殊なケースです）。以下のソルバーセクションで議論されるシステムレベルの摩擦円錐も :math:`\mathcal{K}` と表記されることに注意してください。それはここで定義された個々の接触の摩擦円錐の直積です。

制約力がシステムにどのように作用するかも指定する必要があります。これは :math:`f` の各成分に6D基底ベクトルを関連付けることで行われます。基底ベクトルは空間ベクトルであり、3D力に続く3Dトルクです。基底ベクトルを行列 :math:`E` の列に配置すると、制約力が接触フレームで生成する力/トルクは :math:`E f` です。基底ベクトルの行列は以下のように構成されます。

.. image:: ../images/computation/contact_frame.svg
   :width: 700px
   :align: center
   :class: only-light

.. image:: ../images/computation/contact_frame_dark.svg
   :width: 700px
   :align: center
   :class: only-dark

この図は :math:`n = 6` のケースに対応する完全な基底セットを示しています。それ以外の場合、錐のタイプに応じて最初の :math:`n` 列または :math:`2(n-1)` 列のみを使用します。楕円錐は理解しやすいです。行列 :math:`E` が単位行列であるため、 :math:`f` の最初の3成分は接触フレームの軸に沿って作用する力であり、次の3成分は軸の周りに作用するトルクです。角錐錐の場合、基底ベクトルは角錐の辺に対応します。各ベクトルは法線力成分と、摩擦力または摩擦トルク成分を組み合わせます。摩擦係数によるスケーリングにより、すべての基底ベクトルは近似している楕円摩擦円錐の内部に確実に収まります。これらのベクトルの任意の凸結合についても同様です。

最後に、接触ヤコビアンの計算方法を指定します。まず、関節速度 :math:`v` を接触フレームで表された空間速度 :math:`S v` にマッピングする :math:`6`-by-:math:`\nv` 行列 :math:`S` を構成します。これは、接触点が一方または他方のジオムに属するものとして扱い、その空間ヤコビアンを計算し、2つのヤコビアンを減算して :math:`S` を得ることで行われます。我々の規則では、接触力は第1ジオムから第2ジオムへ向かって作用するため、第1ジオムの空間ヤコビアンは負の符号を持ちます。接触ヤコビアンは :math:`E^T S` です。他のすべての制約と同様に、この行列はシステムレベルのヤコビアン :math:`J` に挿入されます。

.. _Solver:

制約ソルバー
------------

このセクションでは、制約力の計算方法を説明します。これは2段階で行われます。まず、制約力を凸最適化問題のグローバルな一意解として定義します。角錐錐の場合は二次計画問題、楕円錐の場合は錐計画問題です。次に、以下で説明するアルゴリズムを使用して最適化問題を解きます。制約モデルのパラメータと、それらが結果の動力学にどのように影響するかについても説明します。

最適化問題自体の定義には2つのステップがあります。まず、制約力が陰的である加速度 :math:`\dot{v}` 上で定義された主問題から始めます。次に、加速度の主問題をそのラグランジュ双対に変換します。双対は制約力に関する凸最適化問題であり、制約力は主問題のラグランジュ乗数の役割も果たします。順動力学では、主問題または双対問題のいずれかを数値的に解く必要があります。逆動力学では、問題は対角的になり、解析的に解くことができます。

主定式化は、ガウスの最小拘束の原理の一般化に基づいています。基本的な形式では、ガウスの原理は、制約なしの動力学 :math:`M \dot{v} = \tau` に加速度制約 :math:`J \dot{v} = \ar` を課した場合、結果として得られる加速度は以下であると述べています。

.. math::
   \dot{v} = \arg \min_x \left\| x-M^{-1} \tau \right\|^2_M \\
   \textrm{subject to} \; J x = \ar

ここで重み付き :math:`L_2` ノルムは通常の :math:`\|x\|^2_M = x^T M x` です。したがって、制約は制約なし加速度 :math:`M^{-1}\tau` からの最小の偏差を引き起こし、関節座標における偏差を測定するメトリックは慣性行列によって与えられます。この原理は、制約付き運動のラグランジュ・ダランベールの原理と等価であることが知られています。ここでは、ソフト制約の豊かで原則的なモデルを得るためにこれを使用します。これは、ガウスの原理のコスト関数と制約の両方を一般化することで行われます。

先に導入した記法に加えて、以下の記法を使用します。

.. list-table::
   :widths: 1 1 4
   :header-rows: 1

   * - 記号
     - サイズ
     - 説明
   * - :math:`z`
     - :math:`\nq`
     - 制約変形
   * - :math:`\omega`
     - :math:`\nq`
     - 制約変形の速度
   * - :math:`k`
     - :math:`\nq`
     - 仮想制約剛性
   * - :math:`b`
     - :math:`\nq`
     - 仮想制約減衰
   * - :math:`d`
     - :math:`\nq`
     - 制約インピーダンス
   * - :math:`A(q)`
     - :math:`\nq \times \nq`
     - 制約空間の逆慣性
   * - :math:`R(q)`
     - :math:`\nq \times \nq`
     - 制約空間の対角正則化項
   * - :math:`\ar`
     - :math:`\nq`
     - 制約空間の参照加速度
   * - :math:`\au(q, v, \tau)`
     - :math:`\nq`
     - 制約空間の制約なし加速度
   * - :math:`\ac(q, v, \dot{v})`
     - :math:`\nq`
     - 制約空間の制約付き加速度
   * - :math:`\mathcal{K}(q)`
     -
     - すべての接触摩擦円錐の直積
   * - :math:`\eta`
     -
     - 摩擦損失力の上界
   * - :math:`\Omega(q)`
     -
     - 許容制約力の凸集合
   * - :math:`\mathcal{E}, \mathcal{F}, \mathcal{C}`
     -
     - 等式、摩擦損失、接触制約のインデックス集合

インデックス集合はベクトルと行列の部分を参照するために使用されます。例えば、 :math:`J_\mathcal{C}` は接触制約に対応するヤコビアンのすべての行の部分行列です。

.. _soPrimal:

主問題
~~~~~~

まず、制約付き加速度 :math:`\dot{v}` を解として与える最適化問題を定式化し、次にその意味と妥当性を説明します。その問題は以下です。

.. math::
   (\dot{v}, \dot{\omega}) = \arg \min_{(x, y)}
                             \left\|x-M^{-1}(\tau-c)\right\|^2_M +
                             \left\|y-\ar\right\|^{\text{Huber}(\eta)}_{R^{-1}} \\
   \textrm{subject to} \;
   J_\mathcal{E} x_\mathcal{E} - y_\mathcal{E} = 0, \;
   J_\mathcal{F} x_\mathcal{F} - y_\mathcal{F} = 0, \;
   J_\mathcal{C} x_\mathcal{C} - y_\mathcal{C} \in \mathcal{K}^*
   :label: eq:primal

ここでの新しい要素は、制約をソフトにする対角正則化項 :math:`R > 0` と、制約を安定化する参照加速度 :math:`\ar` です。後者はボーマガルテ安定化と精神的に似ていますが、制約力を直接加える代わりに、解が制約力となる最適化問題を修正します。この問題自体が制約付きであるため、 :math:`\ar` と :math:`f` の関係は一般に非線形です。量 :math:`R` と :math:`\ar` は後述するようにソルバー :ref:`パラメータ <soParameters>` から計算されます。ここではそれらが与えられているものと仮定します。

最適化変数 :math:`x` はガウスの原理と同様に加速度を表し、 :math:`y` は制約空間のスラック変数です。ソフト制約をモデル化するために必要です。解が :math:`y = \ar` に到達するよう強制する場合（これは極限 :math:`R \to 0` を取ることで可能）、ハード制約モデルが得られます。この極限はMuJoCoでは許可されていませんが、それでも現象論的にハードなモデルを構築することは可能です。

記号 :math:`\mathcal{K}^*` は摩擦円錐の双対を表します。これは数学的なリバースエンジニアリングによって動機付けられています：主問題の双対を取った後に制約 :math:`f \in \mathcal{K}` を回復したいのですが、錐の双対の双対は錐自身です。先に定義した角錐摩擦円錐は実際に自己双対ですが、楕円錐はそうではありません。

フーバー「ノルム」はロバスト統計のフーバー関数に基づいています：ゼロ付近では二次であり、引数の絶対値が閾値を超えると線形関数に滑らかに遷移します。この場合の閾値は摩擦損失パラメータによって与えられます。 :math:`\eta = \infty` と設定すると二次ノルムが回復されます。摩擦損失による制約力以外のすべてにこの規則を使用します。これもリバースエンジニアリングの一例です：摩擦損失力に対する区間制約を得たいのですが、ラグランジュ双対性は通常、非負制約を生じるため、これは自明ではありません。双対で区間制約を得るために必要なのがまさにフーバー関数であることがわかります。摩擦損失制約がない場合、両方のノルムは二次になります。

次に、問題 :eq:`eq:primal` をガウスの原理にさらに密接に関連付け、スラック変数に物理的意味を与えます。位置 :math:`(q, z)` と速度 :math:`(v, \omega)` を持つ拡張力学系を考えます。新しい状態変数は変形ダイナミクスに対応します。元のシステムで :math:`v` が :math:`\dot{q}` と同じではないのと同様に、ここで :math:`\omega` は :math:`\dot{z}` と同じではありませんが、理由は異なります。変形は非ゼロの位置残差に関連しています。等式制約、リミット、角錐摩擦円錐のすべての成分、および楕円摩擦円錐の法線成分について、明確に定義された位置残差があることを思い出してください。これらの変形変数に対しては :math:`\dot{z} = \omega` です。しかし、摩擦損失と楕円錐の摩擦成分に対しては :math:`z = 0` である一方 :math:`\omega \neq 0` です。これは、制約空間に運動が存在する可能性があっても（制約力はそれを防ごうとする）、位置誤差がないためです。拡張ダイナミクスは以下の通りです。

.. math::
   \begin{aligned}
   \tilde{q} &= {q \brack z}, &
   \tilde{v} &= {v \brack \omega}, &
   \tilde{c} &= {c \brack 0}, \\
   \tilde{\tau} &= {\tau \brack {R^{-1} \ar}}, &
   \tilde{M} &= \left[\begin{array}{cc}
                      M & 0 \\
                      0 & R^{-1}
                      \end{array} \right], &
   \tilde{J} &= \left[ \begin{array}{cc}J & -I \end{array} \right] \\
   \end{aligned}

このシステムにガウスの原理を適用すると、フーバーノルムを除いて上記の主最適化問題が得られます。一般的な運動方程式 :eq:`eq:motion` は以下のようになります。

.. math::
   \tilde{M} \dot{\tilde{v}} + \tilde{c} = \tilde{\tau} + \tilde{J}^T f

すべてのチルダを展開すると、元のダイナミクスと変形ダイナミクスの明示的な形式が得られます。

.. math::
   \begin{aligned}
   M \dot{v} + c &= \tau +J^T f \\
   \dot{\omega} &= \ar - R f \\
   \end{aligned}

したがって、 :math:`R` は逆変形慣性の意味を持ち、 :math:`\ar` は力が加わらない場合の変形加速度の意味を持ちます。

MuJoCoはこれらの変形変数をシステム状態の一部として保持し、関節位置と速度とともにそのダイナミクスを積分するのでしょうか？いいえ、そうしませんが、そのようなオプションは将来提供する価値があるかもしれません。正則化項と参照加速度の関数的依存性を :math:`R(q)` と :math:`\ar(q, v)` と定義したことを思い出してください。これにより問題 :eq:`eq:primal` は :math:`(q, v, \tau)` にのみ依存し、元のダイナミクスは実際には変形ダイナミクスの影響を受けません。ここまで開発した一般的な制約モデルは :math:`R` と :math:`\ar` の計算方法について仮定を置かないため、我々の選択は整合的であり、シミュレータの効率を向上させます。それにもかかわらず、これらの量が変形ダイナミクスに関連することが判明したため、 :math:`R(z)` と :math:`\ar (z, \omega)` と定義し、拡張システム全体をシミュレートする方がより自然かもしれません。以下では、そのようなシミュレーションの利点の一部を明確にします。

変形ダイナミクスが元のダイナミクスを正確に「追跡」するのはいつでしょうか？これは制約力 :math:`f` が以下のパラメータセクションで定義される量 :math:`f^+` に等しい場合に発生することが確認できます。その場合、変形状態は関節位置と速度の静的関数、すなわち :math:`z = r(q)` および :math:`\omega = J(q) v` になります。しかし一般にはそうではありません。指をソフトな素材に押し込み、素材が形状を回復するより速く引き抜き、再び押し込む場合を考えてみてください。2回目の押し込みで経験する接触力は、指と物体の剛体位置だけでなく、最初の押し込みで生じた素材の変形にも依存します。上記の拡張ダイナミクスをシミュレートすればこの現象を捉えることができますが、MuJoCoに実装されたモデルはこれを無視し、代わりにすべての物体が次の接触の前に形状を回復すると仮定します。摩擦方向の滑りに関連する同様の現象も無視されています。

.. _soReduced:

縮約主問題
~~~~~~~~~~

:eq:`eq:primal` で定義された主問題、および後で得られる双対問題は、いずれも制約付き最適化問題です。双対問題はより単純な形式になりますが、それでも制約付き最適化は数値的には制約なし最適化より効率が劣ります。主問題は加速度に関する制約なし最適化に縮約できることがわかります。 :eq:`eq:primal` において :math:`x` が与えられている場合、 :math:`y` に関する最小化は閉形式で行えます。これにより制約も除去されます。つまり、 :math:`y` の解は自動的に制約を満たします。すると、 :math:`x` に関する制約なし最適化問題が残り、より効率的なアルゴリズムで解くことができます。

この縮約は、 :eq:`eq:primal` における :math:`y` に関する最小化が制約集合上の最近点を求めることに帰着するという事実に基づいています。制約集合は平面または錐のいずれかであり、解析的に求めることができます。結果を代入すると、以下の制約なし問題が得られます。

.. math::
   \dot{v} = \arg \min_{x} \left\|x-M^{-1}(\tau-c)\right\|^2_M +
             s \left( J x - \ar \right)
   :label: eq:reduced

関数 :math:`s(\cdot)` はソフト制約ペナルティの役割を果たします。この関数は凸であり、一回連続微分可能であることが示されます。角錐摩擦円錐の場合、これは二次スプラインです。

縮約定式化のもう一つの魅力的な特徴は、逆動力学が容易に計算できることです。上記の問題は制約なしかつ凸であるため、一意のグローバル最小値は勾配をゼロにします。これにより以下の恒等式が得られます。

.. math::
   M \dot{v} + c = \tau - J^T \nabla s \left( J \dot{v} - \ar \right)

これはソフト制約の存在下での解析的な逆動力学です。運動方程式 :eq:`eq:motion` と比較すると、制約力 :math:`f` は関数 :math:`s(\cdot)` の負の勾配で与えられることがわかります。 :math:`\dot{v}` に関してもう一度微分すると以下が得られます。

.. math::
   \frac{\partial \tau}{\partial \dot{v}} = M + J^T H[s] J

これは加速度に対する印加力の解析的導関数です。したがって、関数 :math:`s(\cdot)` とその導関数がMuJoCoの物理モデルの鍵であることがわかります。

.. _soDual:

双対問題
~~~~~~~~

ラグランジュ双対を構成する手続きはやや煩雑ですが、確立された方法です。結果に進みます。上で定義された主問題に対するラグランジュ双対は以下です。

.. math::
   f = \arg\min_\lambda \frac{1}{2} \lambda^{T} \left( A+R \right) \lambda +
       \lambda^T \left( \au - \ar \right) \\
   \text{subject to} \; \lambda \in \Omega
   :label: eq:dual

ここで、制約空間における逆慣性は

.. math::
   A = J M^{-1} J^T

であり、制約空間における制約なし加速度は

.. math::
   \au = J M^{-1} (\tau-c) + \dot{J} v

です。

制約集合 :math:`\Omega` は以下の通りです。 :math:`\lambda_\mathcal{E}` は制約なしです。これは主問題における等式制約のラグランジュ乗数だからです。摩擦損失に対しては、要素ごとにボックス制約 :math:`\left|\lambda_\mathcal{F}\right| \leq \eta` が適用されます。接触に対しては :math:`\lambda_\mathcal{C} \in \mathcal{K}` です。角錐錐の場合、これは単に :math:`\lambda_\mathcal{C} \geq 0` であり、楕円錐の場合は二次錐制約です。 :math:`A` は対称半正定値行列にすぎませんが、 :math:`R` は構成上対称正定値であるため、上記の二次コストは狭義凸です。したがって、角錐摩擦円錐に対してはボックス制約付きの凸二次計画問題となり、楕円摩擦円錐に対してはボックス制約と二次錐制約の混合問題となります。この問題を解くための :ref:`アルゴリズム <soAlgorithms>` については後述します。

先に述べたように、MuJoCoの制約モデルは一意に定義された逆動力学を持ち、縮約定式化において導出する方法の一つをすでに見ました。ここでは双対定式化から再度導出します。逆動力学では :math:`(q, v, \tau)` の代わりに :math:`(q, v, \dot{v})` にアクセスできるため、制約なし加速度 :math:`\au` は未知です。しかし、制約付き加速度は計算できます。

.. math::
   \ac = J \dot{v} + \dot{J} v

逆動力学は以下の最適化問題を解くことで計算できます。

.. math::
   f = \arg \min_\lambda \frac{1}{2} \lambda^{T} R \lambda +
       \lambda^T \left( \ac - \ar \right) \\
   \text{subject to} \; \lambda \in \Omega

これら2つの凸最適化問題のKKT条件を比較することで、以下の場合にそれらの解が一致することが確認できます。

.. math::
   \ac = \au + Af
   :label: eq:identity

この重要な恒等式は、本質的にニュートンの第二法則を制約空間に射影したものです。運動方程式 :eq:`eq:motion` の項 :math:`c` を右辺に移動し、左から :math:`J M^{-1}` を掛け、両辺に :math:`\dot{J} v` を加え、上記の :math:`A, \au, \ac` の定義を代入することで導出されます。実装上、加速度項 :math:`\dot{J} v` は実際には計算しません。これは、最適化問題が制約空間加速度の差に依存するため、この項は計算したとしても相殺されるからです。

逆問題の二次項が :math:`A+R` ではなく :math:`R` で重み付けされていることに注意してください。これは2つのことを教えてくれます。第一に、ハード制約に対応する極限 :math:`R \to 0` では逆問題がもはや定義されません。これは予想通りです。第二に、より実用的なこととして、逆問題は対角的です。すなわち、個々の制約力に関する独立した最適化問題に分離されます。残る唯一の結合は制約集合 :math:`\Omega` によるものですが、その集合もまた先に議論した概念的な制約にわたって分離されています。これらの独立した最適化問題はすべて解析的に解けることがわかります。唯一の自明でないケースは楕円摩擦円錐モデルです。上記で参照した `論文 <https://scholar.google.com/scholar?cluster=9217655838195954277>`__ でその処理方法を示しました。これは :math:`R` の対角値の特定の結合を必要とし、すべてのモデルに対して正確な解析的逆を可能にするようMuJoCoによって自動的に適用されます。

順動力学が計算されると、逆動力学の計算コストは実質的にゼロです。これは、順動力学が逆問題に入るすべての量を必要とするため、唯一の追加ステップは解析的な公式だけだからです。これにより、MuJoCoに自動的な正確性チェックを実装することが可能になります。 ``mjModel.opt.enableflags`` の ``fwdinv`` フラグがオンの場合、各タイムステップの終わりに順動力学と逆動力学が自動的に比較され、その差が ``mjData.solver_fwdinv`` に記録されます。不一致は、順方向ソルバー（数値的であり通常は早期に終了される）がうまく収束していないことを示します。もちろん、逆動力学は順動力学を先に計算せずに、それ自体で有用です。

.. _soAlgorithms:

アルゴリズム
~~~~~~~~~~~~

ここでは、上記の凸最適化問題を解くための数値アルゴリズム（「ソルバー」）について説明します。ニュートンソルバーとCGソルバーは縮約主定式化 :eq:`eq:reduced` を使用し、PGSソルバーは双対定式化 :eq:`eq:dual` を使用します。数値ソルバーは順動力学でのみ必要であることに注意してください。逆動力学は解析的に処理されます。

各ソルバーアルゴリズムは、角錐摩擦円錐と楕円摩擦円錐の両方、および制約ヤコビアンと関連行列の密表現と疎表現の両方で使用できます。

**CG** ：共役勾配法
   このアルゴリズムは、ポラック・リビエール・プラス公式による非線形共役勾配法を使用します。直線探索は正確であり、解析的な二次導関数を用いた1次元のニュートン法を使用します。

**Newton** ：ニュートン法
   このアルゴリズムは、解析的な二階導関数とヘッセ行列のコレスキー分解を用いた厳密なニュートン法を実装します。直線探索はCG法と同じです。これがデフォルトのソルバーです。

**PGS** ：射影ガウス・ザイデル法
   これは物理シミュレータで最も一般的に使用されるアルゴリズムであり、あらゆる面で優れていると思われるニュートン法を開発するまではMuJoCoのデフォルトでした。PGSは双対定式化を使用します。解を斜め方向に改善する勾配ベースの手法とは異なり、ガウス・ザイデルは一度に1つのスカラー成分に対して作用し、他のすべての成分の現在値が与えられた下でその最適値に設定します。PGSの1回のスイープは1回の行列ベクトル積と同程度の計算量です（ただし定数はより大きい）。一次収束ですが、それでも数回の反復で急速に進展します。

   .. image:: ../images/computation/gPGS.svg
      :width: 500px
      :align: center
      :class: only-light

   .. image:: ../images/computation/gPGS_dark.svg
      :width: 500px
      :align: center
      :class: only-dark

   角錐摩擦円錐を使用する場合、問題はPGSが伝統的に適用されてきたボックス制約を含みます。楕円摩擦円錐から生じる錐制約にPGSを直接適用すると、局所最小値の連続体に捕らわれます（左パネル参照）。これは座標軸に沿ってしか進展できないためです。右パネルは我々のこの問題に対する解決策を示しています。引き続き一度に1つの接触を更新しますが、接触内では制約面に適応した非直交軸に沿って更新します。その手順は以下の通りです。まず、錐の頂点から現在の解を通る光線に沿って二次コストを最適化します。次に、現在の解を通り接触法線に直交する超平面で錐を切断します。これにより、我々の接触モデルにおいて最大5次元になりうる楕円体が得られます。この楕円体内で二次コストを最適化します。これは二次制約付き二次計画問題（QCQP）のインスタンスです。スカラー制約が1つだけなので（それがどれほど非線形であっても）、双対は未知のラグランジュ乗数に関するスカラー最適化問題です。この問題を収束までニュートン法で解きます。実際には10回未満の反復で済み、小さな行列を扱います。全体として、このアルゴリズムは角錐錐に対するPGSと同様の挙動を示しますが、楕円錐を近似することなく扱えます。接触あたりの計算量は増えますが、接触の次元は小さく、これら2つの要因はおおよそ相殺されます。

.. _soIsland:

制約アイランド
~~~~~~~~~~~~~~

.. image:: ../images/computation/island.svg
   :width: 58%
   :align: right

自由度（ :ref:`DOF<ElemDof>` ）と制約によって定義される抽象グラフを考えます。頂点は単一のキネマティック :ref:`ツリー<ElemTree>` 内のすべてのDOFであり、辺は異なるツリーに属する2つのボディ間の制約（接触、等式、またはテンドンリミット）です。 *制約アイランド* とは、制約力がアイランド間で伝播できないため独立に解くことができる互いに素な部分グラフです。制約アイランドの発見と構成（「アイランディング」）は、これらの互いに素な部分グラフを見つけ、DOFと制約の両方を並べ替えてメモリ上で連続にすることを含みます。これは図に示されているように、制約ヤコビアン :math:`J` のブロック対角化に相当します。左側はサイズ :math:`\nc \times \nv` のモノリシックなヤコビアンであり、MuJoCoのデータ構造 ``mjData.nefc`` および ``mjModel.nv`` から :ref:`対応する <Framework>` サイズ名を使用しています。右側は独立に解ける3つのアイランドを持つブロック対角化されたヤコビアンです。アイランディングは制約のないDOFも特定するため、すべてのアイランド内のDOFの総数である ``mjData.nidof`` は ``mjModel.nv`` より小さくなる可能性があります。アイランディングはコストがゼロではありませんが（ `engine_island.c <https://github.com/google-deepmind/mujoco/blob/main/src/engine/engine_island.c>`__ の実装を参照）、その価値があります。

- 異なるアイランドは収束に異なる反復回数を必要とし、モノリシックな求解は最も遅いアイランドが必要とする回数だけ実行されます。
- 制約のないDOFはソルバーにまったく触れられません。そうでなければソルバーはそれらが影響を受けないことを発見する必要があります。
- 個別のアイランドの求解はマルチスレッド化できます。

.. admonition:: 既知の問題
   :class: note

   アイランディングはPGSソルバーではまだサポートされていません。


.. _soParameters:

パラメータ
~~~~~~~~~~

ここでは、量 :math:`R, \ar` がモデルパラメータからどのように計算されるかを説明します。選択されたパラメータ化が意味をなすためには、まずこれらの量が動力学にどのように影響するかを理解する必要があります。 :eq:`eq:dual` の制約なし最小化解、すなわち

.. math::
   f^+ = (A+R)^{-1} (\ar - \au)

に着目します。

:math:`f^+ \in \Omega` である場合、 :math:`f^+ = f` は我々のモデルが生成する実際の制約力です。この場合に着目するのは、それが一般的だからです。つまり、任意の時点で活性化する :math:`\Omega` 内の制約の部分集合は通常小さく、さらにこれが実際に解析可能な唯一の場合だからです。制約ダイナミクス :eq:`eq:identity` に :math:`f^+` を代入して項を整理すると、以下が得られます。

.. math::
   \ac = A(A+R)^{-1} \ar + R (A+R)^{-1} \au

したがって、制約付き加速度は制約なし加速度と参照加速度の間を補間します。特に、極限 :math:`R \to 0` ではハード制約であり :math:`\ac = \ar` となり、極限 :math:`R \to \infty` では無限にソフトな制約（すなわち制約なし）であり :math:`\ac = \au` となります。そこで、補間を直接制御するモデルパラメータを導入するのが自然です。このパラメータを *インピーダンス* と呼び、 :math:`d` と表記します。これは次元 :math:`\nq` のベクトルで、要素ごとに :math:`0<d<1` を満たします。これが指定されると、正則化項の対角要素を以下のように計算します。

.. math::
   R_{ii} = \frac{1-d_i}{d_i} \hat{A}_{ii}

ここで、実際の :math:`A` 行列の対角ではなく、その近似を使用していることに注意してください。これは、疎ソルバーや逆動力学において :math:`A` を計算する必要をなくすためです。この近似（対角に限定されます）は、モデルが初期配置 ``mjModel.qpos0`` にあるときの、すべてのボディ、ジョイント、テンドンの「エンドエフェクタ」慣性を用いて構成されます。これらの量はコンパイラによって計算されます。近似がたまたま正確であり、 :math:`A` 自体がたまたま対角であった場合、各スカラー制約の加速度は以下を満たします。

.. math::
   \aci = d_i \ari + (1-d_i) \aui

したがって、望ましい補間効果が得られます。もちろん一般にはこれは正確には成り立ちませんが、ここでの目標は制約モデルの合理的で直感的なパラメータ化を構成し、スケーリングを正しくすることです。

次に、参照加速度の計算方法を説明します。既に述べたように、要素ごとの *減衰* と *剛性* の係数でパラメータ化されたバネ・ダンパーモデルを使用します。

.. math::
   \ari = -b_i (J v)_i - k_i r_i

ここで :math:`r` は位置残差（摩擦損失と楕円錐の摩擦方向ではゼロ）であり、 :math:`J v` は制約空間に射影された関節速度です。添字表記は射影速度ベクトルの1成分を指します。

要約すると、ユーザーはインピーダンス係数のベクトル :math:`0<d<1`、減衰係数 :math:`b > 0`、剛性係数 :math:`k > 0` を指定します。量 :math:`R, \ar` は上に示したようにMuJoCoによって計算され、選択された最適化アルゴリズムが問題 :eq:`eq:dual` を解くために適用されます。Modelingの章の :ref:`ソルバーパラメータ <CSolver>` セクションで説明されているように、MuJoCoは臨界減衰を達成したり、距離に応じて :math:`d` を変化させることでソフト接触層をモデル化するなど、 :math:`d, b, k` を設定するための追加的な自動化を提供しています。

.. _soCones:

摩擦円錐
~~~~~~~~

上で説明したように、MuJoCoは楕円摩擦円錐とその角錐近似の両方を許容します。選択されたソルバーがどの種類の摩擦円錐を使用するかを決定します。角錐近似は :math:`2 (n-1)` 個の辺を持ち、 :math:`n` はcondimで指定される接触空間の次元数です。より多くの辺を追加すれば基礎となる楕円錐へのより良い近似が得られますが、結果として得られるソルバーが楕円の対応物より遅くなるため、意味がありません。

角錐近似の辺の数を増やせば、最適化問題 :eq:`eq:primal` の解が楕円錐の解に収束すると期待されたかもしれません。ハード接触の極限ではこれは正しいです。しかしソフト接触では、これは正しくないことがわかります。この意外な事実は単なる数学的好奇心ではなく、動力学に目に見える影響を及ぼす可能性があります。MuJoCoの以前のバージョンでは、角錐近似で精密な把持行動を実現することが困難でした。この現象を理解するために、問題 :eq:`eq:primal` の加速度変数 :math:`x` を固定し、変形変数 :math:`y` を最適化することを考えます。結果として得られる :math:`x` に関する最適化問題は、制約境界から始まる半二次ペナルティを用いた制約付き最適化のペナルティ法と等価であることが示せます。境界によって投射される「影」と考えてください。この影の形は、近似がどれほど正確であっても、楕円錐とその角錐近似では異なります。下の図は、角錐が近似ですらなく楕円錐と同じ制約集合を表す2D接触の場合にこの効果を示しています。角錐（赤）と楕円（破線の青）の錐について、左から右へ摩擦係数を変化させながらペナルティ/影の等高線を描いています。数学的には、角錐の場合のペナルティは二次スプラインであり、楕円の場合のペナルティは二次式から二次式の平方根を引いたものを含み、錐の先端周りの円形等高線を可能にします。

.. image:: ../images/computation/softcontact.png
   :width: 600px
   :align: center
   :class: only-light

.. image:: ../images/computation/softcontact_dark.png
   :width: 600px
   :align: center
   :class: only-dark

要約すると、楕円摩擦円錐と角錐摩擦円錐は異なるソフト接触動力学を定義します（通常は非常に近いですが）。楕円モデルはより原理的であり物理的直感とより一致しており、対応するソルバーはかなり効率的ですが、モデルによっては角錐ソルバーほど効率的でない場合があります。

.. _Collision:

衝突検出
--------

衝突検出はジオムに対して動作します。ジオムは基礎となるボディに剛体として取り付けられた幾何学的エンティティです。衝突検出の出力は、接触距離がマージンパラメータより小さいものとして定義されるアクティブな接触のリストです。これらはグローバル配列 ``mjData.contact`` に格納され、制約ヤコビアンの構成と制約力の計算に使用されます。以下では、衝突チェックのためにジオムペアがどのように選択されるか、衝突チェックがどのように行われるか、および結果として得られる接触のパラメータがどのように決定されるかを説明します。

.. _coSelection:

選択
~~~~

モデルに :math:`n` 個のジオムがある場合、衝突する可能性のあるジオムペアは :math:`n (n-1)/2` 組あります。これらすべてのペアを詳細にチェックすること（ニアフェーズ衝突検出とも呼ばれます）は、大規模システムでは計算コストが非常に高くなります。幸いなことに、これらの潜在的な衝突の一部はモデリング段階でユーザーによって除外されるため不要であり、他の一部は詳細なチェックなしに素早く刈り込むことができます。MuJoCoには、どのジオムペアを詳細にチェックするかを決定するための柔軟なメカニズムがあります。決定プロセスは生成とフィルタリングの2段階を含みます。

生成
   まず、2つのソースからの結合により候補ジオムペアのリストを生成します。衝突する可能性のあるジオムを含むボディのペアと、MJCFの :ref:`pair <contact-pair>` 要素で定義されたジオムペアの明示的なリストです。

   ボディペアは、修正されたスイープ・アンド・プルーンアルゴリズムに基づくブロードフェーズ衝突検出によって生成されます。修正点は、ソートに使用する軸がすべてのジオム中心の共分散行列の主固有ベクトルとして選ばれることです。これにより広がりが最大化されます。次に、各ボディペアに対して、軸に沿った境界ボックス（AABB）の静的バウンディングボリューム階層（BVH二分木）を使用してミッドフェーズ衝突検出が実行されます。各ボディはそのジオムのAABBツリーを備えており、内部ノードとリーフノードのそれぞれについてボディ慣性フレームまたはジオムフレームに整列しています。

   最後に、ユーザーはMJCFの :ref:`exclude <contact-exclude>` 要素を使用して特定のボディペアを明示的に除外できます。このステップの終了時には、通常 :math:`n (n-1)/2` よりもはるかに小さいジオムペアのリストが得られますが、詳細な衝突チェックの前にさらに刈り込むことができます。

フィルタリング
   次に、前のステップで生成されたリストに4つのフィルタを適用します。フィルタ1と2はすべてのジオムペアに適用されます。フィルタ3と4はボディペアメカニズムによって生成されたペアにのみ適用され、ユーザーがジオムペアを明示的に指定することでこれらのフィルタをバイパスできるようにしています。

   1. 2つのジオムのタイプが、詳細チェックを実行できる衝突関数に対応している必要があります。これは通常該当しますが例外もあります（例えば平面同士の衝突はサポートされていません）。さらに、ユーザーはデフォルトの衝突関数テーブルをNULLポインタで上書きでき、特定のジオムタイプ間の衝突を実質的に無効にできます。
   2. 接触マージンを考慮した境界球テスト（バウンディングスフィアテスト）が適用されます。ペア内のジオムの一方が平面の場合、これは平面-球テストになります。
   3. 2つのジオムは同じボディに属してはなりません。さらに、親が世界ボディでない限り、親と子のボディに属してはなりません。これは、ボディ内やジョイント内での永続的な接触を避けるためです。複数のボディが間にジョイントがないという意味で溶接されている場合、このテストの目的では単一のボディとして扱われることに注意してください。親フィルタテストはユーザーが無効にできますが、同一ボディテストは無効にできません。
   4. 2つのジオムは以下の意味で「互換性」がなければなりません。各ジオムは整数パラメータ ``contype`` と ``conaffinity`` を持ちます。テストに合格するには以下のブール式がtrueである必要があります：

      ``(contype1 & conaffinity2) || (contype2 & conaffinity1)``

      これは一方のジオムの ``contype`` と他方のジオムの ``conaffinity`` に共通のビットが1に設定されていることを要求します。これはOpen Dynamics Engineから借用した強力なメカニズムです。すべてのジオムのデフォルト設定は ``contype = conaffinity = 1`` であり、常にテストに合格するため、最初はこのメカニズムがわかりにくい場合は無視できます。

.. _coChecking:

チェック
~~~~~~~~
ニアフェーズまたは narrow-phase_ 衝突検出とも呼ばれる詳細な衝突チェックは、ペア内のジオムタイプに依存する関数によって実行されます。ナローフェーズ衝突関数のテーブルは `engine_collision_driver.c <https://github.com/google-deepmind/mujoco/blob/main/src/engine/engine_collision_driver.c>`__ の先頭で確認でき、独自のコライダーをインストールしたいユーザーには :ref:`mjCOLLISIONFUNC` として公開されています。MuJoCoはいくつかのプリミティブな幾何形状をサポートしています：平面、球、カプセル、円筒、楕円体、ボックスです。また、三角形メッシュとハイトフィールドもサポートしています。

.. _narrow-phase: https://en.wikipedia.org/wiki/Collision_detection#Narrow_phase

:ref:`SDFプラグイン<exSDF>` （関連ドキュメントを参照）の注目すべき例外を除き、衝突検出は *凸* ジオムに限定されます。すべてのプリミティブタイプは凸です。ハイトフィールドは凸ではありませんが、内部的には三角柱のコレクションとして扱われます（上述のフィルタに加えてカスタムの衝突刈り込みを使用します）。ユーザーが指定したメッシュは非凸である可能性があり、そのままレンダリングされます。しかし衝突の目的では、 `qhull <http://www.qhull.org/>`__ ライブラリによって計算された凸包に置き換えられます（ :ref:`simulate <saSimulate>` で'H'キーにより可視化できます）。

.. _coCCD:

凸衝突
^^^^^^
解析的なコライダーを持たないジオムペア（例えばメッシュ）を含むすべての衝突は、2つの汎用凸衝突検出（CCD）パイプラインのいずれかによって処理されます。

ネイティブパイプライン（デフォルト）
  ネイティブCCDパイプライン（"nativeccd"）はMuJoCoにネイティブ実装されており、ギルバート・ジョンソン・キールティ法と拡張ポリトープアルゴリズム（GJK_ / EPA_）に基づいています。ネイティブパイプラインはMPRベースのパイプラインよりも高速かつ頑健です。

libccdパイプライン（レガシー）
  このレガシーパイプラインは libccd_ ライブラリに基づいており、ミンコフスキーポータル改良法（MPR_）を使用します。 :ref:`nativeccd<option-flag-nativeccd>` フラグを無効にすることでアクティブになります。

.. _libccd: https://github.com/danfis/libccd
.. _MPR: https://en.wikipedia.org/wiki/Minkowski_Portal_Refinement
.. _GJK: https://en.wikipedia.org/wiki/Gilbert%E2%80%93Johnson%E2%80%93Keerthi_distance_algorithm
.. _EPA: http://scroll.stanford.edu/courses/cs468-01-fall/Papers/van-den-bergen.pdf

両方のパイプラインは、距離単位の許容誤差と最大反復回数パラメータによって制御されます。それぞれ ``mjOption.ccd_tolerance`` （ :ref:`ccd_tolerance<option-ccd_tolerance>` ）および ``mjOption.ccd_iterations`` （ :ref:`ccd_iterations<option-ccd_iterations>` ）として公開されています。

.. _coMultiCCD:

複数接触
^^^^^^^^
一部のコライダーは、2つの平坦な物体が接触する場合のように線接触や面接触をモデル化するため、衝突ペアあたり複数の接触を返すことができます。例えば、カプセル-平面コライダーとボックス-平面コライダーはそれぞれ最大2つまたは4つの接触を返すことができます。MPRやGJKのような標準的な汎用凸衝突アルゴリズムは常に単一の接触点を返しますが、これは面接触のシナリオ（例えばボックスの積み重ね）では問題となります。MuJoCoの両方のCCDパイプラインは接触ペアあたり複数の点を返すことができます（"multiccd"）。この挙動は :ref:`multiccd<option-flag-multiccd>` フラグによって制御されますが、異なるトレードオフを持つ異なる方法で実装されています。

libccdパイプライン（レガシー）
  2つのジオムを接線軸周りに±1e-3ラジアン回転させ、衝突ルーチンを再実行することで複数の接触点を見つけます。新しい接触が検出された場合追加され、最大4つの追加接触点が得られます。この方法は効果的ですが、各衝突呼び出しのコストを5倍にします。

ネイティブパイプライン
  ネイティブmulticcdは、解における接触面の新しい分析を使用して複数の接触を発見し、衝突ルーチンの完全な再実行を避けるため、実質的に「無料」です。ネイティブmulticcdは現在、正の接触マージンをサポートしていないことに注意してください。2つのジオムの一方が正のマージンを持つ場合、ネイティブmulticcdはレガシーアルゴリズムにフォールバックします。

.. _coDistance:

.. image:: ../images/computation/ccd_light.gif
   :width: 25%
   :align: right
   :class: only-light

.. image:: ../images/computation/ccd_dark.gif
   :width: 25%
   :align: right
   :class: only-dark

ジオム距離
^^^^^^^^^^

:ref:`上述<coChecking>` のナローフェーズ衝突関数は :ref:`mj_geomDistance` 関数と関連する :ref:`collision-sensors` を駆動します。MPRの制限により、レガシーパイプラインはジオムサイズに対して非常に小さい距離を除いて不正確な値を返し（上）、このユースケースには推奨されません。対照的に、GJKベースのネイティブパイプライン（下）はすべての距離で正しい値を計算します。

.. _coDecomposition:

凸分解
^^^^^^

ハイトフィールド以外の非凸オブジェクトをモデル化するには、ユーザーはそれを凸ジオムの和集合（プリミティブ形状またはメッシュ）に分解し、同じボディに取り付ける必要があります。このルールのもう一つの例外（ハイトフィールド以外）は :ref:`符号付き距離関数<exSDF>` （関連ドキュメントを参照）であり、特定のケース（例えば `解析的SDF <https://github.com/google-deepmind/mujoco/blob/main/plugin/sdf/README.md#gear>`__ ）では効率的ですが、他の要件と制限があります。

`CoACDライブラリ <https://github.com/SarahWeiii/CoACD>`__ のようなオープンソースのメッシュ分解ツールをMuJoCoの外部で使用してこのプロセスを自動化できます。最後に、すべての組み込み衝突関数はカスタムコールバックに置き換えることができます。これは例えば汎用の「トライアングルスープ」衝突検出器を組み込むために使用できます。しかし、このようなアプローチは推奨しません。ジオメトリを前処理し凸ジオムの和集合として表現するには作業が必要ですが、実行時に報われ、より高速かつより安定したシミュレーションが得られます。

.. _coPairwise:

ペアワイズコライダー
^^^^^^^^^^^^^^^^^^^^

以下の表は、異なるジオムペアに使用されるコライダーの情報を提供します。各セルの2行目は、 ``multiccd`` が有効な場合を含む、生成される最大接触数を示しています。例えば、 ``Mesh`` / ``Mesh`` は最大1つの接触を生成し、 ``multiccd`` を有効にすると最大4つの接触を生成します。

.. list-table::
   :header-rows: 1
   :stub-columns: 1
   :widths: auto
   :class: table-pairwise

   * -
     - Sphere
     - Capsule
     - Ellipsoid
     - Cylinder
     - Box
     - Mesh
     - SDF
   * - Plane
     - | primitive
       | **1**
     - | primitive
       | **2**
     - | primitive
       | **1**
     - | primitive
       | **2**
     - | primitive
       | **4**
     - | primitive
       | **3**
     - | primitive
       | **1**
   * - HField
     - | HFieldCCD
       | :ref:`mjMAXCONPAIR <glNumeric>`
     - | HFieldCCD
       | :ref:`mjMAXCONPAIR <glNumeric>`
     - | HFieldCCD
       | :ref:`mjMAXCONPAIR <glNumeric>`
     - | HFieldCCD
       | :ref:`mjMAXCONPAIR <glNumeric>`
     - | HFieldCCD
       | :ref:`mjMAXCONPAIR <glNumeric>`
     - | HFieldCCD
       | :ref:`mjMAXCONPAIR <glNumeric>`
     - | HFieldSDF
       | :ref:`sdf_initpoints <option-sdf_initpoints>`
   * - Sphere
     - | primitive
       | **1**
     - | primitive
       | **1**
     - | CCD
       | **1**
     - | primitive
       | **1**
     - | primitive
       | **1**
     - | CCD
       | **1**
     - | SDF
       | :ref:`sdf_initpoints <option-sdf_initpoints>`
   * - Capsule
     -
     - | primitive
       | **2**
     - | CCD
       | **1**
     - | CCD
       | **1**, **4**
     - | primitive
       | **2**
     - | CCD
       | **1**, **4**
     - | SDF
       | :ref:`sdf_initpoints <option-sdf_initpoints>`
   * - Ellipsoid
     -
     -
     - | CCD
       | **1**
     - | CCD
       | **1**
     - | CCD
       | **1**
     - | CCD
       | **1**
     - | SDF
       | :ref:`sdf_initpoints <option-sdf_initpoints>`
   * - Cylinder
     -
     -
     -
     - | CCD
       | **1**, **4**
     - | CCD
       | **1**, **4**
     - | CCD
       | **1**, **4**
     - | SDF
       | :ref:`sdf_initpoints <option-sdf_initpoints>`
   * - Box
     -
     -
     -
     -
     - | primitive
       | **8**
     - | CCD
       | **1**, **4**
     - | SDF
       | :ref:`sdf_initpoints <option-sdf_initpoints>`
   * - Mesh
     -
     -
     -
     -
     -
     - | CCD
       | **1**, **4**
     - | MeshSDF
       | :ref:`sdf_initpoints <option-sdf_initpoints>`
   * - SDF
     -
     -
     -
     -
     -
     -
     - | SDF
       | :ref:`sdf_initpoints <option-sdf_initpoints>`

.. _Sleeping:

スリーピングアイランド
----------------------

スリーピングとは、静止していると検出されたシミュレーションの可動要素をパイプラインから一時的に除外する（「スリープ状態にする」）パフォーマンス最適化です。この最適化は、モデルに多数の受動的オブジェクトが含まれる場合に最も有用です。スリープまたは覚醒できる最小単位は :ref:`キネマティックツリー<ElemTree>` ですが、ツリーは常に制約で接続された他のツリーと一緒にスリープ状態になるため、「スリーピング :ref:`アイランド<soIsland>` 」という用語が使われます。

.. youtube:: vct493lGQ8Q
   :align: right
   :width: 50%

右のビデオはスリーピングのいくつかの側面を示しています。まず、伝統的なドミノ倒しの「連鎖反応」をシミュレートする `ドミノ <https://github.com/google-deepmind/mujoco/blob/main/model/sleep/dominos.xml>`__ モデルを示します。1つを除くすべてのブロックは安定平衡にあり、すぐにスリープ状態になりますが、不安定な最初のブロックは覚醒状態のまま倒れ始めます。覚醒中のブロックとスリープ中のブロックの間で接触が発生するたびに、後者は自動的に起こされます。地面で安定した後、ブロックの山は再びスリープ状態になり、関連する接触は消えます。このシーケンスはアイランド可視化を有効にして繰り返されます。アイランド可視化ではジオムがそのアイランドの最初のDOFに応じて再着色され、スリープ中はより暗い色が使用されます。サブクリップの最後に、スリーピングのオン/オフが切り替えられ、スリーピングによる速度向上が示されます（右下）。2番目のサブクリップは `100体のヒューマノイド <https://github.com/google-deepmind/mujoco/blob/main/model/sleep/100_humanoids.xml>`__ モデルのバリアントを示しており、すべてのヒューマノイドが *スリープ状態で初期化* されています。スリープ状態で初期化されたツリーは、空中に浮いている状態や深い貫通状態など、任意の構成を取ることができます。1体のヒューマノイドがユーザーの直接的な摂動によって手動で起こされ、触れた他のヒューマノイドを起こしながら引きずり回されます。

スムーズダイナミクスもスリーピングの恩恵を受けますが、最大の高速化は接触数の削減によるものです。スリーピングアイランドは衝突検出の目的では静的ボディのように振る舞います：アイランド内のすべての接触およびアイランドと静的ボディ間の接触はスキップされます。オブジェクトの静的な積み重ねの場合、スキップされる接触の数は多くなり、大幅な速度向上につながります。スリーピングアイランドと覚醒中のツリー間の接触は許可されており、実際にこれが覚醒の主な自動トリガーですが、手動での覚醒もサポートされています。覚醒はパイプラインの :ref:`位置ステージ <piStages>` で発生するため実質的に瞬時であり、起こされたアイランドはずっと覚醒していたかのように正確に振る舞います。

スリーピングはデフォルトでオフであり、 :ref:`sleep<option-flag-sleep>` フラグを使用して有効にします。スリーピングメカニズムの詳細な説明は :ref:`シミュレーションの章<siSleep>` で提供されていますが、ここでは簡単な概要を示します。

スリーピングは2つの方法のいずれかで発生します：

- **自動：** 絶対値での最大速度が :ref:`mjMINAWAKE <glNumeric>` タイムステップの間 :ref:`許容値 <option-sleep_tolerance>` 未満であるツリーは「スリープ準備完了」とマークされます。アイランド内のすべてのツリーがスリープ準備完了であれば、状態の前進時にスリープ状態にされます。
- **スリープ初期化：** ツリールートの :ref:`body/sleep<body-sleep>` 属性を"init"に設定することで、「スリープ初期化」とマークされ、 :ref:`mjData` の初期化時にスリープ状態にされます。

.. _Pipeline:

シミュレーションパイプライン
----------------------------

ここでは、順動力学と逆動力学にそれぞれ関わる計算のシーケンスを要約します。その大部分はすでに説明しました。 ``mjModel.opt.disableflags`` と ``mjModel.opt.enableflags`` のビットフラグを使用して、デフォルトのステップをスキップしたり、オプションのステップを有効にしたりできることに留意してください。コールバックはここでは示しません。

.. _piForward:

順動力学
~~~~~~~~

ソースファイル `engine_forward.c <https://github.com/google-deepmind/mujoco/blob/main/src/engine/engine_forward.c>`__ には、高レベルの順動力学パイプラインが含まれています。

トップレベル
^^^^^^^^^^^^
- トップレベル関数 :ref:`mj_step` は以下のステージ **1-26** のシーケンス全体を呼び出します。
- :ref:`mj_forward` はステージ **2-23** のみを呼び出し、連続時間の順動力学を計算して加速度 ``mjData.qacc`` で終了します。
- :ref:`mj_step1` はステージ **1-19** を呼び出し、 :ref:`mj_step2` はステージ **20-26** を呼び出します。これにより :ref:`mj_step` が2つの異なるフェーズに分割されます。これにより、ユーザーは位置と速度から導出される量に依存するコントローラを書くことができます（ただし力はまだ計算されていないため依存できません）。 :ref:`mj_step1` → :ref:`mj_step2` パイプラインはルンゲ・クッタ積分器をサポートしないことに注意してください。
- :ref:`mj_fwdPosition` はステージ **2-11** 、パイプラインの位置依存部分を呼び出します。

.. the table below was created and is editable in tablesgenerator.com

順動力学パイプラインの概略的な内訳：

.. table::
   :class: small-centered no-stripes

   +-------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------+
   | top-level functions     |                                                    :ref:`mj_step`                                                                               |
   |                         +----------------------------------------------------------------------------------------------------------------+--------------------------------+
   |                         |                                   :ref:`mj_step1`                                                              |          :ref:`mj_step2`       |
   |                         +----------------------------------------------------------------------------------------------------------------+--------------+-------+---------+
   |                         |                                      :ref:`mj_forward`                                                                        |       |         |
   +=========================+===+=============================================================+====+====================================+====+==============+=======+=========+
   | component / description |   |             :ref:`fwdPosition<mj_fwdPosition>`              |    | :ref:`fwdVelocity<mj_fwdVelocity>` |    |              |       |         |
   |                         +---+----------------------------------------+--------------------+----+------------------------------------+----+--------------+-------+---------+
   |                         |   | :ref:`fwdKinematics<mj_fwdKinematics>` | inertia, collision |    |                                    |    | acceleration |       | advance |
   +-------------------------+---+----------------------------------------+--------------------+----+------------------------------------+----+--------------+-------+---------+
   | stage                   | 1 |         2-5                            |         6-11       | 12 |         13-18                      | 19 |    20-23     | 24,25 |     26  |
   +-------------------------+---+----------------------------------------+--------------------+----+------------------------------------+----+--------------+-------+---------+


.. _piStages:

ステージ
^^^^^^^^
以下では、パイプラインのステージと各ステージに対応するAPI関数を説明します。すべての関数はその出力を :ref:`mjData` の属性に書き込みます。以下のリストを :ref:`mjData` の構造体定義と比較すると有益です。構造体定義では、属性ブロックの上のコメントがそれらを計算する関数を指定しています。各ステージは前のステージの一部またはすべてで計算された値に依存することに注意してください。

1. 位置と速度に、発散を示す無効または許容できないほど大きな実数値がないかチェックします。発散が検出された場合、状態は自動的にリセットされ、対応する警告が発生します： :ref:`mj_checkPos` 、 :ref:`mj_checkVel`

位置
''''
以下のステージは一般化位置 ``mjData.qpos`` に依存する量を計算します。

2. 順運動学を計算します。これにより、すべてのボディ、ジオム、サイト、カメラ、ライトのグローバルな位置と方向が得られます。また、すべてのクォータニオンを正規化します： :ref:`mj_kinematics` 、 :ref:`mj_camLight`
3. ボディの慣性とジョイント軸を、対応するキネマティックサブツリーの重心に中心を置いたグローバルフレームで計算します： :ref:`mj_comPos`
4. :ref:`フレックス<deformable-flex>` オブジェクトに関連する量を計算します： :ref:`mj_flex`
5. テンドンの長さとモーメントアームを計算します。これには空間テンドンの最短経路の計算が含まれます： :ref:`mj_tendon`
6. 複合剛体慣性と関節空間慣性行列を計算します： :ref:`mj_makeM`
7. 関節空間慣性行列の疎分解を計算します： :ref:`mj_factorM`
8. アクティブな接触のリストを構成します。これにはブロードフェーズとニアフェーズの両方の衝突検出が含まれます： :ref:`mj_collision`
9. 制約ヤコビアンを構成し、制約残差を計算し、アイランドを構成します： :ref:`mj_makeConstraint` 、 ``mj_island`` （まだAPIで公開されていません）
10. アクチュエータの長さとモーメントアームを計算します： :ref:`mj_transmission`
11. 制約ソルバーに必要な行列とベクトルを計算します： :ref:`mj_projectConstraint`
12. 位置のみに依存するセンサーデータ、および有効な場合はポテンシャルエネルギーを計算します： :ref:`mj_sensorPos` 、 :ref:`mj_energyPos`

速度
''''
以下のステージは一般化速度 ``mjData.qvel`` に依存する量を計算します。パイプラインの逐次的な依存構造のため、実際の依存関係は ``qpos`` と ``qvel`` の両方にあります。

13. テンドン、フレックスエッジ、アクチュエータの速度を計算します： :ref:`mj_fwdVelocity`
14. ボディの速度とジョイント軸の変化率を、サブツリーの重心に中心を置いたグローバル座標フレームで計算します： :ref:`mj_comVel`
15. 受動力（ジョイントとテンドンのバネ・ダンパー、および流体力）を計算します： :ref:`mj_passive`
16. 速度に依存するセンサーデータ、および有効な場合は運動エネルギーを計算します（センサーが必要とする場合、 :ref:`mj_subtreeVel` を呼び出します）： :ref:`mj_sensorVel`
17. 参照制約加速度を計算します： :ref:`mj_referenceConstraint`
18. コリオリ力、遠心力、重力のベクトルを計算します： :ref:`mj_rne`

制御コールバック
''''''''''''''''
19. ユーザー定義の制御コールバックが定義されていれば呼び出します： :ref:`mjcb_control`

力/加速度
'''''''''
以下のステージは :ref:`ユーザー入力<siInput>` に依存する量を計算します。パイプラインの逐次的な性質のため、実際の依存関係は :ref:`積分状態<siIntegrationState>` 全体にあります。

20. アクチュエータ力と、定義されていれば活性化ダイナミクスを計算します： :ref:`mj_fwdActuation`
21. （まだ未知の）制約力を除くすべての力から生じる関節加速度を計算します： :ref:`mj_fwdAcceleration`
22. 選択されたソルバーで制約力を計算し、制約力を考慮して関節加速度を更新します。これにより順動力学の主要な出力であるベクトル ``mjData.qacc`` が得られます： :ref:`mj_fwdConstraint`
23. 有効な場合、力と加速度に依存するセンサーデータを計算します（センサーが必要とする場合、 :ref:`mj_rnePostConstraint` を呼び出します）： :ref:`mj_sensorAcc`
24. 加速度に無効または許容できないほど大きな実数値がないかチェックします。発散が検出された場合、状態は自動的にリセットされ、対応する警告が発生します： :ref:`mj_checkAcc`
25. 順動力学と逆動力学の結果を比較し、順動力学におけるソルバーの収束不良を診断します。これはオプションのステップであり、有効にされた場合のみ実行されます： :ref:`mj_compareFwdInv`
26. 選択された積分器を使用してシミュレーション状態を1タイムステップ進めます。ルンゲ・クッタ積分器は上記のシーケンスをさらに3回繰り返しますが、オプションの計算は1回のみ実行されることに注意してください： :ref:`mj_Euler` 、 :ref:`mj_RungeKutta` 、 :ref:`mj_implicit` のいずれか

.. _piConsistency:

``mjData`` の一貫性
~~~~~~~~~~~~~~~~~~~
MuJoCoの計算パイプラインは完全に命令的であり、何も自動的には起こりません。これにより、他のパラダイムに慣れているユーザーには予期しないように見える動作が生じます。以下は、時として驚きとなり得る意図された動作の2つの例です：

- :ref:`状態<geState>` を設定した後、状態から導出される量は自動的に新しい状態に対応しません。必要なステージを手動で呼び出す必要があります。例えば、一般化位置 ``mjData.qpos`` を設定した後、デカルト座標の位置と方向は :ref:`mj_kinematics` を最初に呼び出さない限り ``qpos`` と一貫しません。
- :ref:`mj_step` の後（状態の更新直後に終了します）、 ``mjData`` の量は *前の* 状態（より正確には、前の状態と現在の状態の間の *遷移* ）に対応します。特に、すべての位置依存のセンサー値とキネマティック :ref:`ヤコビアン<mj_jac>` のような位置依存の計算は、 *前の位置* に対するものになります。



.. _piReproducibility:

再現性
~~~~~~

MuJoCoのシミュレーションパイプラインは完全に決定論的で再現可能です。軌道中の :ref:`状態<geState>` を保存して再読み込みし、 :ref:`mj_step` を再度呼び出した場合、結果の次の状態は同一になります。ただし、いくつかの重要な注意点があります：

- 必要な :ref:`積分状態<siIntegrationState>` のすべてのコンポーネントを保存してください。特に :ref:`ウォームスタート加速度<siWarmstart>` は次の状態にごくわずかな影響しか与えませんが、ビット単位の一致が必要な場合は保存すべきです。
- 状態間のいかなる数値的な差異も、どれほど小さくても、積分時に有意になります。特に接触のあるシステムでは顕著です。接触イベントは高い `リアプノフ指数 <https://en.wikipedia.org/wiki/Lyapunov_exponent>`__ を持ちます。これはあらゆる剛体シミュレータ（そして実際には `現実世界の物理 <https://en.wikipedia.org/wiki/Roulette>`__ ）の性質であり、MuJoCo固有のものではありません。
- 厳密な再現性は **同一バージョン** 内で **同一アーキテクチャ** 上でのみ保証されます。小さな数値的差異はバージョンリリース間ではかなり一般的であり、例えばコードの最適化によるものです。これは、初期状態とオープンループの制御シーケンスを保存する場合、展開された軌道は同一バージョン内では同一になりますが、MuJoCoのバージョン間や異なるオペレーティングシステム間では異なる可能性が高いことを意味します。

.. _piInverse:

逆動力学
~~~~~~~~

トップレベル関数 :ref:`mj_inverse` は以下の計算シーケンスを呼び出します。 :ref:`一貫性<piConsistency>` と :ref:`再現性<piReproducibility>` に関する上記の注意点はここでも適用されます。

#. 順運動学を計算する。
#. ボディの慣性とジョイント軸を計算する。
#. テンドンの長さとモーメントアームを計算する。
#. アクチュエータの長さとモーメントアームを計算する。
#. 複合剛体慣性を計算し、関節空間慣性行列を構成する。
#. 関節空間慣性行列の疎分解を計算する。
#. アクティブな接触のリストを構成する。
#. 制約ヤコビアンを構成し、制約残差を計算する。
#. 位置のみに依存するセンサーデータ、および有効な場合はポテンシャルエネルギーを計算する。
#. テンドンとアクチュエータの速度を計算する。
#. ボディの速度とジョイント軸の変化率を計算する。
#. 速度に依存するセンサーデータ、および有効な場合は運動エネルギーを計算する。センサーが必要とする場合、 :ref:`mj_subtreeVel` を呼び出す。
#. すべての受動力を計算する。
#. 参照制約加速度を計算する。
#. :ref:`invdiscrete<option-flag-invdiscrete>` フラグが設定されており、 :ref:`積分器<option-integrator>` が ``RK4`` でない場合、入力加速度を離散時間から連続時間に変換する。
#. 制約力を計算する。これは数値ソルバーを使用せず解析的に行われる。
#. 制約なしシステムの逆動力学を計算する。
#. 有効な場合、力と加速度に依存するセンサーデータを計算する。センサーが必要とする場合、 :ref:`mj_rnePostConstraint` を呼び出す。
#. すべての結果を組み合わせてベクトル ``mjData.qfrc_inverse`` を計算する。これは逆動力学の主要な出力であり、外力とアクチュエーション力の和に等しい。


.. _derivatives:

導関数
------

MuJoCoの制約ソルバーを含む計算パイプライン全体は、原理的には解析的に微分可能です。これらの導関数の効率的な実装を書くことは開発チームの長期的な目標です。スムーズダイナミクス（制約を除く）の速度に関する解析的導関数はすでに計算されており、2つの :ref:`陰的積分器<geIntegration>` を可能にしています。

:ref:`ソルバーインピーダンス<CSolverImpedance>` のデフォルト値は、デフォルトでは接触が微分可能で *ない* ように設定されており、接触力の発生を滑らかにするには :ref:`0に設定<solimp0>` する必要があることに注意してください。

効率的な有限差分を使用してダイナミクスヤコビアンを計算する2つの関数が現在利用可能です：

:ref:`mjd_transitionFD`:
  離散時間順動力学（ :ref:`mj_step` ）の状態遷移ヤコビアンと制御遷移ヤコビアンを計算します。 :ref:`ドキュメント<mjd_transitionFD>` を参照してください。

:ref:`mjd_inverseFD`:
  連続時間または離散時間逆動力学（ :ref:`mj_inverse` ）のヤコビアンを計算します。 :ref:`ドキュメント<mjd_inverseFD>` を参照してください。

これらの導関数は、MuJoCoの構成可能な計算パイプラインを活用し、不要な場合に量を再計算しないことで効率化されています。例えば、制御に関して差分を取る場合、位置と速度にのみ依存する量は再計算されません。さらに、ソルバーのウォームスタート、クォータニオン、制御のクランプが正しく処理されます。前方差分と中心差分の両方がサポートされています。


.. _References:

参考文献
--------

ここでは、参考文献の簡潔な注釈付きリストを提供し、本文との関連を示します。

ロボットの運動学と動力学を計算するための再帰的アルゴリズムには長い歴史があります。Featherstoneの著書が標準的な参考文献です。RNEおよびCRBアルゴリズムの実装と疎慣性行列分解はこれに基づいています。

   R. Featherstone. Rigid Body Dynamics Algorithms. Springer, 2008.

凸メッシュ衝突に使用するMPRアルゴリズムはSnethenによって導入されました。

   G. Snethen. Complex collision made simple, Game Programming Gems 7, 165-178, 2008.

ここで議論したが実際には使用しなかった、接触モデリングへの線形相補性（LCP）アプローチは、StewartとTrinkleによって導入されました。これは多くのより最近の論文がある十分に発展した分野であることに注意してください。

   D. Stewart and J. Trinkle. An implicit time-stepping scheme for rigid-body dynamics with inelastic collisions and
   coulomb friction. International Journal Numerical Methods Engineering, 39:2673-2691, 1996.

次に、我々の制約モデルとそのガウスの原理における根源に関連する先行研究について述べます。UdwadiaとKalabaは、ガウスの原理を一般化する可能性を指摘することで、この原理への関心を復活させました。

   F. Udwadia and R. Kalaba. A new perspective on constrained motion. Proceedings of the Royal Society, 1992.

接触モデリングに関連する最初のそのような一般化はRedonらによって行われました。彼らはガウスの原理を加速度に対する不等式制約を含むように拡張し、摩擦なしの接触をモデル化するために使用しました。この結果、凸二次計画問題（QP）が得られました。

   S. Redon, A. Kheddar and S. Coquillart. Gauss's least constraint principle and rigid body simulations. IEEE
   International Conference on Robotics and Automation, 2002.

LCP問題をより扱いやすい問題で近似する試みとして、Anitescuは加速度に関するQPを提案しました。これは本質的にここで開発した接触モデルのハード極限です。Redonらの以前のモデルとの違いは、接触あたり単一の不等式（法線方向のみ）を使用する代わりに、Anitescuは角錐を形成する複数の不等式を使用したことです。凸の相補性フリーモデルにおいて摩擦なしから摩擦ありの接触に移行するために必要なのはこれだけです。

   M. Anitescu. Optimization-based simulation of nonsmooth rigid multibody dynamics. Math. Program. Ser. A, 105:113-143,
   2006.

DrumwrightとShellは接触力に関するQPを提案しました。これはAnitescuが以前開発したQPの双対であり、やはりハード接触に限定されています。

   E. Drumwright and D. Shell, Modeling contact friction and joint friction in dynamic robotic simulation using the
   principle of maximum dissipation. International Workshop on the Algorithmic Foundations of Robotics, 2010.

我々の現在のモデルの最初のバージョンは以下の論文で開発されました。これも凸最適化問題でしたが、ソフト接触やその他の制約を許容し、一意に定義された逆を持っていました。

   E. Todorov. A convex, smooth and invertible contact model for trajectory optimization. IEEE International Conference
   on Robotics and Automation, 2011.

摩擦接触のこれらの凸モデルはいずれも、本章で行ったようにガウスの原理から体系的に導出されたものではありません。ここで開発した拡張ダイナミクスは新しいものです。連続時間定式化も新しく、離散時間における「速度ステッピング」スキームに依存する現代の接触ソルバーからの転換です。

ソフト制約モデルの獲得方法は、Open Dynamics Engine（ODE）のconstraint force mixing（CFM）パラメータを連想させます。ただし、ODEはLCPの定式化に基づいており、異なる問題を解いています。

   R. Smith. Open Dynamics Engine user guide. 2006.

Lacoursièreは「ゴースト変数」を導入しましたが、これは我々の変形ダイナミクスに関連しているように見えます。しかし、それらは（その名前が示すように）やや解釈が難しく、我々のモデルとの正確な関係は明確化が残されています。

   C. Lacoursiere. Ghosts and machines: Regularized variational methods for interactive simulations of multibodies with
   dry frictional contacts. PhD Thesis, Umea University, 2007.
